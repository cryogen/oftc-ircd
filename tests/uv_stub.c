/* OPMOCK2 GENERATED CODE - DO NOT MODIFY */
#include "uv_stub.h"
#include <stdio.h>
#include <string.h>

typedef struct
{
    unsigned int to_return;
    char check_params;
} uv_version_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_version_CALLBACK callback;
    uv_version_call calls[MAX_FUNC_CALL];
} uv_version_struct;

static uv_version_struct uv_version_struct_inst;

typedef struct
{
     char * to_return;
    char check_params;
} uv_version_string_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_version_string_CALLBACK callback;
    uv_version_string_call calls[MAX_FUNC_CALL];
} uv_version_string_struct;

static uv_version_string_struct uv_version_string_struct_inst;

typedef struct
{
    struct uv_loop_s * to_return;
    char check_params;
} uv_default_loop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_default_loop_CALLBACK callback;
    uv_default_loop_call calls[MAX_FUNC_CALL];
} uv_default_loop_struct;

static uv_default_loop_struct uv_default_loop_struct_inst;

typedef struct
{
    void * loop;
    OPMOCK_MATCHER match_loop;
    int to_return;
    char check_params;
} uv_loop_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loop_init_CALLBACK callback;
    uv_loop_init_call calls[MAX_FUNC_CALL];
} uv_loop_init_struct;

static uv_loop_init_struct uv_loop_init_struct_inst;

typedef struct
{
    void * loop;
    OPMOCK_MATCHER match_loop;
    int to_return;
    char check_params;
} uv_loop_close_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loop_close_CALLBACK callback;
    uv_loop_close_call calls[MAX_FUNC_CALL];
} uv_loop_close_struct;

static uv_loop_close_struct uv_loop_close_struct_inst;

typedef struct
{
    struct uv_loop_s * to_return;
    char check_params;
} uv_loop_new_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loop_new_CALLBACK callback;
    uv_loop_new_call calls[MAX_FUNC_CALL];
} uv_loop_new_struct;

static uv_loop_new_struct uv_loop_new_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    char check_params;
} uv_loop_delete_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loop_delete_CALLBACK callback;
    uv_loop_delete_call calls[MAX_FUNC_CALL];
} uv_loop_delete_struct;

static uv_loop_delete_struct uv_loop_delete_struct_inst;

typedef struct
{
    unsigned long to_return;
    char check_params;
} uv_loop_size_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loop_size_CALLBACK callback;
    uv_loop_size_call calls[MAX_FUNC_CALL];
} uv_loop_size_struct;

static uv_loop_size_struct uv_loop_size_struct_inst;

typedef struct
{
    void * loop;
    OPMOCK_MATCHER match_loop;
    int to_return;
    char check_params;
} uv_loop_alive_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loop_alive_CALLBACK callback;
    uv_loop_alive_call calls[MAX_FUNC_CALL];
} uv_loop_alive_struct;

static uv_loop_alive_struct uv_loop_alive_struct_inst;

typedef struct
{
    void * arg1;
    uv_run_mode mode;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_mode;
    int to_return;
    char check_params;
} uv_run_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_run_CALLBACK callback;
    uv_run_call calls[MAX_FUNC_CALL];
} uv_run_struct;

static uv_run_struct uv_run_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    char check_params;
} uv_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_stop_CALLBACK callback;
    uv_stop_call calls[MAX_FUNC_CALL];
} uv_stop_struct;

static uv_stop_struct uv_stop_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    char check_params;
} uv_ref_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_ref_CALLBACK callback;
    uv_ref_call calls[MAX_FUNC_CALL];
} uv_ref_struct;

static uv_ref_struct uv_ref_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    char check_params;
} uv_unref_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_unref_CALLBACK callback;
    uv_unref_call calls[MAX_FUNC_CALL];
} uv_unref_struct;

static uv_unref_struct uv_unref_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    int to_return;
    char check_params;
} uv_has_ref_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_has_ref_CALLBACK callback;
    uv_has_ref_call calls[MAX_FUNC_CALL];
} uv_has_ref_struct;

static uv_has_ref_struct uv_has_ref_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    char check_params;
} uv_update_time_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_update_time_CALLBACK callback;
    uv_update_time_call calls[MAX_FUNC_CALL];
} uv_update_time_struct;

static uv_update_time_struct uv_update_time_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    unsigned long long to_return;
    char check_params;
} uv_now_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_now_CALLBACK callback;
    uv_now_call calls[MAX_FUNC_CALL];
} uv_now_struct;

static uv_now_struct uv_now_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    int to_return;
    char check_params;
} uv_backend_fd_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_backend_fd_CALLBACK callback;
    uv_backend_fd_call calls[MAX_FUNC_CALL];
} uv_backend_fd_struct;

static uv_backend_fd_struct uv_backend_fd_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    int to_return;
    char check_params;
} uv_backend_timeout_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_backend_timeout_CALLBACK callback;
    uv_backend_timeout_call calls[MAX_FUNC_CALL];
} uv_backend_timeout_struct;

static uv_backend_timeout_struct uv_backend_timeout_struct_inst;

typedef struct
{
    int err;
    OPMOCK_MATCHER match_err;
     char * to_return;
    char check_params;
} uv_strerror_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_strerror_CALLBACK callback;
    uv_strerror_call calls[MAX_FUNC_CALL];
} uv_strerror_struct;

static uv_strerror_struct uv_strerror_struct_inst;

typedef struct
{
    int err;
    OPMOCK_MATCHER match_err;
     char * to_return;
    char check_params;
} uv_err_name_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_err_name_CALLBACK callback;
    uv_err_name_call calls[MAX_FUNC_CALL];
} uv_err_name_struct;

static uv_err_name_struct uv_err_name_struct_inst;

typedef struct
{
    void * req;
    void * handle;
    void * cb;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_shutdown_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_shutdown_CALLBACK callback;
    uv_shutdown_call calls[MAX_FUNC_CALL];
} uv_shutdown_struct;

static uv_shutdown_struct uv_shutdown_struct_inst;

typedef struct
{
    uv_handle_type type;
    OPMOCK_MATCHER match_type;
    unsigned long to_return;
    char check_params;
} uv_handle_size_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_handle_size_CALLBACK callback;
    uv_handle_size_call calls[MAX_FUNC_CALL];
} uv_handle_size_struct;

static uv_handle_size_struct uv_handle_size_struct_inst;

typedef struct
{
    uv_req_type type;
    OPMOCK_MATCHER match_type;
    unsigned long to_return;
    char check_params;
} uv_req_size_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_req_size_CALLBACK callback;
    uv_req_size_call calls[MAX_FUNC_CALL];
} uv_req_size_struct;

static uv_req_size_struct uv_req_size_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_is_active_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_is_active_CALLBACK callback;
    uv_is_active_call calls[MAX_FUNC_CALL];
} uv_is_active_struct;

static uv_is_active_struct uv_is_active_struct_inst;

typedef struct
{
    void * loop;
    void * walk_cb;
    void * arg;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_walk_cb;
    OPMOCK_MATCHER match_arg;
    char check_params;
} uv_walk_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_walk_CALLBACK callback;
    uv_walk_call calls[MAX_FUNC_CALL];
} uv_walk_struct;

static uv_walk_struct uv_walk_struct_inst;

typedef struct
{
    void * handle;
    void * close_cb;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_close_cb;
    char check_params;
} uv_close_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_close_CALLBACK callback;
    uv_close_call calls[MAX_FUNC_CALL];
} uv_close_struct;

static uv_close_struct uv_close_struct_inst;

typedef struct
{
    void * handle;
    void * value;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_value;
    int to_return;
    char check_params;
} uv_send_buffer_size_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_send_buffer_size_CALLBACK callback;
    uv_send_buffer_size_call calls[MAX_FUNC_CALL];
} uv_send_buffer_size_struct;

static uv_send_buffer_size_struct uv_send_buffer_size_struct_inst;

typedef struct
{
    void * handle;
    void * value;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_value;
    int to_return;
    char check_params;
} uv_recv_buffer_size_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_recv_buffer_size_CALLBACK callback;
    uv_recv_buffer_size_call calls[MAX_FUNC_CALL];
} uv_recv_buffer_size_struct;

static uv_recv_buffer_size_struct uv_recv_buffer_size_struct_inst;

typedef struct
{
    void * handle;
    void * fd;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_fd;
    int to_return;
    char check_params;
} uv_fileno_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fileno_CALLBACK callback;
    uv_fileno_call calls[MAX_FUNC_CALL];
} uv_fileno_struct;

static uv_fileno_struct uv_fileno_struct_inst;

typedef struct
{
    void * base;
    unsigned int len;
    OPMOCK_MATCHER match_base;
    OPMOCK_MATCHER match_len;
    struct uv_buf_t to_return;
    char check_params;
} uv_buf_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_buf_init_CALLBACK callback;
    uv_buf_init_call calls[MAX_FUNC_CALL];
} uv_buf_init_struct;

static uv_buf_init_struct uv_buf_init_struct_inst;

typedef struct
{
    void * stream;
    int backlog;
    void * cb;
    OPMOCK_MATCHER match_stream;
    OPMOCK_MATCHER match_backlog;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_listen_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_listen_CALLBACK callback;
    uv_listen_call calls[MAX_FUNC_CALL];
} uv_listen_struct;

static uv_listen_struct uv_listen_struct_inst;

typedef struct
{
    void * server;
    void * client;
    OPMOCK_MATCHER match_server;
    OPMOCK_MATCHER match_client;
    int to_return;
    char check_params;
} uv_accept_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_accept_CALLBACK callback;
    uv_accept_call calls[MAX_FUNC_CALL];
} uv_accept_struct;

static uv_accept_struct uv_accept_struct_inst;

typedef struct
{
    void * arg1;
    void * alloc_cb;
    void * read_cb;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_alloc_cb;
    OPMOCK_MATCHER match_read_cb;
    int to_return;
    char check_params;
} uv_read_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_read_start_CALLBACK callback;
    uv_read_start_call calls[MAX_FUNC_CALL];
} uv_read_start_struct;

static uv_read_start_struct uv_read_start_struct_inst;

typedef struct
{
    void * arg1;
    OPMOCK_MATCHER match_arg1;
    int to_return;
    char check_params;
} uv_read_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_read_stop_CALLBACK callback;
    uv_read_stop_call calls[MAX_FUNC_CALL];
} uv_read_stop_struct;

static uv_read_stop_struct uv_read_stop_struct_inst;

typedef struct
{
    void * req;
    void * handle;
    void * bufs;
    unsigned int nbufs;
    void * cb;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_write_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_write_CALLBACK callback;
    uv_write_call calls[MAX_FUNC_CALL];
} uv_write_struct;

static uv_write_struct uv_write_struct_inst;

typedef struct
{
    void * req;
    void * handle;
    void * bufs;
    unsigned int nbufs;
    void * send_handle;
    void * cb;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    OPMOCK_MATCHER match_send_handle;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_write2_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_write2_CALLBACK callback;
    uv_write2_call calls[MAX_FUNC_CALL];
} uv_write2_struct;

static uv_write2_struct uv_write2_struct_inst;

typedef struct
{
    void * handle;
    void * bufs;
    unsigned int nbufs;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    int to_return;
    char check_params;
} uv_try_write_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_try_write_CALLBACK callback;
    uv_try_write_call calls[MAX_FUNC_CALL];
} uv_try_write_struct;

static uv_try_write_struct uv_try_write_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_is_readable_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_is_readable_CALLBACK callback;
    uv_is_readable_call calls[MAX_FUNC_CALL];
} uv_is_readable_struct;

static uv_is_readable_struct uv_is_readable_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_is_writable_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_is_writable_CALLBACK callback;
    uv_is_writable_call calls[MAX_FUNC_CALL];
} uv_is_writable_struct;

static uv_is_writable_struct uv_is_writable_struct_inst;

typedef struct
{
    void * handle;
    int blocking;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_blocking;
    int to_return;
    char check_params;
} uv_stream_set_blocking_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_stream_set_blocking_CALLBACK callback;
    uv_stream_set_blocking_call calls[MAX_FUNC_CALL];
} uv_stream_set_blocking_struct;

static uv_stream_set_blocking_struct uv_stream_set_blocking_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_is_closing_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_is_closing_CALLBACK callback;
    uv_is_closing_call calls[MAX_FUNC_CALL];
} uv_is_closing_struct;

static uv_is_closing_struct uv_is_closing_struct_inst;

typedef struct
{
    void * arg1;
    void * handle;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_tcp_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_init_CALLBACK callback;
    uv_tcp_init_call calls[MAX_FUNC_CALL];
} uv_tcp_init_struct;

static uv_tcp_init_struct uv_tcp_init_struct_inst;

typedef struct
{
    void * handle;
    int sock;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_sock;
    int to_return;
    char check_params;
} uv_tcp_open_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_open_CALLBACK callback;
    uv_tcp_open_call calls[MAX_FUNC_CALL];
} uv_tcp_open_struct;

static uv_tcp_open_struct uv_tcp_open_struct_inst;

typedef struct
{
    void * handle;
    int enable;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_enable;
    int to_return;
    char check_params;
} uv_tcp_nodelay_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_nodelay_CALLBACK callback;
    uv_tcp_nodelay_call calls[MAX_FUNC_CALL];
} uv_tcp_nodelay_struct;

static uv_tcp_nodelay_struct uv_tcp_nodelay_struct_inst;

typedef struct
{
    void * handle;
    int enable;
    unsigned int delay;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_enable;
    OPMOCK_MATCHER match_delay;
    int to_return;
    char check_params;
} uv_tcp_keepalive_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_keepalive_CALLBACK callback;
    uv_tcp_keepalive_call calls[MAX_FUNC_CALL];
} uv_tcp_keepalive_struct;

static uv_tcp_keepalive_struct uv_tcp_keepalive_struct_inst;

typedef struct
{
    void * handle;
    int enable;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_enable;
    int to_return;
    char check_params;
} uv_tcp_simultaneous_accepts_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_simultaneous_accepts_CALLBACK callback;
    uv_tcp_simultaneous_accepts_call calls[MAX_FUNC_CALL];
} uv_tcp_simultaneous_accepts_struct;

static uv_tcp_simultaneous_accepts_struct uv_tcp_simultaneous_accepts_struct_inst;

typedef struct
{
    void * handle;
    void * addr;
    unsigned int flags;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_addr;
    OPMOCK_MATCHER match_flags;
    int to_return;
    char check_params;
} uv_tcp_bind_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_bind_CALLBACK callback;
    uv_tcp_bind_call calls[MAX_FUNC_CALL];
} uv_tcp_bind_struct;

static uv_tcp_bind_struct uv_tcp_bind_struct_inst;

typedef struct
{
    void * handle;
    void * name;
    void * namelen;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_name;
    OPMOCK_MATCHER match_namelen;
    int to_return;
    char check_params;
} uv_tcp_getsockname_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_getsockname_CALLBACK callback;
    uv_tcp_getsockname_call calls[MAX_FUNC_CALL];
} uv_tcp_getsockname_struct;

static uv_tcp_getsockname_struct uv_tcp_getsockname_struct_inst;

typedef struct
{
    void * handle;
    void * name;
    void * namelen;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_name;
    OPMOCK_MATCHER match_namelen;
    int to_return;
    char check_params;
} uv_tcp_getpeername_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_getpeername_CALLBACK callback;
    uv_tcp_getpeername_call calls[MAX_FUNC_CALL];
} uv_tcp_getpeername_struct;

static uv_tcp_getpeername_struct uv_tcp_getpeername_struct_inst;

typedef struct
{
    void * req;
    void * handle;
    void * addr;
    void * cb;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_addr;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_tcp_connect_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tcp_connect_CALLBACK callback;
    uv_tcp_connect_call calls[MAX_FUNC_CALL];
} uv_tcp_connect_struct;

static uv_tcp_connect_struct uv_tcp_connect_struct_inst;

typedef struct
{
    void * arg1;
    void * handle;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_udp_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_init_CALLBACK callback;
    uv_udp_init_call calls[MAX_FUNC_CALL];
} uv_udp_init_struct;

static uv_udp_init_struct uv_udp_init_struct_inst;

typedef struct
{
    void * handle;
    int sock;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_sock;
    int to_return;
    char check_params;
} uv_udp_open_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_open_CALLBACK callback;
    uv_udp_open_call calls[MAX_FUNC_CALL];
} uv_udp_open_struct;

static uv_udp_open_struct uv_udp_open_struct_inst;

typedef struct
{
    void * handle;
    void * addr;
    unsigned int flags;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_addr;
    OPMOCK_MATCHER match_flags;
    int to_return;
    char check_params;
} uv_udp_bind_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_bind_CALLBACK callback;
    uv_udp_bind_call calls[MAX_FUNC_CALL];
} uv_udp_bind_struct;

static uv_udp_bind_struct uv_udp_bind_struct_inst;

typedef struct
{
    void * handle;
    void * name;
    void * namelen;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_name;
    OPMOCK_MATCHER match_namelen;
    int to_return;
    char check_params;
} uv_udp_getsockname_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_getsockname_CALLBACK callback;
    uv_udp_getsockname_call calls[MAX_FUNC_CALL];
} uv_udp_getsockname_struct;

static uv_udp_getsockname_struct uv_udp_getsockname_struct_inst;

typedef struct
{
    void * handle;
    void * multicast_addr;
    void * interface_addr;
    uv_membership membership;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_multicast_addr;
    OPMOCK_MATCHER match_interface_addr;
    OPMOCK_MATCHER match_membership;
    int to_return;
    char check_params;
} uv_udp_set_membership_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_set_membership_CALLBACK callback;
    uv_udp_set_membership_call calls[MAX_FUNC_CALL];
} uv_udp_set_membership_struct;

static uv_udp_set_membership_struct uv_udp_set_membership_struct_inst;

typedef struct
{
    void * handle;
    int on;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_on;
    int to_return;
    char check_params;
} uv_udp_set_multicast_loop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_set_multicast_loop_CALLBACK callback;
    uv_udp_set_multicast_loop_call calls[MAX_FUNC_CALL];
} uv_udp_set_multicast_loop_struct;

static uv_udp_set_multicast_loop_struct uv_udp_set_multicast_loop_struct_inst;

typedef struct
{
    void * handle;
    int ttl;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_ttl;
    int to_return;
    char check_params;
} uv_udp_set_multicast_ttl_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_set_multicast_ttl_CALLBACK callback;
    uv_udp_set_multicast_ttl_call calls[MAX_FUNC_CALL];
} uv_udp_set_multicast_ttl_struct;

static uv_udp_set_multicast_ttl_struct uv_udp_set_multicast_ttl_struct_inst;

typedef struct
{
    void * handle;
    void * interface_addr;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_interface_addr;
    int to_return;
    char check_params;
} uv_udp_set_multicast_interface_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_set_multicast_interface_CALLBACK callback;
    uv_udp_set_multicast_interface_call calls[MAX_FUNC_CALL];
} uv_udp_set_multicast_interface_struct;

static uv_udp_set_multicast_interface_struct uv_udp_set_multicast_interface_struct_inst;

typedef struct
{
    void * handle;
    int on;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_on;
    int to_return;
    char check_params;
} uv_udp_set_broadcast_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_set_broadcast_CALLBACK callback;
    uv_udp_set_broadcast_call calls[MAX_FUNC_CALL];
} uv_udp_set_broadcast_struct;

static uv_udp_set_broadcast_struct uv_udp_set_broadcast_struct_inst;

typedef struct
{
    void * handle;
    int ttl;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_ttl;
    int to_return;
    char check_params;
} uv_udp_set_ttl_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_set_ttl_CALLBACK callback;
    uv_udp_set_ttl_call calls[MAX_FUNC_CALL];
} uv_udp_set_ttl_struct;

static uv_udp_set_ttl_struct uv_udp_set_ttl_struct_inst;

typedef struct
{
    void * req;
    void * handle;
    void * bufs;
    unsigned int nbufs;
    void * addr;
    void * send_cb;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    OPMOCK_MATCHER match_addr;
    OPMOCK_MATCHER match_send_cb;
    int to_return;
    char check_params;
} uv_udp_send_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_send_CALLBACK callback;
    uv_udp_send_call calls[MAX_FUNC_CALL];
} uv_udp_send_struct;

static uv_udp_send_struct uv_udp_send_struct_inst;

typedef struct
{
    void * handle;
    void * bufs;
    unsigned int nbufs;
    void * addr;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    OPMOCK_MATCHER match_addr;
    int to_return;
    char check_params;
} uv_udp_try_send_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_try_send_CALLBACK callback;
    uv_udp_try_send_call calls[MAX_FUNC_CALL];
} uv_udp_try_send_struct;

static uv_udp_try_send_struct uv_udp_try_send_struct_inst;

typedef struct
{
    void * handle;
    void * alloc_cb;
    void * recv_cb;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_alloc_cb;
    OPMOCK_MATCHER match_recv_cb;
    int to_return;
    char check_params;
} uv_udp_recv_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_recv_start_CALLBACK callback;
    uv_udp_recv_start_call calls[MAX_FUNC_CALL];
} uv_udp_recv_start_struct;

static uv_udp_recv_start_struct uv_udp_recv_start_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_udp_recv_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_udp_recv_stop_CALLBACK callback;
    uv_udp_recv_stop_call calls[MAX_FUNC_CALL];
} uv_udp_recv_stop_struct;

static uv_udp_recv_stop_struct uv_udp_recv_stop_struct_inst;

typedef struct
{
    void * arg1;
    void * arg2;
    int fd;
    int readable;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_arg2;
    OPMOCK_MATCHER match_fd;
    OPMOCK_MATCHER match_readable;
    int to_return;
    char check_params;
} uv_tty_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tty_init_CALLBACK callback;
    uv_tty_init_call calls[MAX_FUNC_CALL];
} uv_tty_init_struct;

static uv_tty_init_struct uv_tty_init_struct_inst;

typedef struct
{
    void * arg1;
    int mode;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_mode;
    int to_return;
    char check_params;
} uv_tty_set_mode_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tty_set_mode_CALLBACK callback;
    uv_tty_set_mode_call calls[MAX_FUNC_CALL];
} uv_tty_set_mode_struct;

static uv_tty_set_mode_struct uv_tty_set_mode_struct_inst;

typedef struct
{
    int to_return;
    char check_params;
} uv_tty_reset_mode_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tty_reset_mode_CALLBACK callback;
    uv_tty_reset_mode_call calls[MAX_FUNC_CALL];
} uv_tty_reset_mode_struct;

static uv_tty_reset_mode_struct uv_tty_reset_mode_struct_inst;

typedef struct
{
    void * arg1;
    void * width;
    void * height;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_width;
    OPMOCK_MATCHER match_height;
    int to_return;
    char check_params;
} uv_tty_get_winsize_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_tty_get_winsize_CALLBACK callback;
    uv_tty_get_winsize_call calls[MAX_FUNC_CALL];
} uv_tty_get_winsize_struct;

static uv_tty_get_winsize_struct uv_tty_get_winsize_struct_inst;

typedef struct
{
    int file;
    OPMOCK_MATCHER match_file;
    uv_handle_type to_return;
    char check_params;
} uv_guess_handle_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_guess_handle_CALLBACK callback;
    uv_guess_handle_call calls[MAX_FUNC_CALL];
} uv_guess_handle_struct;

static uv_guess_handle_struct uv_guess_handle_struct_inst;

typedef struct
{
    void * arg1;
    void * handle;
    int ipc;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_ipc;
    int to_return;
    char check_params;
} uv_pipe_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_init_CALLBACK callback;
    uv_pipe_init_call calls[MAX_FUNC_CALL];
} uv_pipe_init_struct;

static uv_pipe_init_struct uv_pipe_init_struct_inst;

typedef struct
{
    void * arg1;
    int file;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_file;
    int to_return;
    char check_params;
} uv_pipe_open_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_open_CALLBACK callback;
    uv_pipe_open_call calls[MAX_FUNC_CALL];
} uv_pipe_open_struct;

static uv_pipe_open_struct uv_pipe_open_struct_inst;

typedef struct
{
    void * handle;
    void * name;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_name;
    int to_return;
    char check_params;
} uv_pipe_bind_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_bind_CALLBACK callback;
    uv_pipe_bind_call calls[MAX_FUNC_CALL];
} uv_pipe_bind_struct;

static uv_pipe_bind_struct uv_pipe_bind_struct_inst;

typedef struct
{
    void * req;
    void * handle;
    void * name;
    void * cb;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_name;
    OPMOCK_MATCHER match_cb;
    char check_params;
} uv_pipe_connect_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_connect_CALLBACK callback;
    uv_pipe_connect_call calls[MAX_FUNC_CALL];
} uv_pipe_connect_struct;

static uv_pipe_connect_struct uv_pipe_connect_struct_inst;

typedef struct
{
    void * handle;
    void * buf;
    void * len;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_buf;
    OPMOCK_MATCHER match_len;
    int to_return;
    char check_params;
} uv_pipe_getsockname_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_getsockname_CALLBACK callback;
    uv_pipe_getsockname_call calls[MAX_FUNC_CALL];
} uv_pipe_getsockname_struct;

static uv_pipe_getsockname_struct uv_pipe_getsockname_struct_inst;

typedef struct
{
    void * handle;
    int count;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_count;
    char check_params;
} uv_pipe_pending_instances_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_pending_instances_CALLBACK callback;
    uv_pipe_pending_instances_call calls[MAX_FUNC_CALL];
} uv_pipe_pending_instances_struct;

static uv_pipe_pending_instances_struct uv_pipe_pending_instances_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_pipe_pending_count_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_pending_count_CALLBACK callback;
    uv_pipe_pending_count_call calls[MAX_FUNC_CALL];
} uv_pipe_pending_count_struct;

static uv_pipe_pending_count_struct uv_pipe_pending_count_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    uv_handle_type to_return;
    char check_params;
} uv_pipe_pending_type_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_pipe_pending_type_CALLBACK callback;
    uv_pipe_pending_type_call calls[MAX_FUNC_CALL];
} uv_pipe_pending_type_struct;

static uv_pipe_pending_type_struct uv_pipe_pending_type_struct_inst;

typedef struct
{
    void * loop;
    void * handle;
    int fd;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_fd;
    int to_return;
    char check_params;
} uv_poll_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_poll_init_CALLBACK callback;
    uv_poll_init_call calls[MAX_FUNC_CALL];
} uv_poll_init_struct;

static uv_poll_init_struct uv_poll_init_struct_inst;

typedef struct
{
    void * loop;
    void * handle;
    int socket;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_socket;
    int to_return;
    char check_params;
} uv_poll_init_socket_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_poll_init_socket_CALLBACK callback;
    uv_poll_init_socket_call calls[MAX_FUNC_CALL];
} uv_poll_init_socket_struct;

static uv_poll_init_socket_struct uv_poll_init_socket_struct_inst;

typedef struct
{
    void * handle;
    int events;
    void * cb;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_events;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_poll_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_poll_start_CALLBACK callback;
    uv_poll_start_call calls[MAX_FUNC_CALL];
} uv_poll_start_struct;

static uv_poll_start_struct uv_poll_start_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_poll_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_poll_stop_CALLBACK callback;
    uv_poll_stop_call calls[MAX_FUNC_CALL];
} uv_poll_stop_struct;

static uv_poll_stop_struct uv_poll_stop_struct_inst;

typedef struct
{
    void * arg1;
    void * prepare;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_prepare;
    int to_return;
    char check_params;
} uv_prepare_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_prepare_init_CALLBACK callback;
    uv_prepare_init_call calls[MAX_FUNC_CALL];
} uv_prepare_init_struct;

static uv_prepare_init_struct uv_prepare_init_struct_inst;

typedef struct
{
    void * prepare;
    void * cb;
    OPMOCK_MATCHER match_prepare;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_prepare_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_prepare_start_CALLBACK callback;
    uv_prepare_start_call calls[MAX_FUNC_CALL];
} uv_prepare_start_struct;

static uv_prepare_start_struct uv_prepare_start_struct_inst;

typedef struct
{
    void * prepare;
    OPMOCK_MATCHER match_prepare;
    int to_return;
    char check_params;
} uv_prepare_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_prepare_stop_CALLBACK callback;
    uv_prepare_stop_call calls[MAX_FUNC_CALL];
} uv_prepare_stop_struct;

static uv_prepare_stop_struct uv_prepare_stop_struct_inst;

typedef struct
{
    void * arg1;
    void * check;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_check;
    int to_return;
    char check_params;
} uv_check_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_check_init_CALLBACK callback;
    uv_check_init_call calls[MAX_FUNC_CALL];
} uv_check_init_struct;

static uv_check_init_struct uv_check_init_struct_inst;

typedef struct
{
    void * check;
    void * cb;
    OPMOCK_MATCHER match_check;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_check_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_check_start_CALLBACK callback;
    uv_check_start_call calls[MAX_FUNC_CALL];
} uv_check_start_struct;

static uv_check_start_struct uv_check_start_struct_inst;

typedef struct
{
    void * check;
    OPMOCK_MATCHER match_check;
    int to_return;
    char check_params;
} uv_check_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_check_stop_CALLBACK callback;
    uv_check_stop_call calls[MAX_FUNC_CALL];
} uv_check_stop_struct;

static uv_check_stop_struct uv_check_stop_struct_inst;

typedef struct
{
    void * arg1;
    void * idle;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_idle;
    int to_return;
    char check_params;
} uv_idle_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_idle_init_CALLBACK callback;
    uv_idle_init_call calls[MAX_FUNC_CALL];
} uv_idle_init_struct;

static uv_idle_init_struct uv_idle_init_struct_inst;

typedef struct
{
    void * idle;
    void * cb;
    OPMOCK_MATCHER match_idle;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_idle_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_idle_start_CALLBACK callback;
    uv_idle_start_call calls[MAX_FUNC_CALL];
} uv_idle_start_struct;

static uv_idle_start_struct uv_idle_start_struct_inst;

typedef struct
{
    void * idle;
    OPMOCK_MATCHER match_idle;
    int to_return;
    char check_params;
} uv_idle_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_idle_stop_CALLBACK callback;
    uv_idle_stop_call calls[MAX_FUNC_CALL];
} uv_idle_stop_struct;

static uv_idle_stop_struct uv_idle_stop_struct_inst;

typedef struct
{
    void * arg1;
    void * async;
    void * async_cb;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_async;
    OPMOCK_MATCHER match_async_cb;
    int to_return;
    char check_params;
} uv_async_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_async_init_CALLBACK callback;
    uv_async_init_call calls[MAX_FUNC_CALL];
} uv_async_init_struct;

static uv_async_init_struct uv_async_init_struct_inst;

typedef struct
{
    void * async;
    OPMOCK_MATCHER match_async;
    int to_return;
    char check_params;
} uv_async_send_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_async_send_CALLBACK callback;
    uv_async_send_call calls[MAX_FUNC_CALL];
} uv_async_send_struct;

static uv_async_send_struct uv_async_send_struct_inst;

typedef struct
{
    void * arg1;
    void * handle;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_timer_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_timer_init_CALLBACK callback;
    uv_timer_init_call calls[MAX_FUNC_CALL];
} uv_timer_init_struct;

static uv_timer_init_struct uv_timer_init_struct_inst;

typedef struct
{
    void * handle;
    void * cb;
    unsigned long long timeout;
    unsigned long long repeat;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_cb;
    OPMOCK_MATCHER match_timeout;
    OPMOCK_MATCHER match_repeat;
    int to_return;
    char check_params;
} uv_timer_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_timer_start_CALLBACK callback;
    uv_timer_start_call calls[MAX_FUNC_CALL];
} uv_timer_start_struct;

static uv_timer_start_struct uv_timer_start_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_timer_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_timer_stop_CALLBACK callback;
    uv_timer_stop_call calls[MAX_FUNC_CALL];
} uv_timer_stop_struct;

static uv_timer_stop_struct uv_timer_stop_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_timer_again_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_timer_again_CALLBACK callback;
    uv_timer_again_call calls[MAX_FUNC_CALL];
} uv_timer_again_struct;

static uv_timer_again_struct uv_timer_again_struct_inst;

typedef struct
{
    void * handle;
    unsigned long long repeat;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_repeat;
    char check_params;
} uv_timer_set_repeat_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_timer_set_repeat_CALLBACK callback;
    uv_timer_set_repeat_call calls[MAX_FUNC_CALL];
} uv_timer_set_repeat_struct;

static uv_timer_set_repeat_struct uv_timer_set_repeat_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    unsigned long long to_return;
    char check_params;
} uv_timer_get_repeat_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_timer_get_repeat_CALLBACK callback;
    uv_timer_get_repeat_call calls[MAX_FUNC_CALL];
} uv_timer_get_repeat_struct;

static uv_timer_get_repeat_struct uv_timer_get_repeat_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * getaddrinfo_cb;
    void * node;
    void * service;
    void * hints;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_getaddrinfo_cb;
    OPMOCK_MATCHER match_node;
    OPMOCK_MATCHER match_service;
    OPMOCK_MATCHER match_hints;
    int to_return;
    char check_params;
} uv_getaddrinfo_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_getaddrinfo_CALLBACK callback;
    uv_getaddrinfo_call calls[MAX_FUNC_CALL];
} uv_getaddrinfo_struct;

static uv_getaddrinfo_struct uv_getaddrinfo_struct_inst;

typedef struct
{
    void * ai;
    OPMOCK_MATCHER match_ai;
    char check_params;
} uv_freeaddrinfo_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_freeaddrinfo_CALLBACK callback;
    uv_freeaddrinfo_call calls[MAX_FUNC_CALL];
} uv_freeaddrinfo_struct;

static uv_freeaddrinfo_struct uv_freeaddrinfo_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * getnameinfo_cb;
    void * addr;
    int flags;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_getnameinfo_cb;
    OPMOCK_MATCHER match_addr;
    OPMOCK_MATCHER match_flags;
    int to_return;
    char check_params;
} uv_getnameinfo_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_getnameinfo_CALLBACK callback;
    uv_getnameinfo_call calls[MAX_FUNC_CALL];
} uv_getnameinfo_struct;

static uv_getnameinfo_struct uv_getnameinfo_struct_inst;

typedef struct
{
    void * loop;
    void * handle;
    void * options;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_options;
    int to_return;
    char check_params;
} uv_spawn_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_spawn_CALLBACK callback;
    uv_spawn_call calls[MAX_FUNC_CALL];
} uv_spawn_struct;

static uv_spawn_struct uv_spawn_struct_inst;

typedef struct
{
    void * arg1;
    int signum;
    OPMOCK_MATCHER match_arg1;
    OPMOCK_MATCHER match_signum;
    int to_return;
    char check_params;
} uv_process_kill_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_process_kill_CALLBACK callback;
    uv_process_kill_call calls[MAX_FUNC_CALL];
} uv_process_kill_struct;

static uv_process_kill_struct uv_process_kill_struct_inst;

typedef struct
{
    int pid;
    int signum;
    OPMOCK_MATCHER match_pid;
    OPMOCK_MATCHER match_signum;
    int to_return;
    char check_params;
} uv_kill_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_kill_CALLBACK callback;
    uv_kill_call calls[MAX_FUNC_CALL];
} uv_kill_struct;

static uv_kill_struct uv_kill_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * work_cb;
    void * after_work_cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_work_cb;
    OPMOCK_MATCHER match_after_work_cb;
    int to_return;
    char check_params;
} uv_queue_work_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_queue_work_CALLBACK callback;
    uv_queue_work_call calls[MAX_FUNC_CALL];
} uv_queue_work_struct;

static uv_queue_work_struct uv_queue_work_struct_inst;

typedef struct
{
    void * req;
    OPMOCK_MATCHER match_req;
    int to_return;
    char check_params;
} uv_cancel_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cancel_CALLBACK callback;
    uv_cancel_call calls[MAX_FUNC_CALL];
} uv_cancel_struct;

static uv_cancel_struct uv_cancel_struct_inst;

typedef struct
{
    int argc;
    void * argv;
    OPMOCK_MATCHER match_argc;
    OPMOCK_MATCHER match_argv;
    char ** to_return;
    char check_params;
} uv_setup_args_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_setup_args_CALLBACK callback;
    uv_setup_args_call calls[MAX_FUNC_CALL];
} uv_setup_args_struct;

static uv_setup_args_struct uv_setup_args_struct_inst;

typedef struct
{
    void * buffer;
    unsigned long size;
    OPMOCK_MATCHER match_buffer;
    OPMOCK_MATCHER match_size;
    int to_return;
    char check_params;
} uv_get_process_title_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_get_process_title_CALLBACK callback;
    uv_get_process_title_call calls[MAX_FUNC_CALL];
} uv_get_process_title_struct;

static uv_get_process_title_struct uv_get_process_title_struct_inst;

typedef struct
{
    void * title;
    OPMOCK_MATCHER match_title;
    int to_return;
    char check_params;
} uv_set_process_title_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_set_process_title_CALLBACK callback;
    uv_set_process_title_call calls[MAX_FUNC_CALL];
} uv_set_process_title_struct;

static uv_set_process_title_struct uv_set_process_title_struct_inst;

typedef struct
{
    void * rss;
    OPMOCK_MATCHER match_rss;
    int to_return;
    char check_params;
} uv_resident_set_memory_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_resident_set_memory_CALLBACK callback;
    uv_resident_set_memory_call calls[MAX_FUNC_CALL];
} uv_resident_set_memory_struct;

static uv_resident_set_memory_struct uv_resident_set_memory_struct_inst;

typedef struct
{
    void * uptime;
    OPMOCK_MATCHER match_uptime;
    int to_return;
    char check_params;
} uv_uptime_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_uptime_CALLBACK callback;
    uv_uptime_call calls[MAX_FUNC_CALL];
} uv_uptime_struct;

static uv_uptime_struct uv_uptime_struct_inst;

typedef struct
{
    void * rusage;
    OPMOCK_MATCHER match_rusage;
    int to_return;
    char check_params;
} uv_getrusage_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_getrusage_CALLBACK callback;
    uv_getrusage_call calls[MAX_FUNC_CALL];
} uv_getrusage_struct;

static uv_getrusage_struct uv_getrusage_struct_inst;

typedef struct
{
    void * cpu_infos;
    void * count;
    OPMOCK_MATCHER match_cpu_infos;
    OPMOCK_MATCHER match_count;
    int to_return;
    char check_params;
} uv_cpu_info_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cpu_info_CALLBACK callback;
    uv_cpu_info_call calls[MAX_FUNC_CALL];
} uv_cpu_info_struct;

static uv_cpu_info_struct uv_cpu_info_struct_inst;

typedef struct
{
    void * cpu_infos;
    int count;
    OPMOCK_MATCHER match_cpu_infos;
    OPMOCK_MATCHER match_count;
    char check_params;
} uv_free_cpu_info_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_free_cpu_info_CALLBACK callback;
    uv_free_cpu_info_call calls[MAX_FUNC_CALL];
} uv_free_cpu_info_struct;

static uv_free_cpu_info_struct uv_free_cpu_info_struct_inst;

typedef struct
{
    void * addresses;
    void * count;
    OPMOCK_MATCHER match_addresses;
    OPMOCK_MATCHER match_count;
    int to_return;
    char check_params;
} uv_interface_addresses_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_interface_addresses_CALLBACK callback;
    uv_interface_addresses_call calls[MAX_FUNC_CALL];
} uv_interface_addresses_struct;

static uv_interface_addresses_struct uv_interface_addresses_struct_inst;

typedef struct
{
    void * addresses;
    int count;
    OPMOCK_MATCHER match_addresses;
    OPMOCK_MATCHER match_count;
    char check_params;
} uv_free_interface_addresses_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_free_interface_addresses_CALLBACK callback;
    uv_free_interface_addresses_call calls[MAX_FUNC_CALL];
} uv_free_interface_addresses_struct;

static uv_free_interface_addresses_struct uv_free_interface_addresses_struct_inst;

typedef struct
{
    void * req;
    OPMOCK_MATCHER match_req;
    char check_params;
} uv_fs_req_cleanup_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_req_cleanup_CALLBACK callback;
    uv_fs_req_cleanup_call calls[MAX_FUNC_CALL];
} uv_fs_req_cleanup_struct;

static uv_fs_req_cleanup_struct uv_fs_req_cleanup_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_close_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_close_CALLBACK callback;
    uv_fs_close_call calls[MAX_FUNC_CALL];
} uv_fs_close_struct;

static uv_fs_close_struct uv_fs_close_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    int flags;
    int mode;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_flags;
    OPMOCK_MATCHER match_mode;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_open_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_open_CALLBACK callback;
    uv_fs_open_call calls[MAX_FUNC_CALL];
} uv_fs_open_struct;

static uv_fs_open_struct uv_fs_open_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    void * bufs;
    unsigned int nbufs;
    long long offset;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    OPMOCK_MATCHER match_offset;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_read_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_read_CALLBACK callback;
    uv_fs_read_call calls[MAX_FUNC_CALL];
} uv_fs_read_struct;

static uv_fs_read_struct uv_fs_read_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_unlink_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_unlink_CALLBACK callback;
    uv_fs_unlink_call calls[MAX_FUNC_CALL];
} uv_fs_unlink_struct;

static uv_fs_unlink_struct uv_fs_unlink_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    void * bufs;
    unsigned int nbufs;
    long long offset;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_bufs;
    OPMOCK_MATCHER match_nbufs;
    OPMOCK_MATCHER match_offset;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_write_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_write_CALLBACK callback;
    uv_fs_write_call calls[MAX_FUNC_CALL];
} uv_fs_write_struct;

static uv_fs_write_struct uv_fs_write_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    int mode;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_mode;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_mkdir_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_mkdir_CALLBACK callback;
    uv_fs_mkdir_call calls[MAX_FUNC_CALL];
} uv_fs_mkdir_struct;

static uv_fs_mkdir_struct uv_fs_mkdir_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * tpl;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_tpl;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_mkdtemp_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_mkdtemp_CALLBACK callback;
    uv_fs_mkdtemp_call calls[MAX_FUNC_CALL];
} uv_fs_mkdtemp_struct;

static uv_fs_mkdtemp_struct uv_fs_mkdtemp_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_rmdir_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_rmdir_CALLBACK callback;
    uv_fs_rmdir_call calls[MAX_FUNC_CALL];
} uv_fs_rmdir_struct;

static uv_fs_rmdir_struct uv_fs_rmdir_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    int flags;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_flags;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_scandir_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_scandir_CALLBACK callback;
    uv_fs_scandir_call calls[MAX_FUNC_CALL];
} uv_fs_scandir_struct;

static uv_fs_scandir_struct uv_fs_scandir_struct_inst;

typedef struct
{
    void * req;
    void * ent;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_ent;
    int to_return;
    char check_params;
} uv_fs_scandir_next_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_scandir_next_CALLBACK callback;
    uv_fs_scandir_next_call calls[MAX_FUNC_CALL];
} uv_fs_scandir_next_struct;

static uv_fs_scandir_next_struct uv_fs_scandir_next_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_stat_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_stat_CALLBACK callback;
    uv_fs_stat_call calls[MAX_FUNC_CALL];
} uv_fs_stat_struct;

static uv_fs_stat_struct uv_fs_stat_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_fstat_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_fstat_CALLBACK callback;
    uv_fs_fstat_call calls[MAX_FUNC_CALL];
} uv_fs_fstat_struct;

static uv_fs_fstat_struct uv_fs_fstat_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * new_path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_new_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_rename_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_rename_CALLBACK callback;
    uv_fs_rename_call calls[MAX_FUNC_CALL];
} uv_fs_rename_struct;

static uv_fs_rename_struct uv_fs_rename_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_fsync_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_fsync_CALLBACK callback;
    uv_fs_fsync_call calls[MAX_FUNC_CALL];
} uv_fs_fsync_struct;

static uv_fs_fsync_struct uv_fs_fsync_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_fdatasync_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_fdatasync_CALLBACK callback;
    uv_fs_fdatasync_call calls[MAX_FUNC_CALL];
} uv_fs_fdatasync_struct;

static uv_fs_fdatasync_struct uv_fs_fdatasync_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    long long offset;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_offset;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_ftruncate_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_ftruncate_CALLBACK callback;
    uv_fs_ftruncate_call calls[MAX_FUNC_CALL];
} uv_fs_ftruncate_struct;

static uv_fs_ftruncate_struct uv_fs_ftruncate_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int out_fd;
    int in_fd;
    long long in_offset;
    unsigned long length;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_out_fd;
    OPMOCK_MATCHER match_in_fd;
    OPMOCK_MATCHER match_in_offset;
    OPMOCK_MATCHER match_length;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_sendfile_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_sendfile_CALLBACK callback;
    uv_fs_sendfile_call calls[MAX_FUNC_CALL];
} uv_fs_sendfile_struct;

static uv_fs_sendfile_struct uv_fs_sendfile_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    int mode;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_mode;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_access_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_access_CALLBACK callback;
    uv_fs_access_call calls[MAX_FUNC_CALL];
} uv_fs_access_struct;

static uv_fs_access_struct uv_fs_access_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    int mode;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_mode;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_chmod_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_chmod_CALLBACK callback;
    uv_fs_chmod_call calls[MAX_FUNC_CALL];
} uv_fs_chmod_struct;

static uv_fs_chmod_struct uv_fs_chmod_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    double atime;
    double mtime;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_atime;
    OPMOCK_MATCHER match_mtime;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_utime_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_utime_CALLBACK callback;
    uv_fs_utime_call calls[MAX_FUNC_CALL];
} uv_fs_utime_struct;

static uv_fs_utime_struct uv_fs_utime_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    double atime;
    double mtime;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_atime;
    OPMOCK_MATCHER match_mtime;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_futime_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_futime_CALLBACK callback;
    uv_fs_futime_call calls[MAX_FUNC_CALL];
} uv_fs_futime_struct;

static uv_fs_futime_struct uv_fs_futime_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_lstat_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_lstat_CALLBACK callback;
    uv_fs_lstat_call calls[MAX_FUNC_CALL];
} uv_fs_lstat_struct;

static uv_fs_lstat_struct uv_fs_lstat_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * new_path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_new_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_link_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_link_CALLBACK callback;
    uv_fs_link_call calls[MAX_FUNC_CALL];
} uv_fs_link_struct;

static uv_fs_link_struct uv_fs_link_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * new_path;
    int flags;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_new_path;
    OPMOCK_MATCHER match_flags;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_symlink_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_symlink_CALLBACK callback;
    uv_fs_symlink_call calls[MAX_FUNC_CALL];
} uv_fs_symlink_struct;

static uv_fs_symlink_struct uv_fs_symlink_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_readlink_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_readlink_CALLBACK callback;
    uv_fs_readlink_call calls[MAX_FUNC_CALL];
} uv_fs_readlink_struct;

static uv_fs_readlink_struct uv_fs_readlink_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    int mode;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_mode;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_fchmod_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_fchmod_CALLBACK callback;
    uv_fs_fchmod_call calls[MAX_FUNC_CALL];
} uv_fs_fchmod_struct;

static uv_fs_fchmod_struct uv_fs_fchmod_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    void * path;
    unsigned int uid;
    unsigned int gid;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_uid;
    OPMOCK_MATCHER match_gid;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_chown_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_chown_CALLBACK callback;
    uv_fs_chown_call calls[MAX_FUNC_CALL];
} uv_fs_chown_struct;

static uv_fs_chown_struct uv_fs_chown_struct_inst;

typedef struct
{
    void * loop;
    void * req;
    int file;
    unsigned int uid;
    unsigned int gid;
    void * cb;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_req;
    OPMOCK_MATCHER match_file;
    OPMOCK_MATCHER match_uid;
    OPMOCK_MATCHER match_gid;
    OPMOCK_MATCHER match_cb;
    int to_return;
    char check_params;
} uv_fs_fchown_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_fchown_CALLBACK callback;
    uv_fs_fchown_call calls[MAX_FUNC_CALL];
} uv_fs_fchown_struct;

static uv_fs_fchown_struct uv_fs_fchown_struct_inst;

typedef struct
{
    void * loop;
    void * handle;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_fs_poll_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_poll_init_CALLBACK callback;
    uv_fs_poll_init_call calls[MAX_FUNC_CALL];
} uv_fs_poll_init_struct;

static uv_fs_poll_init_struct uv_fs_poll_init_struct_inst;

typedef struct
{
    void * handle;
    void * poll_cb;
    void * path;
    unsigned int interval;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_poll_cb;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_interval;
    int to_return;
    char check_params;
} uv_fs_poll_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_poll_start_CALLBACK callback;
    uv_fs_poll_start_call calls[MAX_FUNC_CALL];
} uv_fs_poll_start_struct;

static uv_fs_poll_start_struct uv_fs_poll_start_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_fs_poll_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_poll_stop_CALLBACK callback;
    uv_fs_poll_stop_call calls[MAX_FUNC_CALL];
} uv_fs_poll_stop_struct;

static uv_fs_poll_stop_struct uv_fs_poll_stop_struct_inst;

typedef struct
{
    void * handle;
    void * buf;
    void * len;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_buf;
    OPMOCK_MATCHER match_len;
    int to_return;
    char check_params;
} uv_fs_poll_getpath_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_poll_getpath_CALLBACK callback;
    uv_fs_poll_getpath_call calls[MAX_FUNC_CALL];
} uv_fs_poll_getpath_struct;

static uv_fs_poll_getpath_struct uv_fs_poll_getpath_struct_inst;

typedef struct
{
    void * loop;
    void * handle;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_signal_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_signal_init_CALLBACK callback;
    uv_signal_init_call calls[MAX_FUNC_CALL];
} uv_signal_init_struct;

static uv_signal_init_struct uv_signal_init_struct_inst;

typedef struct
{
    void * handle;
    void * signal_cb;
    int signum;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_signal_cb;
    OPMOCK_MATCHER match_signum;
    int to_return;
    char check_params;
} uv_signal_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_signal_start_CALLBACK callback;
    uv_signal_start_call calls[MAX_FUNC_CALL];
} uv_signal_start_struct;

static uv_signal_start_struct uv_signal_start_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_signal_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_signal_stop_CALLBACK callback;
    uv_signal_stop_call calls[MAX_FUNC_CALL];
} uv_signal_stop_struct;

static uv_signal_stop_struct uv_signal_stop_struct_inst;

typedef struct
{
    void * avg;
    OPMOCK_MATCHER match_avg;
    char check_params;
} uv_loadavg_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_loadavg_CALLBACK callback;
    uv_loadavg_call calls[MAX_FUNC_CALL];
} uv_loadavg_struct;

static uv_loadavg_struct uv_loadavg_struct_inst;

typedef struct
{
    void * loop;
    void * handle;
    OPMOCK_MATCHER match_loop;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_fs_event_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_event_init_CALLBACK callback;
    uv_fs_event_init_call calls[MAX_FUNC_CALL];
} uv_fs_event_init_struct;

static uv_fs_event_init_struct uv_fs_event_init_struct_inst;

typedef struct
{
    void * handle;
    void * cb;
    void * path;
    unsigned int flags;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_cb;
    OPMOCK_MATCHER match_path;
    OPMOCK_MATCHER match_flags;
    int to_return;
    char check_params;
} uv_fs_event_start_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_event_start_CALLBACK callback;
    uv_fs_event_start_call calls[MAX_FUNC_CALL];
} uv_fs_event_start_struct;

static uv_fs_event_start_struct uv_fs_event_start_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_fs_event_stop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_event_stop_CALLBACK callback;
    uv_fs_event_stop_call calls[MAX_FUNC_CALL];
} uv_fs_event_stop_struct;

static uv_fs_event_stop_struct uv_fs_event_stop_struct_inst;

typedef struct
{
    void * handle;
    void * buf;
    void * len;
    OPMOCK_MATCHER match_handle;
    OPMOCK_MATCHER match_buf;
    OPMOCK_MATCHER match_len;
    int to_return;
    char check_params;
} uv_fs_event_getpath_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_fs_event_getpath_CALLBACK callback;
    uv_fs_event_getpath_call calls[MAX_FUNC_CALL];
} uv_fs_event_getpath_struct;

static uv_fs_event_getpath_struct uv_fs_event_getpath_struct_inst;

typedef struct
{
    void * ip;
    int port;
    void * addr;
    OPMOCK_MATCHER match_ip;
    OPMOCK_MATCHER match_port;
    OPMOCK_MATCHER match_addr;
    int to_return;
    char check_params;
} uv_ip4_addr_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_ip4_addr_CALLBACK callback;
    uv_ip4_addr_call calls[MAX_FUNC_CALL];
} uv_ip4_addr_struct;

static uv_ip4_addr_struct uv_ip4_addr_struct_inst;

typedef struct
{
    void * ip;
    int port;
    void * addr;
    OPMOCK_MATCHER match_ip;
    OPMOCK_MATCHER match_port;
    OPMOCK_MATCHER match_addr;
    int to_return;
    char check_params;
} uv_ip6_addr_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_ip6_addr_CALLBACK callback;
    uv_ip6_addr_call calls[MAX_FUNC_CALL];
} uv_ip6_addr_struct;

static uv_ip6_addr_struct uv_ip6_addr_struct_inst;

typedef struct
{
    void * src;
    void * dst;
    unsigned long size;
    OPMOCK_MATCHER match_src;
    OPMOCK_MATCHER match_dst;
    OPMOCK_MATCHER match_size;
    int to_return;
    char check_params;
} uv_ip4_name_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_ip4_name_CALLBACK callback;
    uv_ip4_name_call calls[MAX_FUNC_CALL];
} uv_ip4_name_struct;

static uv_ip4_name_struct uv_ip4_name_struct_inst;

typedef struct
{
    void * src;
    void * dst;
    unsigned long size;
    OPMOCK_MATCHER match_src;
    OPMOCK_MATCHER match_dst;
    OPMOCK_MATCHER match_size;
    int to_return;
    char check_params;
} uv_ip6_name_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_ip6_name_CALLBACK callback;
    uv_ip6_name_call calls[MAX_FUNC_CALL];
} uv_ip6_name_struct;

static uv_ip6_name_struct uv_ip6_name_struct_inst;

typedef struct
{
    int af;
    void * src;
    void * dst;
    unsigned long size;
    OPMOCK_MATCHER match_af;
    OPMOCK_MATCHER match_src;
    OPMOCK_MATCHER match_dst;
    OPMOCK_MATCHER match_size;
    int to_return;
    char check_params;
} uv_inet_ntop_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_inet_ntop_CALLBACK callback;
    uv_inet_ntop_call calls[MAX_FUNC_CALL];
} uv_inet_ntop_struct;

static uv_inet_ntop_struct uv_inet_ntop_struct_inst;

typedef struct
{
    int af;
    void * src;
    void * dst;
    OPMOCK_MATCHER match_af;
    OPMOCK_MATCHER match_src;
    OPMOCK_MATCHER match_dst;
    int to_return;
    char check_params;
} uv_inet_pton_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_inet_pton_CALLBACK callback;
    uv_inet_pton_call calls[MAX_FUNC_CALL];
} uv_inet_pton_struct;

static uv_inet_pton_struct uv_inet_pton_struct_inst;

typedef struct
{
    void * buffer;
    void * size;
    OPMOCK_MATCHER match_buffer;
    OPMOCK_MATCHER match_size;
    int to_return;
    char check_params;
} uv_exepath_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_exepath_CALLBACK callback;
    uv_exepath_call calls[MAX_FUNC_CALL];
} uv_exepath_struct;

static uv_exepath_struct uv_exepath_struct_inst;

typedef struct
{
    void * buffer;
    void * size;
    OPMOCK_MATCHER match_buffer;
    OPMOCK_MATCHER match_size;
    int to_return;
    char check_params;
} uv_cwd_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cwd_CALLBACK callback;
    uv_cwd_call calls[MAX_FUNC_CALL];
} uv_cwd_struct;

static uv_cwd_struct uv_cwd_struct_inst;

typedef struct
{
    void * dir;
    OPMOCK_MATCHER match_dir;
    int to_return;
    char check_params;
} uv_chdir_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_chdir_CALLBACK callback;
    uv_chdir_call calls[MAX_FUNC_CALL];
} uv_chdir_struct;

static uv_chdir_struct uv_chdir_struct_inst;

typedef struct
{
    unsigned long long to_return;
    char check_params;
} uv_get_free_memory_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_get_free_memory_CALLBACK callback;
    uv_get_free_memory_call calls[MAX_FUNC_CALL];
} uv_get_free_memory_struct;

static uv_get_free_memory_struct uv_get_free_memory_struct_inst;

typedef struct
{
    unsigned long long to_return;
    char check_params;
} uv_get_total_memory_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_get_total_memory_CALLBACK callback;
    uv_get_total_memory_call calls[MAX_FUNC_CALL];
} uv_get_total_memory_struct;

static uv_get_total_memory_struct uv_get_total_memory_struct_inst;

typedef struct
{
    unsigned long long to_return;
    char check_params;
} uv_hrtime_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_hrtime_CALLBACK callback;
    uv_hrtime_call calls[MAX_FUNC_CALL];
} uv_hrtime_struct;

static uv_hrtime_struct uv_hrtime_struct_inst;

typedef struct
{
    char check_params;
} uv_disable_stdio_inheritance_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_disable_stdio_inheritance_CALLBACK callback;
    uv_disable_stdio_inheritance_call calls[MAX_FUNC_CALL];
} uv_disable_stdio_inheritance_struct;

static uv_disable_stdio_inheritance_struct uv_disable_stdio_inheritance_struct_inst;

typedef struct
{
    void * filename;
    void * lib;
    OPMOCK_MATCHER match_filename;
    OPMOCK_MATCHER match_lib;
    int to_return;
    char check_params;
} uv_dlopen_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_dlopen_CALLBACK callback;
    uv_dlopen_call calls[MAX_FUNC_CALL];
} uv_dlopen_struct;

static uv_dlopen_struct uv_dlopen_struct_inst;

typedef struct
{
    void * lib;
    OPMOCK_MATCHER match_lib;
    char check_params;
} uv_dlclose_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_dlclose_CALLBACK callback;
    uv_dlclose_call calls[MAX_FUNC_CALL];
} uv_dlclose_struct;

static uv_dlclose_struct uv_dlclose_struct_inst;

typedef struct
{
    void * lib;
    void * name;
    void * ptr;
    OPMOCK_MATCHER match_lib;
    OPMOCK_MATCHER match_name;
    OPMOCK_MATCHER match_ptr;
    int to_return;
    char check_params;
} uv_dlsym_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_dlsym_CALLBACK callback;
    uv_dlsym_call calls[MAX_FUNC_CALL];
} uv_dlsym_struct;

static uv_dlsym_struct uv_dlsym_struct_inst;

typedef struct
{
    void * lib;
    OPMOCK_MATCHER match_lib;
     char * to_return;
    char check_params;
} uv_dlerror_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_dlerror_CALLBACK callback;
    uv_dlerror_call calls[MAX_FUNC_CALL];
} uv_dlerror_struct;

static uv_dlerror_struct uv_dlerror_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_mutex_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_mutex_init_CALLBACK callback;
    uv_mutex_init_call calls[MAX_FUNC_CALL];
} uv_mutex_init_struct;

static uv_mutex_init_struct uv_mutex_init_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    char check_params;
} uv_mutex_destroy_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_mutex_destroy_CALLBACK callback;
    uv_mutex_destroy_call calls[MAX_FUNC_CALL];
} uv_mutex_destroy_struct;

static uv_mutex_destroy_struct uv_mutex_destroy_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    char check_params;
} uv_mutex_lock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_mutex_lock_CALLBACK callback;
    uv_mutex_lock_call calls[MAX_FUNC_CALL];
} uv_mutex_lock_struct;

static uv_mutex_lock_struct uv_mutex_lock_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    int to_return;
    char check_params;
} uv_mutex_trylock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_mutex_trylock_CALLBACK callback;
    uv_mutex_trylock_call calls[MAX_FUNC_CALL];
} uv_mutex_trylock_struct;

static uv_mutex_trylock_struct uv_mutex_trylock_struct_inst;

typedef struct
{
    void * handle;
    OPMOCK_MATCHER match_handle;
    char check_params;
} uv_mutex_unlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_mutex_unlock_CALLBACK callback;
    uv_mutex_unlock_call calls[MAX_FUNC_CALL];
} uv_mutex_unlock_struct;

static uv_mutex_unlock_struct uv_mutex_unlock_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    int to_return;
    char check_params;
} uv_rwlock_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_init_CALLBACK callback;
    uv_rwlock_init_call calls[MAX_FUNC_CALL];
} uv_rwlock_init_struct;

static uv_rwlock_init_struct uv_rwlock_init_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    char check_params;
} uv_rwlock_destroy_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_destroy_CALLBACK callback;
    uv_rwlock_destroy_call calls[MAX_FUNC_CALL];
} uv_rwlock_destroy_struct;

static uv_rwlock_destroy_struct uv_rwlock_destroy_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    char check_params;
} uv_rwlock_rdlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_rdlock_CALLBACK callback;
    uv_rwlock_rdlock_call calls[MAX_FUNC_CALL];
} uv_rwlock_rdlock_struct;

static uv_rwlock_rdlock_struct uv_rwlock_rdlock_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    int to_return;
    char check_params;
} uv_rwlock_tryrdlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_tryrdlock_CALLBACK callback;
    uv_rwlock_tryrdlock_call calls[MAX_FUNC_CALL];
} uv_rwlock_tryrdlock_struct;

static uv_rwlock_tryrdlock_struct uv_rwlock_tryrdlock_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    char check_params;
} uv_rwlock_rdunlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_rdunlock_CALLBACK callback;
    uv_rwlock_rdunlock_call calls[MAX_FUNC_CALL];
} uv_rwlock_rdunlock_struct;

static uv_rwlock_rdunlock_struct uv_rwlock_rdunlock_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    char check_params;
} uv_rwlock_wrlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_wrlock_CALLBACK callback;
    uv_rwlock_wrlock_call calls[MAX_FUNC_CALL];
} uv_rwlock_wrlock_struct;

static uv_rwlock_wrlock_struct uv_rwlock_wrlock_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    int to_return;
    char check_params;
} uv_rwlock_trywrlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_trywrlock_CALLBACK callback;
    uv_rwlock_trywrlock_call calls[MAX_FUNC_CALL];
} uv_rwlock_trywrlock_struct;

static uv_rwlock_trywrlock_struct uv_rwlock_trywrlock_struct_inst;

typedef struct
{
    void * rwlock;
    OPMOCK_MATCHER match_rwlock;
    char check_params;
} uv_rwlock_wrunlock_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_rwlock_wrunlock_CALLBACK callback;
    uv_rwlock_wrunlock_call calls[MAX_FUNC_CALL];
} uv_rwlock_wrunlock_struct;

static uv_rwlock_wrunlock_struct uv_rwlock_wrunlock_struct_inst;

typedef struct
{
    void * sem;
    unsigned int value;
    OPMOCK_MATCHER match_sem;
    OPMOCK_MATCHER match_value;
    int to_return;
    char check_params;
} uv_sem_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_sem_init_CALLBACK callback;
    uv_sem_init_call calls[MAX_FUNC_CALL];
} uv_sem_init_struct;

static uv_sem_init_struct uv_sem_init_struct_inst;

typedef struct
{
    void * sem;
    OPMOCK_MATCHER match_sem;
    char check_params;
} uv_sem_destroy_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_sem_destroy_CALLBACK callback;
    uv_sem_destroy_call calls[MAX_FUNC_CALL];
} uv_sem_destroy_struct;

static uv_sem_destroy_struct uv_sem_destroy_struct_inst;

typedef struct
{
    void * sem;
    OPMOCK_MATCHER match_sem;
    char check_params;
} uv_sem_post_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_sem_post_CALLBACK callback;
    uv_sem_post_call calls[MAX_FUNC_CALL];
} uv_sem_post_struct;

static uv_sem_post_struct uv_sem_post_struct_inst;

typedef struct
{
    void * sem;
    OPMOCK_MATCHER match_sem;
    char check_params;
} uv_sem_wait_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_sem_wait_CALLBACK callback;
    uv_sem_wait_call calls[MAX_FUNC_CALL];
} uv_sem_wait_struct;

static uv_sem_wait_struct uv_sem_wait_struct_inst;

typedef struct
{
    void * sem;
    OPMOCK_MATCHER match_sem;
    int to_return;
    char check_params;
} uv_sem_trywait_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_sem_trywait_CALLBACK callback;
    uv_sem_trywait_call calls[MAX_FUNC_CALL];
} uv_sem_trywait_struct;

static uv_sem_trywait_struct uv_sem_trywait_struct_inst;

typedef struct
{
    void * cond;
    OPMOCK_MATCHER match_cond;
    int to_return;
    char check_params;
} uv_cond_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cond_init_CALLBACK callback;
    uv_cond_init_call calls[MAX_FUNC_CALL];
} uv_cond_init_struct;

static uv_cond_init_struct uv_cond_init_struct_inst;

typedef struct
{
    void * cond;
    OPMOCK_MATCHER match_cond;
    char check_params;
} uv_cond_destroy_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cond_destroy_CALLBACK callback;
    uv_cond_destroy_call calls[MAX_FUNC_CALL];
} uv_cond_destroy_struct;

static uv_cond_destroy_struct uv_cond_destroy_struct_inst;

typedef struct
{
    void * cond;
    OPMOCK_MATCHER match_cond;
    char check_params;
} uv_cond_signal_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cond_signal_CALLBACK callback;
    uv_cond_signal_call calls[MAX_FUNC_CALL];
} uv_cond_signal_struct;

static uv_cond_signal_struct uv_cond_signal_struct_inst;

typedef struct
{
    void * cond;
    OPMOCK_MATCHER match_cond;
    char check_params;
} uv_cond_broadcast_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cond_broadcast_CALLBACK callback;
    uv_cond_broadcast_call calls[MAX_FUNC_CALL];
} uv_cond_broadcast_struct;

static uv_cond_broadcast_struct uv_cond_broadcast_struct_inst;

typedef struct
{
    void * barrier;
    unsigned int count;
    OPMOCK_MATCHER match_barrier;
    OPMOCK_MATCHER match_count;
    int to_return;
    char check_params;
} uv_barrier_init_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_barrier_init_CALLBACK callback;
    uv_barrier_init_call calls[MAX_FUNC_CALL];
} uv_barrier_init_struct;

static uv_barrier_init_struct uv_barrier_init_struct_inst;

typedef struct
{
    void * barrier;
    OPMOCK_MATCHER match_barrier;
    char check_params;
} uv_barrier_destroy_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_barrier_destroy_CALLBACK callback;
    uv_barrier_destroy_call calls[MAX_FUNC_CALL];
} uv_barrier_destroy_struct;

static uv_barrier_destroy_struct uv_barrier_destroy_struct_inst;

typedef struct
{
    void * barrier;
    OPMOCK_MATCHER match_barrier;
    int to_return;
    char check_params;
} uv_barrier_wait_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_barrier_wait_CALLBACK callback;
    uv_barrier_wait_call calls[MAX_FUNC_CALL];
} uv_barrier_wait_struct;

static uv_barrier_wait_struct uv_barrier_wait_struct_inst;

typedef struct
{
    void * cond;
    void * mutex;
    OPMOCK_MATCHER match_cond;
    OPMOCK_MATCHER match_mutex;
    char check_params;
} uv_cond_wait_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cond_wait_CALLBACK callback;
    uv_cond_wait_call calls[MAX_FUNC_CALL];
} uv_cond_wait_struct;

static uv_cond_wait_struct uv_cond_wait_struct_inst;

typedef struct
{
    void * cond;
    void * mutex;
    unsigned long long timeout;
    OPMOCK_MATCHER match_cond;
    OPMOCK_MATCHER match_mutex;
    OPMOCK_MATCHER match_timeout;
    int to_return;
    char check_params;
} uv_cond_timedwait_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_cond_timedwait_CALLBACK callback;
    uv_cond_timedwait_call calls[MAX_FUNC_CALL];
} uv_cond_timedwait_struct;

static uv_cond_timedwait_struct uv_cond_timedwait_struct_inst;

typedef struct
{
    void * guard;
    void * callback;
    OPMOCK_MATCHER match_guard;
    OPMOCK_MATCHER match_callback;
    char check_params;
} uv_once_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_once_CALLBACK callback;
    uv_once_call calls[MAX_FUNC_CALL];
} uv_once_struct;

static uv_once_struct uv_once_struct_inst;

typedef struct
{
    void * key;
    OPMOCK_MATCHER match_key;
    int to_return;
    char check_params;
} uv_key_create_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_key_create_CALLBACK callback;
    uv_key_create_call calls[MAX_FUNC_CALL];
} uv_key_create_struct;

static uv_key_create_struct uv_key_create_struct_inst;

typedef struct
{
    void * key;
    OPMOCK_MATCHER match_key;
    char check_params;
} uv_key_delete_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_key_delete_CALLBACK callback;
    uv_key_delete_call calls[MAX_FUNC_CALL];
} uv_key_delete_struct;

static uv_key_delete_struct uv_key_delete_struct_inst;

typedef struct
{
    void * key;
    OPMOCK_MATCHER match_key;
    void * to_return;
    char check_params;
} uv_key_get_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_key_get_CALLBACK callback;
    uv_key_get_call calls[MAX_FUNC_CALL];
} uv_key_get_struct;

static uv_key_get_struct uv_key_get_struct_inst;

typedef struct
{
    void * key;
    void * value;
    OPMOCK_MATCHER match_key;
    OPMOCK_MATCHER match_value;
    char check_params;
} uv_key_set_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_key_set_CALLBACK callback;
    uv_key_set_call calls[MAX_FUNC_CALL];
} uv_key_set_struct;

static uv_key_set_struct uv_key_set_struct_inst;

typedef struct
{
    void * tid;
    void * entry;
    void * arg;
    OPMOCK_MATCHER match_tid;
    OPMOCK_MATCHER match_entry;
    OPMOCK_MATCHER match_arg;
    int to_return;
    char check_params;
} uv_thread_create_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_thread_create_CALLBACK callback;
    uv_thread_create_call calls[MAX_FUNC_CALL];
} uv_thread_create_struct;

static uv_thread_create_struct uv_thread_create_struct_inst;

typedef struct
{
    struct _opaque_pthread_t * to_return;
    char check_params;
} uv_thread_self_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_thread_self_CALLBACK callback;
    uv_thread_self_call calls[MAX_FUNC_CALL];
} uv_thread_self_struct;

static uv_thread_self_struct uv_thread_self_struct_inst;

typedef struct
{
    void * tid;
    OPMOCK_MATCHER match_tid;
    int to_return;
    char check_params;
} uv_thread_join_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_thread_join_CALLBACK callback;
    uv_thread_join_call calls[MAX_FUNC_CALL];
} uv_thread_join_struct;

static uv_thread_join_struct uv_thread_join_struct_inst;

typedef struct
{
    void * t1;
    void * t2;
    OPMOCK_MATCHER match_t1;
    OPMOCK_MATCHER match_t2;
    int to_return;
    char check_params;
} uv_thread_equal_call;

typedef struct
{
    int expectedCalls;
    int actualCalls;
    OPMOCK_uv_thread_equal_CALLBACK callback;
    uv_thread_equal_call calls[MAX_FUNC_CALL];
} uv_thread_equal_struct;

static uv_thread_equal_struct uv_thread_equal_struct_inst;

static void opmock_reset_all_mocks_in_this_header()
{
    uv_version_MockReset();
    uv_version_string_MockReset();
    uv_default_loop_MockReset();
    uv_loop_init_MockReset();
    uv_loop_close_MockReset();
    uv_loop_new_MockReset();
    uv_loop_delete_MockReset();
    uv_loop_size_MockReset();
    uv_loop_alive_MockReset();
    uv_run_MockReset();
    uv_stop_MockReset();
    uv_ref_MockReset();
    uv_unref_MockReset();
    uv_has_ref_MockReset();
    uv_update_time_MockReset();
    uv_now_MockReset();
    uv_backend_fd_MockReset();
    uv_backend_timeout_MockReset();
    uv_strerror_MockReset();
    uv_err_name_MockReset();
    uv_shutdown_MockReset();
    uv_handle_size_MockReset();
    uv_req_size_MockReset();
    uv_is_active_MockReset();
    uv_walk_MockReset();
    uv_close_MockReset();
    uv_send_buffer_size_MockReset();
    uv_recv_buffer_size_MockReset();
    uv_fileno_MockReset();
    uv_buf_init_MockReset();
    uv_listen_MockReset();
    uv_accept_MockReset();
    uv_read_start_MockReset();
    uv_read_stop_MockReset();
    uv_write_MockReset();
    uv_write2_MockReset();
    uv_try_write_MockReset();
    uv_is_readable_MockReset();
    uv_is_writable_MockReset();
    uv_stream_set_blocking_MockReset();
    uv_is_closing_MockReset();
    uv_tcp_init_MockReset();
    uv_tcp_open_MockReset();
    uv_tcp_nodelay_MockReset();
    uv_tcp_keepalive_MockReset();
    uv_tcp_simultaneous_accepts_MockReset();
    uv_tcp_bind_MockReset();
    uv_tcp_getsockname_MockReset();
    uv_tcp_getpeername_MockReset();
    uv_tcp_connect_MockReset();
    uv_udp_init_MockReset();
    uv_udp_open_MockReset();
    uv_udp_bind_MockReset();
    uv_udp_getsockname_MockReset();
    uv_udp_set_membership_MockReset();
    uv_udp_set_multicast_loop_MockReset();
    uv_udp_set_multicast_ttl_MockReset();
    uv_udp_set_multicast_interface_MockReset();
    uv_udp_set_broadcast_MockReset();
    uv_udp_set_ttl_MockReset();
    uv_udp_send_MockReset();
    uv_udp_try_send_MockReset();
    uv_udp_recv_start_MockReset();
    uv_udp_recv_stop_MockReset();
    uv_tty_init_MockReset();
    uv_tty_set_mode_MockReset();
    uv_tty_reset_mode_MockReset();
    uv_tty_get_winsize_MockReset();
    uv_guess_handle_MockReset();
    uv_pipe_init_MockReset();
    uv_pipe_open_MockReset();
    uv_pipe_bind_MockReset();
    uv_pipe_connect_MockReset();
    uv_pipe_getsockname_MockReset();
    uv_pipe_pending_instances_MockReset();
    uv_pipe_pending_count_MockReset();
    uv_pipe_pending_type_MockReset();
    uv_poll_init_MockReset();
    uv_poll_init_socket_MockReset();
    uv_poll_start_MockReset();
    uv_poll_stop_MockReset();
    uv_prepare_init_MockReset();
    uv_prepare_start_MockReset();
    uv_prepare_stop_MockReset();
    uv_check_init_MockReset();
    uv_check_start_MockReset();
    uv_check_stop_MockReset();
    uv_idle_init_MockReset();
    uv_idle_start_MockReset();
    uv_idle_stop_MockReset();
    uv_async_init_MockReset();
    uv_async_send_MockReset();
    uv_timer_init_MockReset();
    uv_timer_start_MockReset();
    uv_timer_stop_MockReset();
    uv_timer_again_MockReset();
    uv_timer_set_repeat_MockReset();
    uv_timer_get_repeat_MockReset();
    uv_getaddrinfo_MockReset();
    uv_freeaddrinfo_MockReset();
    uv_getnameinfo_MockReset();
    uv_spawn_MockReset();
    uv_process_kill_MockReset();
    uv_kill_MockReset();
    uv_queue_work_MockReset();
    uv_cancel_MockReset();
    uv_setup_args_MockReset();
    uv_get_process_title_MockReset();
    uv_set_process_title_MockReset();
    uv_resident_set_memory_MockReset();
    uv_uptime_MockReset();
    uv_getrusage_MockReset();
    uv_cpu_info_MockReset();
    uv_free_cpu_info_MockReset();
    uv_interface_addresses_MockReset();
    uv_free_interface_addresses_MockReset();
    uv_fs_req_cleanup_MockReset();
    uv_fs_close_MockReset();
    uv_fs_open_MockReset();
    uv_fs_read_MockReset();
    uv_fs_unlink_MockReset();
    uv_fs_write_MockReset();
    uv_fs_mkdir_MockReset();
    uv_fs_mkdtemp_MockReset();
    uv_fs_rmdir_MockReset();
    uv_fs_scandir_MockReset();
    uv_fs_scandir_next_MockReset();
    uv_fs_stat_MockReset();
    uv_fs_fstat_MockReset();
    uv_fs_rename_MockReset();
    uv_fs_fsync_MockReset();
    uv_fs_fdatasync_MockReset();
    uv_fs_ftruncate_MockReset();
    uv_fs_sendfile_MockReset();
    uv_fs_access_MockReset();
    uv_fs_chmod_MockReset();
    uv_fs_utime_MockReset();
    uv_fs_futime_MockReset();
    uv_fs_lstat_MockReset();
    uv_fs_link_MockReset();
    uv_fs_symlink_MockReset();
    uv_fs_readlink_MockReset();
    uv_fs_fchmod_MockReset();
    uv_fs_chown_MockReset();
    uv_fs_fchown_MockReset();
    uv_fs_poll_init_MockReset();
    uv_fs_poll_start_MockReset();
    uv_fs_poll_stop_MockReset();
    uv_fs_poll_getpath_MockReset();
    uv_signal_init_MockReset();
    uv_signal_start_MockReset();
    uv_signal_stop_MockReset();
    uv_loadavg_MockReset();
    uv_fs_event_init_MockReset();
    uv_fs_event_start_MockReset();
    uv_fs_event_stop_MockReset();
    uv_fs_event_getpath_MockReset();
    uv_ip4_addr_MockReset();
    uv_ip6_addr_MockReset();
    uv_ip4_name_MockReset();
    uv_ip6_name_MockReset();
    uv_inet_ntop_MockReset();
    uv_inet_pton_MockReset();
    uv_exepath_MockReset();
    uv_cwd_MockReset();
    uv_chdir_MockReset();
    uv_get_free_memory_MockReset();
    uv_get_total_memory_MockReset();
    uv_hrtime_MockReset();
    uv_disable_stdio_inheritance_MockReset();
    uv_dlopen_MockReset();
    uv_dlclose_MockReset();
    uv_dlsym_MockReset();
    uv_dlerror_MockReset();
    uv_mutex_init_MockReset();
    uv_mutex_destroy_MockReset();
    uv_mutex_lock_MockReset();
    uv_mutex_trylock_MockReset();
    uv_mutex_unlock_MockReset();
    uv_rwlock_init_MockReset();
    uv_rwlock_destroy_MockReset();
    uv_rwlock_rdlock_MockReset();
    uv_rwlock_tryrdlock_MockReset();
    uv_rwlock_rdunlock_MockReset();
    uv_rwlock_wrlock_MockReset();
    uv_rwlock_trywrlock_MockReset();
    uv_rwlock_wrunlock_MockReset();
    uv_sem_init_MockReset();
    uv_sem_destroy_MockReset();
    uv_sem_post_MockReset();
    uv_sem_wait_MockReset();
    uv_sem_trywait_MockReset();
    uv_cond_init_MockReset();
    uv_cond_destroy_MockReset();
    uv_cond_signal_MockReset();
    uv_cond_broadcast_MockReset();
    uv_barrier_init_MockReset();
    uv_barrier_destroy_MockReset();
    uv_barrier_wait_MockReset();
    uv_cond_wait_MockReset();
    uv_cond_timedwait_MockReset();
    uv_once_MockReset();
    uv_key_create_MockReset();
    uv_key_delete_MockReset();
    uv_key_get_MockReset();
    uv_key_set_MockReset();
    uv_thread_create_MockReset();
    uv_thread_self_MockReset();
    uv_thread_join_MockReset();
    uv_thread_equal_MockReset();
}

static void opmock_verify_all_mocks_in_this_header()
{
    uv_version_VerifyMock();
    uv_version_string_VerifyMock();
    uv_default_loop_VerifyMock();
    uv_loop_init_VerifyMock();
    uv_loop_close_VerifyMock();
    uv_loop_new_VerifyMock();
    uv_loop_delete_VerifyMock();
    uv_loop_size_VerifyMock();
    uv_loop_alive_VerifyMock();
    uv_run_VerifyMock();
    uv_stop_VerifyMock();
    uv_ref_VerifyMock();
    uv_unref_VerifyMock();
    uv_has_ref_VerifyMock();
    uv_update_time_VerifyMock();
    uv_now_VerifyMock();
    uv_backend_fd_VerifyMock();
    uv_backend_timeout_VerifyMock();
    uv_strerror_VerifyMock();
    uv_err_name_VerifyMock();
    uv_shutdown_VerifyMock();
    uv_handle_size_VerifyMock();
    uv_req_size_VerifyMock();
    uv_is_active_VerifyMock();
    uv_walk_VerifyMock();
    uv_close_VerifyMock();
    uv_send_buffer_size_VerifyMock();
    uv_recv_buffer_size_VerifyMock();
    uv_fileno_VerifyMock();
    uv_buf_init_VerifyMock();
    uv_listen_VerifyMock();
    uv_accept_VerifyMock();
    uv_read_start_VerifyMock();
    uv_read_stop_VerifyMock();
    uv_write_VerifyMock();
    uv_write2_VerifyMock();
    uv_try_write_VerifyMock();
    uv_is_readable_VerifyMock();
    uv_is_writable_VerifyMock();
    uv_stream_set_blocking_VerifyMock();
    uv_is_closing_VerifyMock();
    uv_tcp_init_VerifyMock();
    uv_tcp_open_VerifyMock();
    uv_tcp_nodelay_VerifyMock();
    uv_tcp_keepalive_VerifyMock();
    uv_tcp_simultaneous_accepts_VerifyMock();
    uv_tcp_bind_VerifyMock();
    uv_tcp_getsockname_VerifyMock();
    uv_tcp_getpeername_VerifyMock();
    uv_tcp_connect_VerifyMock();
    uv_udp_init_VerifyMock();
    uv_udp_open_VerifyMock();
    uv_udp_bind_VerifyMock();
    uv_udp_getsockname_VerifyMock();
    uv_udp_set_membership_VerifyMock();
    uv_udp_set_multicast_loop_VerifyMock();
    uv_udp_set_multicast_ttl_VerifyMock();
    uv_udp_set_multicast_interface_VerifyMock();
    uv_udp_set_broadcast_VerifyMock();
    uv_udp_set_ttl_VerifyMock();
    uv_udp_send_VerifyMock();
    uv_udp_try_send_VerifyMock();
    uv_udp_recv_start_VerifyMock();
    uv_udp_recv_stop_VerifyMock();
    uv_tty_init_VerifyMock();
    uv_tty_set_mode_VerifyMock();
    uv_tty_reset_mode_VerifyMock();
    uv_tty_get_winsize_VerifyMock();
    uv_guess_handle_VerifyMock();
    uv_pipe_init_VerifyMock();
    uv_pipe_open_VerifyMock();
    uv_pipe_bind_VerifyMock();
    uv_pipe_connect_VerifyMock();
    uv_pipe_getsockname_VerifyMock();
    uv_pipe_pending_instances_VerifyMock();
    uv_pipe_pending_count_VerifyMock();
    uv_pipe_pending_type_VerifyMock();
    uv_poll_init_VerifyMock();
    uv_poll_init_socket_VerifyMock();
    uv_poll_start_VerifyMock();
    uv_poll_stop_VerifyMock();
    uv_prepare_init_VerifyMock();
    uv_prepare_start_VerifyMock();
    uv_prepare_stop_VerifyMock();
    uv_check_init_VerifyMock();
    uv_check_start_VerifyMock();
    uv_check_stop_VerifyMock();
    uv_idle_init_VerifyMock();
    uv_idle_start_VerifyMock();
    uv_idle_stop_VerifyMock();
    uv_async_init_VerifyMock();
    uv_async_send_VerifyMock();
    uv_timer_init_VerifyMock();
    uv_timer_start_VerifyMock();
    uv_timer_stop_VerifyMock();
    uv_timer_again_VerifyMock();
    uv_timer_set_repeat_VerifyMock();
    uv_timer_get_repeat_VerifyMock();
    uv_getaddrinfo_VerifyMock();
    uv_freeaddrinfo_VerifyMock();
    uv_getnameinfo_VerifyMock();
    uv_spawn_VerifyMock();
    uv_process_kill_VerifyMock();
    uv_kill_VerifyMock();
    uv_queue_work_VerifyMock();
    uv_cancel_VerifyMock();
    uv_setup_args_VerifyMock();
    uv_get_process_title_VerifyMock();
    uv_set_process_title_VerifyMock();
    uv_resident_set_memory_VerifyMock();
    uv_uptime_VerifyMock();
    uv_getrusage_VerifyMock();
    uv_cpu_info_VerifyMock();
    uv_free_cpu_info_VerifyMock();
    uv_interface_addresses_VerifyMock();
    uv_free_interface_addresses_VerifyMock();
    uv_fs_req_cleanup_VerifyMock();
    uv_fs_close_VerifyMock();
    uv_fs_open_VerifyMock();
    uv_fs_read_VerifyMock();
    uv_fs_unlink_VerifyMock();
    uv_fs_write_VerifyMock();
    uv_fs_mkdir_VerifyMock();
    uv_fs_mkdtemp_VerifyMock();
    uv_fs_rmdir_VerifyMock();
    uv_fs_scandir_VerifyMock();
    uv_fs_scandir_next_VerifyMock();
    uv_fs_stat_VerifyMock();
    uv_fs_fstat_VerifyMock();
    uv_fs_rename_VerifyMock();
    uv_fs_fsync_VerifyMock();
    uv_fs_fdatasync_VerifyMock();
    uv_fs_ftruncate_VerifyMock();
    uv_fs_sendfile_VerifyMock();
    uv_fs_access_VerifyMock();
    uv_fs_chmod_VerifyMock();
    uv_fs_utime_VerifyMock();
    uv_fs_futime_VerifyMock();
    uv_fs_lstat_VerifyMock();
    uv_fs_link_VerifyMock();
    uv_fs_symlink_VerifyMock();
    uv_fs_readlink_VerifyMock();
    uv_fs_fchmod_VerifyMock();
    uv_fs_chown_VerifyMock();
    uv_fs_fchown_VerifyMock();
    uv_fs_poll_init_VerifyMock();
    uv_fs_poll_start_VerifyMock();
    uv_fs_poll_stop_VerifyMock();
    uv_fs_poll_getpath_VerifyMock();
    uv_signal_init_VerifyMock();
    uv_signal_start_VerifyMock();
    uv_signal_stop_VerifyMock();
    uv_loadavg_VerifyMock();
    uv_fs_event_init_VerifyMock();
    uv_fs_event_start_VerifyMock();
    uv_fs_event_stop_VerifyMock();
    uv_fs_event_getpath_VerifyMock();
    uv_ip4_addr_VerifyMock();
    uv_ip6_addr_VerifyMock();
    uv_ip4_name_VerifyMock();
    uv_ip6_name_VerifyMock();
    uv_inet_ntop_VerifyMock();
    uv_inet_pton_VerifyMock();
    uv_exepath_VerifyMock();
    uv_cwd_VerifyMock();
    uv_chdir_VerifyMock();
    uv_get_free_memory_VerifyMock();
    uv_get_total_memory_VerifyMock();
    uv_hrtime_VerifyMock();
    uv_disable_stdio_inheritance_VerifyMock();
    uv_dlopen_VerifyMock();
    uv_dlclose_VerifyMock();
    uv_dlsym_VerifyMock();
    uv_dlerror_VerifyMock();
    uv_mutex_init_VerifyMock();
    uv_mutex_destroy_VerifyMock();
    uv_mutex_lock_VerifyMock();
    uv_mutex_trylock_VerifyMock();
    uv_mutex_unlock_VerifyMock();
    uv_rwlock_init_VerifyMock();
    uv_rwlock_destroy_VerifyMock();
    uv_rwlock_rdlock_VerifyMock();
    uv_rwlock_tryrdlock_VerifyMock();
    uv_rwlock_rdunlock_VerifyMock();
    uv_rwlock_wrlock_VerifyMock();
    uv_rwlock_trywrlock_VerifyMock();
    uv_rwlock_wrunlock_VerifyMock();
    uv_sem_init_VerifyMock();
    uv_sem_destroy_VerifyMock();
    uv_sem_post_VerifyMock();
    uv_sem_wait_VerifyMock();
    uv_sem_trywait_VerifyMock();
    uv_cond_init_VerifyMock();
    uv_cond_destroy_VerifyMock();
    uv_cond_signal_VerifyMock();
    uv_cond_broadcast_VerifyMock();
    uv_barrier_init_VerifyMock();
    uv_barrier_destroy_VerifyMock();
    uv_barrier_wait_VerifyMock();
    uv_cond_wait_VerifyMock();
    uv_cond_timedwait_VerifyMock();
    uv_once_VerifyMock();
    uv_key_create_VerifyMock();
    uv_key_delete_VerifyMock();
    uv_key_get_VerifyMock();
    uv_key_set_VerifyMock();
    uv_thread_create_VerifyMock();
    uv_thread_self_VerifyMock();
    uv_thread_join_VerifyMock();
    uv_thread_equal_VerifyMock();
}

unsigned int uv_version()
{
    unsigned int default_res = (unsigned int)uv_version_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_version_struct_inst.actualCalls++;

    if (uv_version_struct_inst.callback != NULL)
    {
        return uv_version_struct_inst.callback (uv_version_struct_inst.actualCalls);
    }
    if (uv_version_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_version', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "unsigned int uv_version ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'unsigned int uv_version()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_version_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_version_struct_inst.expectedCalls; opmock_i++) {
        uv_version_struct_inst.calls[opmock_i - 1] = uv_version_struct_inst.calls[opmock_i];
    }

    uv_version_struct_inst.expectedCalls--;
    return default_res;
}

void uv_version_MockReset()
{
    uv_version_struct_inst.expectedCalls = 0;
    uv_version_struct_inst.actualCalls = 0;
    uv_version_struct_inst.callback = NULL;
}

void uv_version_MockWithCallback(OPMOCK_uv_version_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_version_struct_inst.callback = callback;
    uv_version_struct_inst.expectedCalls = 0;
    uv_version_struct_inst.actualCalls = 0;
}

void uv_version_VerifyMock()
{
    if (uv_version_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_version'",uv_version_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_version_ExpectAndReturn (unsigned int to_return)
{
    if(uv_version_struct_inst.callback != NULL)
    {
        uv_version_MockReset ();
    }

    if(uv_version_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_version_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"unsigned int uv_version ()");
    uv_version_struct_inst.calls[uv_version_struct_inst.expectedCalls].to_return = (unsigned int) to_return;
    uv_version_struct_inst.calls[uv_version_struct_inst.expectedCalls].check_params = 1;
    uv_version_struct_inst.expectedCalls++;
}

const char * uv_version_string()
{
    const char * default_res = (const char *)uv_version_string_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_version_string_struct_inst.actualCalls++;

    if (uv_version_string_struct_inst.callback != NULL)
    {
        return uv_version_string_struct_inst.callback (uv_version_string_struct_inst.actualCalls);
    }
    if (uv_version_string_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_version_string', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "const char * uv_version_string ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'const char * uv_version_string()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_version_string_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_version_string_struct_inst.expectedCalls; opmock_i++) {
        uv_version_string_struct_inst.calls[opmock_i - 1] = uv_version_string_struct_inst.calls[opmock_i];
    }

    uv_version_string_struct_inst.expectedCalls--;
    return default_res;
}

void uv_version_string_MockReset()
{
    uv_version_string_struct_inst.expectedCalls = 0;
    uv_version_string_struct_inst.actualCalls = 0;
    uv_version_string_struct_inst.callback = NULL;
}

void uv_version_string_MockWithCallback(OPMOCK_uv_version_string_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_version_string_struct_inst.callback = callback;
    uv_version_string_struct_inst.expectedCalls = 0;
    uv_version_string_struct_inst.actualCalls = 0;
}

void uv_version_string_VerifyMock()
{
    if (uv_version_string_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_version_string'",uv_version_string_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_version_string_ExpectAndReturn (const char * to_return)
{
    if(uv_version_string_struct_inst.callback != NULL)
    {
        uv_version_string_MockReset ();
    }

    if(uv_version_string_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_version_string_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"const char * uv_version_string ()");
    uv_version_string_struct_inst.calls[uv_version_string_struct_inst.expectedCalls].to_return = ( char *) to_return;
    uv_version_string_struct_inst.calls[uv_version_string_struct_inst.expectedCalls].check_params = 1;
    uv_version_string_struct_inst.expectedCalls++;
}

uv_loop_t * uv_default_loop()
{
    uv_loop_t * default_res = (uv_loop_t *)uv_default_loop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_default_loop_struct_inst.actualCalls++;

    if (uv_default_loop_struct_inst.callback != NULL)
    {
        return uv_default_loop_struct_inst.callback (uv_default_loop_struct_inst.actualCalls);
    }
    if (uv_default_loop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_default_loop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uv_loop_t * uv_default_loop ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uv_loop_t * uv_default_loop()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_default_loop_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_default_loop_struct_inst.expectedCalls; opmock_i++) {
        uv_default_loop_struct_inst.calls[opmock_i - 1] = uv_default_loop_struct_inst.calls[opmock_i];
    }

    uv_default_loop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_default_loop_MockReset()
{
    uv_default_loop_struct_inst.expectedCalls = 0;
    uv_default_loop_struct_inst.actualCalls = 0;
    uv_default_loop_struct_inst.callback = NULL;
}

void uv_default_loop_MockWithCallback(OPMOCK_uv_default_loop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_default_loop_struct_inst.callback = callback;
    uv_default_loop_struct_inst.expectedCalls = 0;
    uv_default_loop_struct_inst.actualCalls = 0;
}

void uv_default_loop_VerifyMock()
{
    if (uv_default_loop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_default_loop'",uv_default_loop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_default_loop_ExpectAndReturn (uv_loop_t * to_return)
{
    if(uv_default_loop_struct_inst.callback != NULL)
    {
        uv_default_loop_MockReset ();
    }

    if(uv_default_loop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_default_loop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uv_loop_t * uv_default_loop ()");
    uv_default_loop_struct_inst.calls[uv_default_loop_struct_inst.expectedCalls].to_return = (struct uv_loop_s *) to_return;
    uv_default_loop_struct_inst.calls[uv_default_loop_struct_inst.expectedCalls].check_params = 1;
    uv_default_loop_struct_inst.expectedCalls++;
}

int uv_loop_init(uv_loop_t * loop)
{
    int default_res = (int)uv_loop_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_loop_init_struct_inst.actualCalls++;

    if (uv_loop_init_struct_inst.callback != NULL)
    {
        return uv_loop_init_struct_inst.callback (loop, uv_loop_init_struct_inst.actualCalls);
    }
    if (uv_loop_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loop_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_loop_init (uv_loop_t * loop)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_loop_init(uv_loop_t * loop)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loop_init_struct_inst.calls[0].check_params == 1) {
        if(uv_loop_init_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_loop_init_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_loop_init_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_loop_init', %s",uv_loop_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_loop_init_struct_inst.expectedCalls; opmock_i++) {
        uv_loop_init_struct_inst.calls[opmock_i - 1] = uv_loop_init_struct_inst.calls[opmock_i];
    }

    uv_loop_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_loop_init_MockReset()
{
    uv_loop_init_struct_inst.expectedCalls = 0;
    uv_loop_init_struct_inst.actualCalls = 0;
    uv_loop_init_struct_inst.callback = NULL;
}

void uv_loop_init_MockWithCallback(OPMOCK_uv_loop_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loop_init_struct_inst.callback = callback;
    uv_loop_init_struct_inst.expectedCalls = 0;
    uv_loop_init_struct_inst.actualCalls = 0;
}

void uv_loop_init_VerifyMock()
{
    if (uv_loop_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loop_init'",uv_loop_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loop_init_ExpectAndReturn (uv_loop_t * loop, int to_return, OPMOCK_MATCHER match_loop)
{
    if(uv_loop_init_struct_inst.callback != NULL)
    {
        uv_loop_init_MockReset ();
    }

    if(uv_loop_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loop_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_loop_init (uv_loop_t * loop)");
    uv_loop_init_struct_inst.calls[uv_loop_init_struct_inst.expectedCalls].loop = (void *)loop;
    uv_loop_init_struct_inst.calls[uv_loop_init_struct_inst.expectedCalls].match_loop = match_loop;
    uv_loop_init_struct_inst.calls[uv_loop_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_loop_init_struct_inst.calls[uv_loop_init_struct_inst.expectedCalls].check_params = 1;
    uv_loop_init_struct_inst.expectedCalls++;
}

int uv_loop_close(uv_loop_t * loop)
{
    int default_res = (int)uv_loop_close_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_loop_close_struct_inst.actualCalls++;

    if (uv_loop_close_struct_inst.callback != NULL)
    {
        return uv_loop_close_struct_inst.callback (loop, uv_loop_close_struct_inst.actualCalls);
    }
    if (uv_loop_close_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loop_close', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_loop_close (uv_loop_t * loop)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_loop_close(uv_loop_t * loop)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loop_close_struct_inst.calls[0].check_params == 1) {
        if(uv_loop_close_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_loop_close_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_loop_close_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_loop_close', %s",uv_loop_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_loop_close_struct_inst.expectedCalls; opmock_i++) {
        uv_loop_close_struct_inst.calls[opmock_i - 1] = uv_loop_close_struct_inst.calls[opmock_i];
    }

    uv_loop_close_struct_inst.expectedCalls--;
    return default_res;
}

void uv_loop_close_MockReset()
{
    uv_loop_close_struct_inst.expectedCalls = 0;
    uv_loop_close_struct_inst.actualCalls = 0;
    uv_loop_close_struct_inst.callback = NULL;
}

void uv_loop_close_MockWithCallback(OPMOCK_uv_loop_close_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loop_close_struct_inst.callback = callback;
    uv_loop_close_struct_inst.expectedCalls = 0;
    uv_loop_close_struct_inst.actualCalls = 0;
}

void uv_loop_close_VerifyMock()
{
    if (uv_loop_close_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loop_close'",uv_loop_close_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loop_close_ExpectAndReturn (uv_loop_t * loop, int to_return, OPMOCK_MATCHER match_loop)
{
    if(uv_loop_close_struct_inst.callback != NULL)
    {
        uv_loop_close_MockReset ();
    }

    if(uv_loop_close_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loop_close_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_loop_close (uv_loop_t * loop)");
    uv_loop_close_struct_inst.calls[uv_loop_close_struct_inst.expectedCalls].loop = (void *)loop;
    uv_loop_close_struct_inst.calls[uv_loop_close_struct_inst.expectedCalls].match_loop = match_loop;
    uv_loop_close_struct_inst.calls[uv_loop_close_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_loop_close_struct_inst.calls[uv_loop_close_struct_inst.expectedCalls].check_params = 1;
    uv_loop_close_struct_inst.expectedCalls++;
}

uv_loop_t * uv_loop_new()
{
    uv_loop_t * default_res = (uv_loop_t *)uv_loop_new_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_loop_new_struct_inst.actualCalls++;

    if (uv_loop_new_struct_inst.callback != NULL)
    {
        return uv_loop_new_struct_inst.callback (uv_loop_new_struct_inst.actualCalls);
    }
    if (uv_loop_new_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loop_new', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uv_loop_t * uv_loop_new ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uv_loop_t * uv_loop_new()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loop_new_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_loop_new_struct_inst.expectedCalls; opmock_i++) {
        uv_loop_new_struct_inst.calls[opmock_i - 1] = uv_loop_new_struct_inst.calls[opmock_i];
    }

    uv_loop_new_struct_inst.expectedCalls--;
    return default_res;
}

void uv_loop_new_MockReset()
{
    uv_loop_new_struct_inst.expectedCalls = 0;
    uv_loop_new_struct_inst.actualCalls = 0;
    uv_loop_new_struct_inst.callback = NULL;
}

void uv_loop_new_MockWithCallback(OPMOCK_uv_loop_new_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loop_new_struct_inst.callback = callback;
    uv_loop_new_struct_inst.expectedCalls = 0;
    uv_loop_new_struct_inst.actualCalls = 0;
}

void uv_loop_new_VerifyMock()
{
    if (uv_loop_new_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loop_new'",uv_loop_new_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loop_new_ExpectAndReturn (uv_loop_t * to_return)
{
    if(uv_loop_new_struct_inst.callback != NULL)
    {
        uv_loop_new_MockReset ();
    }

    if(uv_loop_new_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loop_new_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uv_loop_t * uv_loop_new ()");
    uv_loop_new_struct_inst.calls[uv_loop_new_struct_inst.expectedCalls].to_return = (struct uv_loop_s *) to_return;
    uv_loop_new_struct_inst.calls[uv_loop_new_struct_inst.expectedCalls].check_params = 1;
    uv_loop_new_struct_inst.expectedCalls++;
}

void uv_loop_delete(uv_loop_t * arg1)
{
    int opmock_i;
    uv_loop_delete_struct_inst.actualCalls++;

    if (uv_loop_delete_struct_inst.callback != NULL)
    {
        uv_loop_delete_struct_inst.callback (arg1, uv_loop_delete_struct_inst.actualCalls);
        return;
    }
    if (uv_loop_delete_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loop_delete', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_loop_delete (uv_loop_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_loop_delete(uv_loop_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loop_delete_struct_inst.calls[0].check_params == 1) {
        if(uv_loop_delete_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_loop_delete_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_loop_delete_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_loop_delete', %s",uv_loop_delete_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_loop_delete_struct_inst.expectedCalls; opmock_i++) {
        uv_loop_delete_struct_inst.calls[opmock_i - 1] = uv_loop_delete_struct_inst.calls[opmock_i];
    }

    uv_loop_delete_struct_inst.expectedCalls--;
}

void uv_loop_delete_MockReset()
{
    uv_loop_delete_struct_inst.expectedCalls = 0;
    uv_loop_delete_struct_inst.actualCalls = 0;
    uv_loop_delete_struct_inst.callback = NULL;
}

void uv_loop_delete_MockWithCallback(OPMOCK_uv_loop_delete_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loop_delete_struct_inst.callback = callback;
    uv_loop_delete_struct_inst.expectedCalls = 0;
    uv_loop_delete_struct_inst.actualCalls = 0;
}

void uv_loop_delete_VerifyMock()
{
    if (uv_loop_delete_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loop_delete'",uv_loop_delete_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loop_delete_ExpectAndReturn (uv_loop_t * arg1, OPMOCK_MATCHER match_arg1)
{
    if(uv_loop_delete_struct_inst.callback != NULL)
    {
        uv_loop_delete_MockReset ();
    }

    if(uv_loop_delete_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loop_delete_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_loop_delete (uv_loop_t * arg1)");
    uv_loop_delete_struct_inst.calls[uv_loop_delete_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_loop_delete_struct_inst.calls[uv_loop_delete_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_loop_delete_struct_inst.calls[uv_loop_delete_struct_inst.expectedCalls].check_params = 1;
    uv_loop_delete_struct_inst.expectedCalls++;
}

size_t uv_loop_size()
{
    size_t default_res = (size_t)uv_loop_size_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_loop_size_struct_inst.actualCalls++;

    if (uv_loop_size_struct_inst.callback != NULL)
    {
        return uv_loop_size_struct_inst.callback (uv_loop_size_struct_inst.actualCalls);
    }
    if (uv_loop_size_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loop_size', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "size_t uv_loop_size ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'size_t uv_loop_size()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loop_size_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_loop_size_struct_inst.expectedCalls; opmock_i++) {
        uv_loop_size_struct_inst.calls[opmock_i - 1] = uv_loop_size_struct_inst.calls[opmock_i];
    }

    uv_loop_size_struct_inst.expectedCalls--;
    return default_res;
}

void uv_loop_size_MockReset()
{
    uv_loop_size_struct_inst.expectedCalls = 0;
    uv_loop_size_struct_inst.actualCalls = 0;
    uv_loop_size_struct_inst.callback = NULL;
}

void uv_loop_size_MockWithCallback(OPMOCK_uv_loop_size_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loop_size_struct_inst.callback = callback;
    uv_loop_size_struct_inst.expectedCalls = 0;
    uv_loop_size_struct_inst.actualCalls = 0;
}

void uv_loop_size_VerifyMock()
{
    if (uv_loop_size_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loop_size'",uv_loop_size_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loop_size_ExpectAndReturn (size_t to_return)
{
    if(uv_loop_size_struct_inst.callback != NULL)
    {
        uv_loop_size_MockReset ();
    }

    if(uv_loop_size_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loop_size_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"size_t uv_loop_size ()");
    uv_loop_size_struct_inst.calls[uv_loop_size_struct_inst.expectedCalls].to_return = (unsigned long) to_return;
    uv_loop_size_struct_inst.calls[uv_loop_size_struct_inst.expectedCalls].check_params = 1;
    uv_loop_size_struct_inst.expectedCalls++;
}

int uv_loop_alive(const uv_loop_t * loop)
{
    int default_res = (int)uv_loop_alive_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_loop_alive_struct_inst.actualCalls++;

    if (uv_loop_alive_struct_inst.callback != NULL)
    {
        return uv_loop_alive_struct_inst.callback (loop, uv_loop_alive_struct_inst.actualCalls);
    }
    if (uv_loop_alive_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loop_alive', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_loop_alive (const uv_loop_t * loop)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_loop_alive(const uv_loop_t * loop)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loop_alive_struct_inst.calls[0].check_params == 1) {
        if(uv_loop_alive_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_loop_alive_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_loop_alive_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_loop_alive', %s",uv_loop_alive_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_loop_alive_struct_inst.expectedCalls; opmock_i++) {
        uv_loop_alive_struct_inst.calls[opmock_i - 1] = uv_loop_alive_struct_inst.calls[opmock_i];
    }

    uv_loop_alive_struct_inst.expectedCalls--;
    return default_res;
}

void uv_loop_alive_MockReset()
{
    uv_loop_alive_struct_inst.expectedCalls = 0;
    uv_loop_alive_struct_inst.actualCalls = 0;
    uv_loop_alive_struct_inst.callback = NULL;
}

void uv_loop_alive_MockWithCallback(OPMOCK_uv_loop_alive_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loop_alive_struct_inst.callback = callback;
    uv_loop_alive_struct_inst.expectedCalls = 0;
    uv_loop_alive_struct_inst.actualCalls = 0;
}

void uv_loop_alive_VerifyMock()
{
    if (uv_loop_alive_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loop_alive'",uv_loop_alive_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loop_alive_ExpectAndReturn (const uv_loop_t * loop, int to_return, OPMOCK_MATCHER match_loop)
{
    if(uv_loop_alive_struct_inst.callback != NULL)
    {
        uv_loop_alive_MockReset ();
    }

    if(uv_loop_alive_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loop_alive_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_loop_alive (const uv_loop_t * loop)");
    uv_loop_alive_struct_inst.calls[uv_loop_alive_struct_inst.expectedCalls].loop = (void *)loop;
    uv_loop_alive_struct_inst.calls[uv_loop_alive_struct_inst.expectedCalls].match_loop = match_loop;
    uv_loop_alive_struct_inst.calls[uv_loop_alive_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_loop_alive_struct_inst.calls[uv_loop_alive_struct_inst.expectedCalls].check_params = 1;
    uv_loop_alive_struct_inst.expectedCalls++;
}

int uv_run(uv_loop_t * arg1, uv_run_mode mode)
{
    int default_res = (int)uv_run_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_run_struct_inst.actualCalls++;

    if (uv_run_struct_inst.callback != NULL)
    {
        return uv_run_struct_inst.callback (arg1, mode, uv_run_struct_inst.actualCalls);
    }
    if (uv_run_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_run', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_run (uv_loop_t * arg1, uv_run_mode mode)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_run(uv_loop_t * arg1, uv_run_mode mode)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_run_struct_inst.calls[0].check_params == 1) {
        if(uv_run_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_run_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_run_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_run', %s",uv_run_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_run_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_run_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_run_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_run', %s",uv_run_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_run_struct_inst.expectedCalls; opmock_i++) {
        uv_run_struct_inst.calls[opmock_i - 1] = uv_run_struct_inst.calls[opmock_i];
    }

    uv_run_struct_inst.expectedCalls--;
    return default_res;
}

void uv_run_MockReset()
{
    uv_run_struct_inst.expectedCalls = 0;
    uv_run_struct_inst.actualCalls = 0;
    uv_run_struct_inst.callback = NULL;
}

void uv_run_MockWithCallback(OPMOCK_uv_run_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_run_struct_inst.callback = callback;
    uv_run_struct_inst.expectedCalls = 0;
    uv_run_struct_inst.actualCalls = 0;
}

void uv_run_VerifyMock()
{
    if (uv_run_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_run'",uv_run_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_run_ExpectAndReturn (uv_loop_t * arg1, uv_run_mode mode, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_mode)
{
    if(uv_run_struct_inst.callback != NULL)
    {
        uv_run_MockReset ();
    }

    if(uv_run_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_run_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_run (uv_loop_t * arg1, uv_run_mode mode)");
    uv_run_struct_inst.calls[uv_run_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_run_struct_inst.calls[uv_run_struct_inst.expectedCalls].mode = (uv_run_mode)mode;
    uv_run_struct_inst.calls[uv_run_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_run_struct_inst.calls[uv_run_struct_inst.expectedCalls].match_mode = match_mode;
    uv_run_struct_inst.calls[uv_run_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_run_struct_inst.calls[uv_run_struct_inst.expectedCalls].check_params = 1;
    uv_run_struct_inst.expectedCalls++;
}

void uv_stop(uv_loop_t * arg1)
{
    int opmock_i;
    uv_stop_struct_inst.actualCalls++;

    if (uv_stop_struct_inst.callback != NULL)
    {
        uv_stop_struct_inst.callback (arg1, uv_stop_struct_inst.actualCalls);
        return;
    }
    if (uv_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_stop', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_stop (uv_loop_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_stop(uv_loop_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_stop_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_stop_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_stop_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_stop', %s",uv_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_stop_struct_inst.calls[opmock_i - 1] = uv_stop_struct_inst.calls[opmock_i];
    }

    uv_stop_struct_inst.expectedCalls--;
}

void uv_stop_MockReset()
{
    uv_stop_struct_inst.expectedCalls = 0;
    uv_stop_struct_inst.actualCalls = 0;
    uv_stop_struct_inst.callback = NULL;
}

void uv_stop_MockWithCallback(OPMOCK_uv_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_stop_struct_inst.callback = callback;
    uv_stop_struct_inst.expectedCalls = 0;
    uv_stop_struct_inst.actualCalls = 0;
}

void uv_stop_VerifyMock()
{
    if (uv_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_stop'",uv_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_stop_ExpectAndReturn (uv_loop_t * arg1, OPMOCK_MATCHER match_arg1)
{
    if(uv_stop_struct_inst.callback != NULL)
    {
        uv_stop_MockReset ();
    }

    if(uv_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_stop (uv_loop_t * arg1)");
    uv_stop_struct_inst.calls[uv_stop_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_stop_struct_inst.calls[uv_stop_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_stop_struct_inst.calls[uv_stop_struct_inst.expectedCalls].check_params = 1;
    uv_stop_struct_inst.expectedCalls++;
}

void uv_ref(uv_handle_t * arg1)
{
    int opmock_i;
    uv_ref_struct_inst.actualCalls++;

    if (uv_ref_struct_inst.callback != NULL)
    {
        uv_ref_struct_inst.callback (arg1, uv_ref_struct_inst.actualCalls);
        return;
    }
    if (uv_ref_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_ref', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_ref (uv_handle_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_ref(uv_handle_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_ref_struct_inst.calls[0].check_params == 1) {
        if(uv_ref_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_ref_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_ref_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ref', %s",uv_ref_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_ref_struct_inst.expectedCalls; opmock_i++) {
        uv_ref_struct_inst.calls[opmock_i - 1] = uv_ref_struct_inst.calls[opmock_i];
    }

    uv_ref_struct_inst.expectedCalls--;
}

void uv_ref_MockReset()
{
    uv_ref_struct_inst.expectedCalls = 0;
    uv_ref_struct_inst.actualCalls = 0;
    uv_ref_struct_inst.callback = NULL;
}

void uv_ref_MockWithCallback(OPMOCK_uv_ref_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_ref_struct_inst.callback = callback;
    uv_ref_struct_inst.expectedCalls = 0;
    uv_ref_struct_inst.actualCalls = 0;
}

void uv_ref_VerifyMock()
{
    if (uv_ref_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_ref'",uv_ref_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_ref_ExpectAndReturn (uv_handle_t * arg1, OPMOCK_MATCHER match_arg1)
{
    if(uv_ref_struct_inst.callback != NULL)
    {
        uv_ref_MockReset ();
    }

    if(uv_ref_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_ref_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_ref (uv_handle_t * arg1)");
    uv_ref_struct_inst.calls[uv_ref_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_ref_struct_inst.calls[uv_ref_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_ref_struct_inst.calls[uv_ref_struct_inst.expectedCalls].check_params = 1;
    uv_ref_struct_inst.expectedCalls++;
}

void uv_unref(uv_handle_t * arg1)
{
    int opmock_i;
    uv_unref_struct_inst.actualCalls++;

    if (uv_unref_struct_inst.callback != NULL)
    {
        uv_unref_struct_inst.callback (arg1, uv_unref_struct_inst.actualCalls);
        return;
    }
    if (uv_unref_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_unref', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_unref (uv_handle_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_unref(uv_handle_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_unref_struct_inst.calls[0].check_params == 1) {
        if(uv_unref_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_unref_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_unref_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_unref', %s",uv_unref_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_unref_struct_inst.expectedCalls; opmock_i++) {
        uv_unref_struct_inst.calls[opmock_i - 1] = uv_unref_struct_inst.calls[opmock_i];
    }

    uv_unref_struct_inst.expectedCalls--;
}

void uv_unref_MockReset()
{
    uv_unref_struct_inst.expectedCalls = 0;
    uv_unref_struct_inst.actualCalls = 0;
    uv_unref_struct_inst.callback = NULL;
}

void uv_unref_MockWithCallback(OPMOCK_uv_unref_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_unref_struct_inst.callback = callback;
    uv_unref_struct_inst.expectedCalls = 0;
    uv_unref_struct_inst.actualCalls = 0;
}

void uv_unref_VerifyMock()
{
    if (uv_unref_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_unref'",uv_unref_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_unref_ExpectAndReturn (uv_handle_t * arg1, OPMOCK_MATCHER match_arg1)
{
    if(uv_unref_struct_inst.callback != NULL)
    {
        uv_unref_MockReset ();
    }

    if(uv_unref_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_unref_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_unref (uv_handle_t * arg1)");
    uv_unref_struct_inst.calls[uv_unref_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_unref_struct_inst.calls[uv_unref_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_unref_struct_inst.calls[uv_unref_struct_inst.expectedCalls].check_params = 1;
    uv_unref_struct_inst.expectedCalls++;
}

int uv_has_ref(const uv_handle_t * arg1)
{
    int default_res = (int)uv_has_ref_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_has_ref_struct_inst.actualCalls++;

    if (uv_has_ref_struct_inst.callback != NULL)
    {
        return uv_has_ref_struct_inst.callback (arg1, uv_has_ref_struct_inst.actualCalls);
    }
    if (uv_has_ref_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_has_ref', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_has_ref (const uv_handle_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_has_ref(const uv_handle_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_has_ref_struct_inst.calls[0].check_params == 1) {
        if(uv_has_ref_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_has_ref_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_has_ref_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_has_ref', %s",uv_has_ref_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_has_ref_struct_inst.expectedCalls; opmock_i++) {
        uv_has_ref_struct_inst.calls[opmock_i - 1] = uv_has_ref_struct_inst.calls[opmock_i];
    }

    uv_has_ref_struct_inst.expectedCalls--;
    return default_res;
}

void uv_has_ref_MockReset()
{
    uv_has_ref_struct_inst.expectedCalls = 0;
    uv_has_ref_struct_inst.actualCalls = 0;
    uv_has_ref_struct_inst.callback = NULL;
}

void uv_has_ref_MockWithCallback(OPMOCK_uv_has_ref_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_has_ref_struct_inst.callback = callback;
    uv_has_ref_struct_inst.expectedCalls = 0;
    uv_has_ref_struct_inst.actualCalls = 0;
}

void uv_has_ref_VerifyMock()
{
    if (uv_has_ref_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_has_ref'",uv_has_ref_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_has_ref_ExpectAndReturn (const uv_handle_t * arg1, int to_return, OPMOCK_MATCHER match_arg1)
{
    if(uv_has_ref_struct_inst.callback != NULL)
    {
        uv_has_ref_MockReset ();
    }

    if(uv_has_ref_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_has_ref_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_has_ref (const uv_handle_t * arg1)");
    uv_has_ref_struct_inst.calls[uv_has_ref_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_has_ref_struct_inst.calls[uv_has_ref_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_has_ref_struct_inst.calls[uv_has_ref_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_has_ref_struct_inst.calls[uv_has_ref_struct_inst.expectedCalls].check_params = 1;
    uv_has_ref_struct_inst.expectedCalls++;
}

void uv_update_time(uv_loop_t * arg1)
{
    int opmock_i;
    uv_update_time_struct_inst.actualCalls++;

    if (uv_update_time_struct_inst.callback != NULL)
    {
        uv_update_time_struct_inst.callback (arg1, uv_update_time_struct_inst.actualCalls);
        return;
    }
    if (uv_update_time_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_update_time', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_update_time (uv_loop_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_update_time(uv_loop_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_update_time_struct_inst.calls[0].check_params == 1) {
        if(uv_update_time_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_update_time_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_update_time_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_update_time', %s",uv_update_time_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_update_time_struct_inst.expectedCalls; opmock_i++) {
        uv_update_time_struct_inst.calls[opmock_i - 1] = uv_update_time_struct_inst.calls[opmock_i];
    }

    uv_update_time_struct_inst.expectedCalls--;
}

void uv_update_time_MockReset()
{
    uv_update_time_struct_inst.expectedCalls = 0;
    uv_update_time_struct_inst.actualCalls = 0;
    uv_update_time_struct_inst.callback = NULL;
}

void uv_update_time_MockWithCallback(OPMOCK_uv_update_time_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_update_time_struct_inst.callback = callback;
    uv_update_time_struct_inst.expectedCalls = 0;
    uv_update_time_struct_inst.actualCalls = 0;
}

void uv_update_time_VerifyMock()
{
    if (uv_update_time_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_update_time'",uv_update_time_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_update_time_ExpectAndReturn (uv_loop_t * arg1, OPMOCK_MATCHER match_arg1)
{
    if(uv_update_time_struct_inst.callback != NULL)
    {
        uv_update_time_MockReset ();
    }

    if(uv_update_time_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_update_time_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_update_time (uv_loop_t * arg1)");
    uv_update_time_struct_inst.calls[uv_update_time_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_update_time_struct_inst.calls[uv_update_time_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_update_time_struct_inst.calls[uv_update_time_struct_inst.expectedCalls].check_params = 1;
    uv_update_time_struct_inst.expectedCalls++;
}

uint64_t uv_now(const uv_loop_t * arg1)
{
    uint64_t default_res = (uint64_t)uv_now_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_now_struct_inst.actualCalls++;

    if (uv_now_struct_inst.callback != NULL)
    {
        return uv_now_struct_inst.callback (arg1, uv_now_struct_inst.actualCalls);
    }
    if (uv_now_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_now', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uint64_t uv_now (const uv_loop_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uint64_t uv_now(const uv_loop_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_now_struct_inst.calls[0].check_params == 1) {
        if(uv_now_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_now_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_now_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_now', %s",uv_now_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_now_struct_inst.expectedCalls; opmock_i++) {
        uv_now_struct_inst.calls[opmock_i - 1] = uv_now_struct_inst.calls[opmock_i];
    }

    uv_now_struct_inst.expectedCalls--;
    return default_res;
}

void uv_now_MockReset()
{
    uv_now_struct_inst.expectedCalls = 0;
    uv_now_struct_inst.actualCalls = 0;
    uv_now_struct_inst.callback = NULL;
}

void uv_now_MockWithCallback(OPMOCK_uv_now_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_now_struct_inst.callback = callback;
    uv_now_struct_inst.expectedCalls = 0;
    uv_now_struct_inst.actualCalls = 0;
}

void uv_now_VerifyMock()
{
    if (uv_now_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_now'",uv_now_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_now_ExpectAndReturn (const uv_loop_t * arg1, uint64_t to_return, OPMOCK_MATCHER match_arg1)
{
    if(uv_now_struct_inst.callback != NULL)
    {
        uv_now_MockReset ();
    }

    if(uv_now_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_now_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uint64_t uv_now (const uv_loop_t * arg1)");
    uv_now_struct_inst.calls[uv_now_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_now_struct_inst.calls[uv_now_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_now_struct_inst.calls[uv_now_struct_inst.expectedCalls].to_return = (unsigned long long) to_return;
    uv_now_struct_inst.calls[uv_now_struct_inst.expectedCalls].check_params = 1;
    uv_now_struct_inst.expectedCalls++;
}

int uv_backend_fd(const uv_loop_t * arg1)
{
    int default_res = (int)uv_backend_fd_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_backend_fd_struct_inst.actualCalls++;

    if (uv_backend_fd_struct_inst.callback != NULL)
    {
        return uv_backend_fd_struct_inst.callback (arg1, uv_backend_fd_struct_inst.actualCalls);
    }
    if (uv_backend_fd_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_backend_fd', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_backend_fd (const uv_loop_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_backend_fd(const uv_loop_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_backend_fd_struct_inst.calls[0].check_params == 1) {
        if(uv_backend_fd_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_backend_fd_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_backend_fd_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_backend_fd', %s",uv_backend_fd_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_backend_fd_struct_inst.expectedCalls; opmock_i++) {
        uv_backend_fd_struct_inst.calls[opmock_i - 1] = uv_backend_fd_struct_inst.calls[opmock_i];
    }

    uv_backend_fd_struct_inst.expectedCalls--;
    return default_res;
}

void uv_backend_fd_MockReset()
{
    uv_backend_fd_struct_inst.expectedCalls = 0;
    uv_backend_fd_struct_inst.actualCalls = 0;
    uv_backend_fd_struct_inst.callback = NULL;
}

void uv_backend_fd_MockWithCallback(OPMOCK_uv_backend_fd_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_backend_fd_struct_inst.callback = callback;
    uv_backend_fd_struct_inst.expectedCalls = 0;
    uv_backend_fd_struct_inst.actualCalls = 0;
}

void uv_backend_fd_VerifyMock()
{
    if (uv_backend_fd_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_backend_fd'",uv_backend_fd_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_backend_fd_ExpectAndReturn (const uv_loop_t * arg1, int to_return, OPMOCK_MATCHER match_arg1)
{
    if(uv_backend_fd_struct_inst.callback != NULL)
    {
        uv_backend_fd_MockReset ();
    }

    if(uv_backend_fd_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_backend_fd_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_backend_fd (const uv_loop_t * arg1)");
    uv_backend_fd_struct_inst.calls[uv_backend_fd_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_backend_fd_struct_inst.calls[uv_backend_fd_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_backend_fd_struct_inst.calls[uv_backend_fd_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_backend_fd_struct_inst.calls[uv_backend_fd_struct_inst.expectedCalls].check_params = 1;
    uv_backend_fd_struct_inst.expectedCalls++;
}

int uv_backend_timeout(const uv_loop_t * arg1)
{
    int default_res = (int)uv_backend_timeout_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_backend_timeout_struct_inst.actualCalls++;

    if (uv_backend_timeout_struct_inst.callback != NULL)
    {
        return uv_backend_timeout_struct_inst.callback (arg1, uv_backend_timeout_struct_inst.actualCalls);
    }
    if (uv_backend_timeout_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_backend_timeout', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_backend_timeout (const uv_loop_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_backend_timeout(const uv_loop_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_backend_timeout_struct_inst.calls[0].check_params == 1) {
        if(uv_backend_timeout_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_backend_timeout_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_backend_timeout_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_backend_timeout', %s",uv_backend_timeout_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_backend_timeout_struct_inst.expectedCalls; opmock_i++) {
        uv_backend_timeout_struct_inst.calls[opmock_i - 1] = uv_backend_timeout_struct_inst.calls[opmock_i];
    }

    uv_backend_timeout_struct_inst.expectedCalls--;
    return default_res;
}

void uv_backend_timeout_MockReset()
{
    uv_backend_timeout_struct_inst.expectedCalls = 0;
    uv_backend_timeout_struct_inst.actualCalls = 0;
    uv_backend_timeout_struct_inst.callback = NULL;
}

void uv_backend_timeout_MockWithCallback(OPMOCK_uv_backend_timeout_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_backend_timeout_struct_inst.callback = callback;
    uv_backend_timeout_struct_inst.expectedCalls = 0;
    uv_backend_timeout_struct_inst.actualCalls = 0;
}

void uv_backend_timeout_VerifyMock()
{
    if (uv_backend_timeout_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_backend_timeout'",uv_backend_timeout_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_backend_timeout_ExpectAndReturn (const uv_loop_t * arg1, int to_return, OPMOCK_MATCHER match_arg1)
{
    if(uv_backend_timeout_struct_inst.callback != NULL)
    {
        uv_backend_timeout_MockReset ();
    }

    if(uv_backend_timeout_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_backend_timeout_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_backend_timeout (const uv_loop_t * arg1)");
    uv_backend_timeout_struct_inst.calls[uv_backend_timeout_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_backend_timeout_struct_inst.calls[uv_backend_timeout_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_backend_timeout_struct_inst.calls[uv_backend_timeout_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_backend_timeout_struct_inst.calls[uv_backend_timeout_struct_inst.expectedCalls].check_params = 1;
    uv_backend_timeout_struct_inst.expectedCalls++;
}

const char * uv_strerror(int err)
{
    const char * default_res = (const char *)uv_strerror_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_strerror_struct_inst.actualCalls++;

    if (uv_strerror_struct_inst.callback != NULL)
    {
        return uv_strerror_struct_inst.callback (err, uv_strerror_struct_inst.actualCalls);
    }
    if (uv_strerror_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_strerror', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "const char * uv_strerror (int err)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'const char * uv_strerror(int err)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_strerror_struct_inst.calls[0].check_params == 1) {
        if(uv_strerror_struct_inst.calls[0].match_err) {
            void * val1 = (void *) &uv_strerror_struct_inst.calls[0].err;
            void * val2 = (void *) &err;
            int match_result = uv_strerror_struct_inst.calls[0].match_err(val1, val2, "err", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_strerror', %s",uv_strerror_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_strerror_struct_inst.expectedCalls; opmock_i++) {
        uv_strerror_struct_inst.calls[opmock_i - 1] = uv_strerror_struct_inst.calls[opmock_i];
    }

    uv_strerror_struct_inst.expectedCalls--;
    return default_res;
}

void uv_strerror_MockReset()
{
    uv_strerror_struct_inst.expectedCalls = 0;
    uv_strerror_struct_inst.actualCalls = 0;
    uv_strerror_struct_inst.callback = NULL;
}

void uv_strerror_MockWithCallback(OPMOCK_uv_strerror_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_strerror_struct_inst.callback = callback;
    uv_strerror_struct_inst.expectedCalls = 0;
    uv_strerror_struct_inst.actualCalls = 0;
}

void uv_strerror_VerifyMock()
{
    if (uv_strerror_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_strerror'",uv_strerror_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_strerror_ExpectAndReturn (int err, const char * to_return, OPMOCK_MATCHER match_err)
{
    if(uv_strerror_struct_inst.callback != NULL)
    {
        uv_strerror_MockReset ();
    }

    if(uv_strerror_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_strerror_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"const char * uv_strerror (int err)");
    uv_strerror_struct_inst.calls[uv_strerror_struct_inst.expectedCalls].err = (int)err;
    uv_strerror_struct_inst.calls[uv_strerror_struct_inst.expectedCalls].match_err = match_err;
    uv_strerror_struct_inst.calls[uv_strerror_struct_inst.expectedCalls].to_return = ( char *) to_return;
    uv_strerror_struct_inst.calls[uv_strerror_struct_inst.expectedCalls].check_params = 1;
    uv_strerror_struct_inst.expectedCalls++;
}

const char * uv_err_name(int err)
{
    const char * default_res = (const char *)uv_err_name_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_err_name_struct_inst.actualCalls++;

    if (uv_err_name_struct_inst.callback != NULL)
    {
        return uv_err_name_struct_inst.callback (err, uv_err_name_struct_inst.actualCalls);
    }
    if (uv_err_name_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_err_name', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "const char * uv_err_name (int err)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'const char * uv_err_name(int err)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_err_name_struct_inst.calls[0].check_params == 1) {
        if(uv_err_name_struct_inst.calls[0].match_err) {
            void * val1 = (void *) &uv_err_name_struct_inst.calls[0].err;
            void * val2 = (void *) &err;
            int match_result = uv_err_name_struct_inst.calls[0].match_err(val1, val2, "err", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_err_name', %s",uv_err_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_err_name_struct_inst.expectedCalls; opmock_i++) {
        uv_err_name_struct_inst.calls[opmock_i - 1] = uv_err_name_struct_inst.calls[opmock_i];
    }

    uv_err_name_struct_inst.expectedCalls--;
    return default_res;
}

void uv_err_name_MockReset()
{
    uv_err_name_struct_inst.expectedCalls = 0;
    uv_err_name_struct_inst.actualCalls = 0;
    uv_err_name_struct_inst.callback = NULL;
}

void uv_err_name_MockWithCallback(OPMOCK_uv_err_name_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_err_name_struct_inst.callback = callback;
    uv_err_name_struct_inst.expectedCalls = 0;
    uv_err_name_struct_inst.actualCalls = 0;
}

void uv_err_name_VerifyMock()
{
    if (uv_err_name_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_err_name'",uv_err_name_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_err_name_ExpectAndReturn (int err, const char * to_return, OPMOCK_MATCHER match_err)
{
    if(uv_err_name_struct_inst.callback != NULL)
    {
        uv_err_name_MockReset ();
    }

    if(uv_err_name_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_err_name_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"const char * uv_err_name (int err)");
    uv_err_name_struct_inst.calls[uv_err_name_struct_inst.expectedCalls].err = (int)err;
    uv_err_name_struct_inst.calls[uv_err_name_struct_inst.expectedCalls].match_err = match_err;
    uv_err_name_struct_inst.calls[uv_err_name_struct_inst.expectedCalls].to_return = ( char *) to_return;
    uv_err_name_struct_inst.calls[uv_err_name_struct_inst.expectedCalls].check_params = 1;
    uv_err_name_struct_inst.expectedCalls++;
}

int uv_shutdown(uv_shutdown_t * req, uv_stream_t * handle, uv_shutdown_cb cb)
{
    int default_res = (int)uv_shutdown_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_shutdown_struct_inst.actualCalls++;

    if (uv_shutdown_struct_inst.callback != NULL)
    {
        return uv_shutdown_struct_inst.callback (req, handle, cb, uv_shutdown_struct_inst.actualCalls);
    }
    if (uv_shutdown_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_shutdown', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_shutdown (uv_shutdown_t * req, uv_stream_t * handle, uv_shutdown_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_shutdown(uv_shutdown_t * req, uv_stream_t * handle, uv_shutdown_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_shutdown_struct_inst.calls[0].check_params == 1) {
        if(uv_shutdown_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_shutdown_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_shutdown_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_shutdown', %s",uv_shutdown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_shutdown_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_shutdown_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_shutdown_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_shutdown', %s",uv_shutdown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_shutdown_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_shutdown_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_shutdown_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_shutdown', %s",uv_shutdown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_shutdown_struct_inst.expectedCalls; opmock_i++) {
        uv_shutdown_struct_inst.calls[opmock_i - 1] = uv_shutdown_struct_inst.calls[opmock_i];
    }

    uv_shutdown_struct_inst.expectedCalls--;
    return default_res;
}

void uv_shutdown_MockReset()
{
    uv_shutdown_struct_inst.expectedCalls = 0;
    uv_shutdown_struct_inst.actualCalls = 0;
    uv_shutdown_struct_inst.callback = NULL;
}

void uv_shutdown_MockWithCallback(OPMOCK_uv_shutdown_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_shutdown_struct_inst.callback = callback;
    uv_shutdown_struct_inst.expectedCalls = 0;
    uv_shutdown_struct_inst.actualCalls = 0;
}

void uv_shutdown_VerifyMock()
{
    if (uv_shutdown_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_shutdown'",uv_shutdown_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_shutdown_ExpectAndReturn (uv_shutdown_t * req, uv_stream_t * handle, uv_shutdown_cb cb, int to_return, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_cb)
{
    if(uv_shutdown_struct_inst.callback != NULL)
    {
        uv_shutdown_MockReset ();
    }

    if(uv_shutdown_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_shutdown_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_shutdown (uv_shutdown_t * req, uv_stream_t * handle, uv_shutdown_cb cb)");
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].req = (void *)req;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].handle = (void *)handle;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].cb = (void *)cb;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].match_req = match_req;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].match_handle = match_handle;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].match_cb = match_cb;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_shutdown_struct_inst.calls[uv_shutdown_struct_inst.expectedCalls].check_params = 1;
    uv_shutdown_struct_inst.expectedCalls++;
}

size_t uv_handle_size(uv_handle_type type)
{
    size_t default_res = (size_t)uv_handle_size_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_handle_size_struct_inst.actualCalls++;

    if (uv_handle_size_struct_inst.callback != NULL)
    {
        return uv_handle_size_struct_inst.callback (type, uv_handle_size_struct_inst.actualCalls);
    }
    if (uv_handle_size_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_handle_size', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "size_t uv_handle_size (uv_handle_type type)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'size_t uv_handle_size(uv_handle_type type)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_handle_size_struct_inst.calls[0].check_params == 1) {
        if(uv_handle_size_struct_inst.calls[0].match_type) {
            void * val1 = (void *) &uv_handle_size_struct_inst.calls[0].type;
            void * val2 = (void *) &type;
            int match_result = uv_handle_size_struct_inst.calls[0].match_type(val1, val2, "type", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_handle_size', %s",uv_handle_size_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_handle_size_struct_inst.expectedCalls; opmock_i++) {
        uv_handle_size_struct_inst.calls[opmock_i - 1] = uv_handle_size_struct_inst.calls[opmock_i];
    }

    uv_handle_size_struct_inst.expectedCalls--;
    return default_res;
}

void uv_handle_size_MockReset()
{
    uv_handle_size_struct_inst.expectedCalls = 0;
    uv_handle_size_struct_inst.actualCalls = 0;
    uv_handle_size_struct_inst.callback = NULL;
}

void uv_handle_size_MockWithCallback(OPMOCK_uv_handle_size_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_handle_size_struct_inst.callback = callback;
    uv_handle_size_struct_inst.expectedCalls = 0;
    uv_handle_size_struct_inst.actualCalls = 0;
}

void uv_handle_size_VerifyMock()
{
    if (uv_handle_size_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_handle_size'",uv_handle_size_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_handle_size_ExpectAndReturn (uv_handle_type type, size_t to_return, OPMOCK_MATCHER match_type)
{
    if(uv_handle_size_struct_inst.callback != NULL)
    {
        uv_handle_size_MockReset ();
    }

    if(uv_handle_size_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_handle_size_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"size_t uv_handle_size (uv_handle_type type)");
    uv_handle_size_struct_inst.calls[uv_handle_size_struct_inst.expectedCalls].type = (uv_handle_type)type;
    uv_handle_size_struct_inst.calls[uv_handle_size_struct_inst.expectedCalls].match_type = match_type;
    uv_handle_size_struct_inst.calls[uv_handle_size_struct_inst.expectedCalls].to_return = (unsigned long) to_return;
    uv_handle_size_struct_inst.calls[uv_handle_size_struct_inst.expectedCalls].check_params = 1;
    uv_handle_size_struct_inst.expectedCalls++;
}

size_t uv_req_size(uv_req_type type)
{
    size_t default_res = (size_t)uv_req_size_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_req_size_struct_inst.actualCalls++;

    if (uv_req_size_struct_inst.callback != NULL)
    {
        return uv_req_size_struct_inst.callback (type, uv_req_size_struct_inst.actualCalls);
    }
    if (uv_req_size_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_req_size', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "size_t uv_req_size (uv_req_type type)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'size_t uv_req_size(uv_req_type type)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_req_size_struct_inst.calls[0].check_params == 1) {
        if(uv_req_size_struct_inst.calls[0].match_type) {
            void * val1 = (void *) &uv_req_size_struct_inst.calls[0].type;
            void * val2 = (void *) &type;
            int match_result = uv_req_size_struct_inst.calls[0].match_type(val1, val2, "type", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_req_size', %s",uv_req_size_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_req_size_struct_inst.expectedCalls; opmock_i++) {
        uv_req_size_struct_inst.calls[opmock_i - 1] = uv_req_size_struct_inst.calls[opmock_i];
    }

    uv_req_size_struct_inst.expectedCalls--;
    return default_res;
}

void uv_req_size_MockReset()
{
    uv_req_size_struct_inst.expectedCalls = 0;
    uv_req_size_struct_inst.actualCalls = 0;
    uv_req_size_struct_inst.callback = NULL;
}

void uv_req_size_MockWithCallback(OPMOCK_uv_req_size_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_req_size_struct_inst.callback = callback;
    uv_req_size_struct_inst.expectedCalls = 0;
    uv_req_size_struct_inst.actualCalls = 0;
}

void uv_req_size_VerifyMock()
{
    if (uv_req_size_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_req_size'",uv_req_size_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_req_size_ExpectAndReturn (uv_req_type type, size_t to_return, OPMOCK_MATCHER match_type)
{
    if(uv_req_size_struct_inst.callback != NULL)
    {
        uv_req_size_MockReset ();
    }

    if(uv_req_size_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_req_size_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"size_t uv_req_size (uv_req_type type)");
    uv_req_size_struct_inst.calls[uv_req_size_struct_inst.expectedCalls].type = (uv_req_type)type;
    uv_req_size_struct_inst.calls[uv_req_size_struct_inst.expectedCalls].match_type = match_type;
    uv_req_size_struct_inst.calls[uv_req_size_struct_inst.expectedCalls].to_return = (unsigned long) to_return;
    uv_req_size_struct_inst.calls[uv_req_size_struct_inst.expectedCalls].check_params = 1;
    uv_req_size_struct_inst.expectedCalls++;
}

int uv_is_active(const uv_handle_t * handle)
{
    int default_res = (int)uv_is_active_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_is_active_struct_inst.actualCalls++;

    if (uv_is_active_struct_inst.callback != NULL)
    {
        return uv_is_active_struct_inst.callback (handle, uv_is_active_struct_inst.actualCalls);
    }
    if (uv_is_active_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_is_active', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_is_active (const uv_handle_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_is_active(const uv_handle_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_is_active_struct_inst.calls[0].check_params == 1) {
        if(uv_is_active_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_is_active_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_is_active_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_is_active', %s",uv_is_active_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_is_active_struct_inst.expectedCalls; opmock_i++) {
        uv_is_active_struct_inst.calls[opmock_i - 1] = uv_is_active_struct_inst.calls[opmock_i];
    }

    uv_is_active_struct_inst.expectedCalls--;
    return default_res;
}

void uv_is_active_MockReset()
{
    uv_is_active_struct_inst.expectedCalls = 0;
    uv_is_active_struct_inst.actualCalls = 0;
    uv_is_active_struct_inst.callback = NULL;
}

void uv_is_active_MockWithCallback(OPMOCK_uv_is_active_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_is_active_struct_inst.callback = callback;
    uv_is_active_struct_inst.expectedCalls = 0;
    uv_is_active_struct_inst.actualCalls = 0;
}

void uv_is_active_VerifyMock()
{
    if (uv_is_active_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_is_active'",uv_is_active_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_is_active_ExpectAndReturn (const uv_handle_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_is_active_struct_inst.callback != NULL)
    {
        uv_is_active_MockReset ();
    }

    if(uv_is_active_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_is_active_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_is_active (const uv_handle_t * handle)");
    uv_is_active_struct_inst.calls[uv_is_active_struct_inst.expectedCalls].handle = (void *)handle;
    uv_is_active_struct_inst.calls[uv_is_active_struct_inst.expectedCalls].match_handle = match_handle;
    uv_is_active_struct_inst.calls[uv_is_active_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_is_active_struct_inst.calls[uv_is_active_struct_inst.expectedCalls].check_params = 1;
    uv_is_active_struct_inst.expectedCalls++;
}

void uv_walk(uv_loop_t * loop, uv_walk_cb walk_cb, void * arg)
{
    int opmock_i;
    uv_walk_struct_inst.actualCalls++;

    if (uv_walk_struct_inst.callback != NULL)
    {
        uv_walk_struct_inst.callback (loop, walk_cb, arg, uv_walk_struct_inst.actualCalls);
        return;
    }
    if (uv_walk_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_walk', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_walk (uv_loop_t * loop, uv_walk_cb walk_cb, void * arg)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_walk(uv_loop_t * loop, uv_walk_cb walk_cb, void * arg)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_walk_struct_inst.calls[0].check_params == 1) {
        if(uv_walk_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_walk_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_walk_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_walk', %s",uv_walk_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_walk_struct_inst.calls[0].match_walk_cb) {
            void * val1 = (void *) &uv_walk_struct_inst.calls[0].walk_cb;
            void * val2 = (void *) &walk_cb;
            int match_result = uv_walk_struct_inst.calls[0].match_walk_cb(val1, val2, "walk_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_walk', %s",uv_walk_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_walk_struct_inst.calls[0].match_arg) {
            void * val1 = (void *) &uv_walk_struct_inst.calls[0].arg;
            void * val2 = (void *) &arg;
            int match_result = uv_walk_struct_inst.calls[0].match_arg(val1, val2, "arg", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_walk', %s",uv_walk_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_walk_struct_inst.expectedCalls; opmock_i++) {
        uv_walk_struct_inst.calls[opmock_i - 1] = uv_walk_struct_inst.calls[opmock_i];
    }

    uv_walk_struct_inst.expectedCalls--;
}

void uv_walk_MockReset()
{
    uv_walk_struct_inst.expectedCalls = 0;
    uv_walk_struct_inst.actualCalls = 0;
    uv_walk_struct_inst.callback = NULL;
}

void uv_walk_MockWithCallback(OPMOCK_uv_walk_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_walk_struct_inst.callback = callback;
    uv_walk_struct_inst.expectedCalls = 0;
    uv_walk_struct_inst.actualCalls = 0;
}

void uv_walk_VerifyMock()
{
    if (uv_walk_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_walk'",uv_walk_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_walk_ExpectAndReturn (uv_loop_t * loop, uv_walk_cb walk_cb, void * arg, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_walk_cb, OPMOCK_MATCHER match_arg)
{
    if(uv_walk_struct_inst.callback != NULL)
    {
        uv_walk_MockReset ();
    }

    if(uv_walk_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_walk_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_walk (uv_loop_t * loop, uv_walk_cb walk_cb, void * arg)");
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].loop = (void *)loop;
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].walk_cb = (void *)walk_cb;
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].arg = (void *)arg;
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].match_loop = match_loop;
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].match_walk_cb = match_walk_cb;
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].match_arg = match_arg;
    uv_walk_struct_inst.calls[uv_walk_struct_inst.expectedCalls].check_params = 1;
    uv_walk_struct_inst.expectedCalls++;
}

void uv_close(uv_handle_t * handle, uv_close_cb close_cb)
{
    int opmock_i;
    uv_close_struct_inst.actualCalls++;

    if (uv_close_struct_inst.callback != NULL)
    {
        uv_close_struct_inst.callback (handle, close_cb, uv_close_struct_inst.actualCalls);
        return;
    }
    if (uv_close_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_close', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_close (uv_handle_t * handle, uv_close_cb close_cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_close(uv_handle_t * handle, uv_close_cb close_cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_close_struct_inst.calls[0].check_params == 1) {
        if(uv_close_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_close_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_close_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_close', %s",uv_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_close_struct_inst.calls[0].match_close_cb) {
            void * val1 = (void *) &uv_close_struct_inst.calls[0].close_cb;
            void * val2 = (void *) &close_cb;
            int match_result = uv_close_struct_inst.calls[0].match_close_cb(val1, val2, "close_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_close', %s",uv_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_close_struct_inst.expectedCalls; opmock_i++) {
        uv_close_struct_inst.calls[opmock_i - 1] = uv_close_struct_inst.calls[opmock_i];
    }

    uv_close_struct_inst.expectedCalls--;
}

void uv_close_MockReset()
{
    uv_close_struct_inst.expectedCalls = 0;
    uv_close_struct_inst.actualCalls = 0;
    uv_close_struct_inst.callback = NULL;
}

void uv_close_MockWithCallback(OPMOCK_uv_close_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_close_struct_inst.callback = callback;
    uv_close_struct_inst.expectedCalls = 0;
    uv_close_struct_inst.actualCalls = 0;
}

void uv_close_VerifyMock()
{
    if (uv_close_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_close'",uv_close_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_close_ExpectAndReturn (uv_handle_t * handle, uv_close_cb close_cb, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_close_cb)
{
    if(uv_close_struct_inst.callback != NULL)
    {
        uv_close_MockReset ();
    }

    if(uv_close_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_close_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_close (uv_handle_t * handle, uv_close_cb close_cb)");
    uv_close_struct_inst.calls[uv_close_struct_inst.expectedCalls].handle = (void *)handle;
    uv_close_struct_inst.calls[uv_close_struct_inst.expectedCalls].close_cb = (void *)close_cb;
    uv_close_struct_inst.calls[uv_close_struct_inst.expectedCalls].match_handle = match_handle;
    uv_close_struct_inst.calls[uv_close_struct_inst.expectedCalls].match_close_cb = match_close_cb;
    uv_close_struct_inst.calls[uv_close_struct_inst.expectedCalls].check_params = 1;
    uv_close_struct_inst.expectedCalls++;
}

int uv_send_buffer_size(uv_handle_t * handle, int * value)
{
    int default_res = (int)uv_send_buffer_size_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_send_buffer_size_struct_inst.actualCalls++;

    if (uv_send_buffer_size_struct_inst.callback != NULL)
    {
        return uv_send_buffer_size_struct_inst.callback (handle, value, uv_send_buffer_size_struct_inst.actualCalls);
    }
    if (uv_send_buffer_size_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_send_buffer_size', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_send_buffer_size (uv_handle_t * handle, int * value)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_send_buffer_size(uv_handle_t * handle, int * value)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_send_buffer_size_struct_inst.calls[0].check_params == 1) {
        if(uv_send_buffer_size_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_send_buffer_size_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_send_buffer_size_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_send_buffer_size', %s",uv_send_buffer_size_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_send_buffer_size_struct_inst.calls[0].match_value) {
            void * val1 = (void *) &uv_send_buffer_size_struct_inst.calls[0].value;
            void * val2 = (void *) &value;
            int match_result = uv_send_buffer_size_struct_inst.calls[0].match_value(val1, val2, "value", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_send_buffer_size', %s",uv_send_buffer_size_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_send_buffer_size_struct_inst.expectedCalls; opmock_i++) {
        uv_send_buffer_size_struct_inst.calls[opmock_i - 1] = uv_send_buffer_size_struct_inst.calls[opmock_i];
    }

    uv_send_buffer_size_struct_inst.expectedCalls--;
    return default_res;
}

void uv_send_buffer_size_MockReset()
{
    uv_send_buffer_size_struct_inst.expectedCalls = 0;
    uv_send_buffer_size_struct_inst.actualCalls = 0;
    uv_send_buffer_size_struct_inst.callback = NULL;
}

void uv_send_buffer_size_MockWithCallback(OPMOCK_uv_send_buffer_size_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_send_buffer_size_struct_inst.callback = callback;
    uv_send_buffer_size_struct_inst.expectedCalls = 0;
    uv_send_buffer_size_struct_inst.actualCalls = 0;
}

void uv_send_buffer_size_VerifyMock()
{
    if (uv_send_buffer_size_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_send_buffer_size'",uv_send_buffer_size_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_send_buffer_size_ExpectAndReturn (uv_handle_t * handle, int * value, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_value)
{
    if(uv_send_buffer_size_struct_inst.callback != NULL)
    {
        uv_send_buffer_size_MockReset ();
    }

    if(uv_send_buffer_size_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_send_buffer_size_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_send_buffer_size (uv_handle_t * handle, int * value)");
    uv_send_buffer_size_struct_inst.calls[uv_send_buffer_size_struct_inst.expectedCalls].handle = (void *)handle;
    uv_send_buffer_size_struct_inst.calls[uv_send_buffer_size_struct_inst.expectedCalls].value = (void *)value;
    uv_send_buffer_size_struct_inst.calls[uv_send_buffer_size_struct_inst.expectedCalls].match_handle = match_handle;
    uv_send_buffer_size_struct_inst.calls[uv_send_buffer_size_struct_inst.expectedCalls].match_value = match_value;
    uv_send_buffer_size_struct_inst.calls[uv_send_buffer_size_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_send_buffer_size_struct_inst.calls[uv_send_buffer_size_struct_inst.expectedCalls].check_params = 1;
    uv_send_buffer_size_struct_inst.expectedCalls++;
}

int uv_recv_buffer_size(uv_handle_t * handle, int * value)
{
    int default_res = (int)uv_recv_buffer_size_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_recv_buffer_size_struct_inst.actualCalls++;

    if (uv_recv_buffer_size_struct_inst.callback != NULL)
    {
        return uv_recv_buffer_size_struct_inst.callback (handle, value, uv_recv_buffer_size_struct_inst.actualCalls);
    }
    if (uv_recv_buffer_size_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_recv_buffer_size', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_recv_buffer_size (uv_handle_t * handle, int * value)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_recv_buffer_size(uv_handle_t * handle, int * value)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_recv_buffer_size_struct_inst.calls[0].check_params == 1) {
        if(uv_recv_buffer_size_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_recv_buffer_size_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_recv_buffer_size_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_recv_buffer_size', %s",uv_recv_buffer_size_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_recv_buffer_size_struct_inst.calls[0].match_value) {
            void * val1 = (void *) &uv_recv_buffer_size_struct_inst.calls[0].value;
            void * val2 = (void *) &value;
            int match_result = uv_recv_buffer_size_struct_inst.calls[0].match_value(val1, val2, "value", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_recv_buffer_size', %s",uv_recv_buffer_size_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_recv_buffer_size_struct_inst.expectedCalls; opmock_i++) {
        uv_recv_buffer_size_struct_inst.calls[opmock_i - 1] = uv_recv_buffer_size_struct_inst.calls[opmock_i];
    }

    uv_recv_buffer_size_struct_inst.expectedCalls--;
    return default_res;
}

void uv_recv_buffer_size_MockReset()
{
    uv_recv_buffer_size_struct_inst.expectedCalls = 0;
    uv_recv_buffer_size_struct_inst.actualCalls = 0;
    uv_recv_buffer_size_struct_inst.callback = NULL;
}

void uv_recv_buffer_size_MockWithCallback(OPMOCK_uv_recv_buffer_size_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_recv_buffer_size_struct_inst.callback = callback;
    uv_recv_buffer_size_struct_inst.expectedCalls = 0;
    uv_recv_buffer_size_struct_inst.actualCalls = 0;
}

void uv_recv_buffer_size_VerifyMock()
{
    if (uv_recv_buffer_size_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_recv_buffer_size'",uv_recv_buffer_size_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_recv_buffer_size_ExpectAndReturn (uv_handle_t * handle, int * value, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_value)
{
    if(uv_recv_buffer_size_struct_inst.callback != NULL)
    {
        uv_recv_buffer_size_MockReset ();
    }

    if(uv_recv_buffer_size_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_recv_buffer_size_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_recv_buffer_size (uv_handle_t * handle, int * value)");
    uv_recv_buffer_size_struct_inst.calls[uv_recv_buffer_size_struct_inst.expectedCalls].handle = (void *)handle;
    uv_recv_buffer_size_struct_inst.calls[uv_recv_buffer_size_struct_inst.expectedCalls].value = (void *)value;
    uv_recv_buffer_size_struct_inst.calls[uv_recv_buffer_size_struct_inst.expectedCalls].match_handle = match_handle;
    uv_recv_buffer_size_struct_inst.calls[uv_recv_buffer_size_struct_inst.expectedCalls].match_value = match_value;
    uv_recv_buffer_size_struct_inst.calls[uv_recv_buffer_size_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_recv_buffer_size_struct_inst.calls[uv_recv_buffer_size_struct_inst.expectedCalls].check_params = 1;
    uv_recv_buffer_size_struct_inst.expectedCalls++;
}

int uv_fileno(const uv_handle_t * handle, uv_os_fd_t * fd)
{
    int default_res = (int)uv_fileno_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fileno_struct_inst.actualCalls++;

    if (uv_fileno_struct_inst.callback != NULL)
    {
        return uv_fileno_struct_inst.callback (handle, fd, uv_fileno_struct_inst.actualCalls);
    }
    if (uv_fileno_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fileno', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fileno (const uv_handle_t * handle, uv_os_fd_t * fd)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fileno(const uv_handle_t * handle, uv_os_fd_t * fd)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fileno_struct_inst.calls[0].check_params == 1) {
        if(uv_fileno_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fileno_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fileno_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fileno', %s",uv_fileno_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fileno_struct_inst.calls[0].match_fd) {
            void * val1 = (void *) &uv_fileno_struct_inst.calls[0].fd;
            void * val2 = (void *) &fd;
            int match_result = uv_fileno_struct_inst.calls[0].match_fd(val1, val2, "fd", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fileno', %s",uv_fileno_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fileno_struct_inst.expectedCalls; opmock_i++) {
        uv_fileno_struct_inst.calls[opmock_i - 1] = uv_fileno_struct_inst.calls[opmock_i];
    }

    uv_fileno_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fileno_MockReset()
{
    uv_fileno_struct_inst.expectedCalls = 0;
    uv_fileno_struct_inst.actualCalls = 0;
    uv_fileno_struct_inst.callback = NULL;
}

void uv_fileno_MockWithCallback(OPMOCK_uv_fileno_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fileno_struct_inst.callback = callback;
    uv_fileno_struct_inst.expectedCalls = 0;
    uv_fileno_struct_inst.actualCalls = 0;
}

void uv_fileno_VerifyMock()
{
    if (uv_fileno_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fileno'",uv_fileno_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fileno_ExpectAndReturn (const uv_handle_t * handle, uv_os_fd_t * fd, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_fd)
{
    if(uv_fileno_struct_inst.callback != NULL)
    {
        uv_fileno_MockReset ();
    }

    if(uv_fileno_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fileno_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fileno (const uv_handle_t * handle, uv_os_fd_t * fd)");
    uv_fileno_struct_inst.calls[uv_fileno_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fileno_struct_inst.calls[uv_fileno_struct_inst.expectedCalls].fd = (void *)fd;
    uv_fileno_struct_inst.calls[uv_fileno_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fileno_struct_inst.calls[uv_fileno_struct_inst.expectedCalls].match_fd = match_fd;
    uv_fileno_struct_inst.calls[uv_fileno_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fileno_struct_inst.calls[uv_fileno_struct_inst.expectedCalls].check_params = 1;
    uv_fileno_struct_inst.expectedCalls++;
}

uv_buf_t uv_buf_init(char * base, unsigned int len)
{
    uv_buf_t default_res = (uv_buf_t)uv_buf_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_buf_init_struct_inst.actualCalls++;

    if (uv_buf_init_struct_inst.callback != NULL)
    {
        return uv_buf_init_struct_inst.callback (base, len, uv_buf_init_struct_inst.actualCalls);
    }
    if (uv_buf_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_buf_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uv_buf_t uv_buf_init (char * base, unsigned int len)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uv_buf_t uv_buf_init(char * base, unsigned int len)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_buf_init_struct_inst.calls[0].check_params == 1) {
        if(uv_buf_init_struct_inst.calls[0].match_base) {
            void * val1 = (void *) &uv_buf_init_struct_inst.calls[0].base;
            void * val2 = (void *) &base;
            int match_result = uv_buf_init_struct_inst.calls[0].match_base(val1, val2, "base", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_buf_init', %s",uv_buf_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_buf_init_struct_inst.calls[0].match_len) {
            void * val1 = (void *) &uv_buf_init_struct_inst.calls[0].len;
            void * val2 = (void *) &len;
            int match_result = uv_buf_init_struct_inst.calls[0].match_len(val1, val2, "len", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_buf_init', %s",uv_buf_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_buf_init_struct_inst.expectedCalls; opmock_i++) {
        uv_buf_init_struct_inst.calls[opmock_i - 1] = uv_buf_init_struct_inst.calls[opmock_i];
    }

    uv_buf_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_buf_init_MockReset()
{
    uv_buf_init_struct_inst.expectedCalls = 0;
    uv_buf_init_struct_inst.actualCalls = 0;
    uv_buf_init_struct_inst.callback = NULL;
}

void uv_buf_init_MockWithCallback(OPMOCK_uv_buf_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_buf_init_struct_inst.callback = callback;
    uv_buf_init_struct_inst.expectedCalls = 0;
    uv_buf_init_struct_inst.actualCalls = 0;
}

void uv_buf_init_VerifyMock()
{
    if (uv_buf_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_buf_init'",uv_buf_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_buf_init_ExpectAndReturn (char * base, unsigned int len, uv_buf_t to_return, OPMOCK_MATCHER match_base, OPMOCK_MATCHER match_len)
{
    if(uv_buf_init_struct_inst.callback != NULL)
    {
        uv_buf_init_MockReset ();
    }

    if(uv_buf_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_buf_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uv_buf_t uv_buf_init (char * base, unsigned int len)");
    uv_buf_init_struct_inst.calls[uv_buf_init_struct_inst.expectedCalls].base = (void *)base;
    uv_buf_init_struct_inst.calls[uv_buf_init_struct_inst.expectedCalls].len = (unsigned int)len;
    uv_buf_init_struct_inst.calls[uv_buf_init_struct_inst.expectedCalls].match_base = match_base;
    uv_buf_init_struct_inst.calls[uv_buf_init_struct_inst.expectedCalls].match_len = match_len;
    uv_buf_init_struct_inst.calls[uv_buf_init_struct_inst.expectedCalls].to_return = (struct uv_buf_t) to_return;
    uv_buf_init_struct_inst.calls[uv_buf_init_struct_inst.expectedCalls].check_params = 1;
    uv_buf_init_struct_inst.expectedCalls++;
}

int uv_listen(uv_stream_t * stream, int backlog, uv_connection_cb cb)
{
    int default_res = (int)uv_listen_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_listen_struct_inst.actualCalls++;

    if (uv_listen_struct_inst.callback != NULL)
    {
        return uv_listen_struct_inst.callback (stream, backlog, cb, uv_listen_struct_inst.actualCalls);
    }
    if (uv_listen_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_listen', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_listen (uv_stream_t * stream, int backlog, uv_connection_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_listen(uv_stream_t * stream, int backlog, uv_connection_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_listen_struct_inst.calls[0].check_params == 1) {
        if(uv_listen_struct_inst.calls[0].match_stream) {
            void * val1 = (void *) &uv_listen_struct_inst.calls[0].stream;
            void * val2 = (void *) &stream;
            int match_result = uv_listen_struct_inst.calls[0].match_stream(val1, val2, "stream", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_listen', %s",uv_listen_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_listen_struct_inst.calls[0].match_backlog) {
            void * val1 = (void *) &uv_listen_struct_inst.calls[0].backlog;
            void * val2 = (void *) &backlog;
            int match_result = uv_listen_struct_inst.calls[0].match_backlog(val1, val2, "backlog", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_listen', %s",uv_listen_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_listen_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_listen_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_listen_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_listen', %s",uv_listen_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_listen_struct_inst.expectedCalls; opmock_i++) {
        uv_listen_struct_inst.calls[opmock_i - 1] = uv_listen_struct_inst.calls[opmock_i];
    }

    uv_listen_struct_inst.expectedCalls--;
    return default_res;
}

void uv_listen_MockReset()
{
    uv_listen_struct_inst.expectedCalls = 0;
    uv_listen_struct_inst.actualCalls = 0;
    uv_listen_struct_inst.callback = NULL;
}

void uv_listen_MockWithCallback(OPMOCK_uv_listen_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_listen_struct_inst.callback = callback;
    uv_listen_struct_inst.expectedCalls = 0;
    uv_listen_struct_inst.actualCalls = 0;
}

void uv_listen_VerifyMock()
{
    if (uv_listen_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_listen'",uv_listen_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_listen_ExpectAndReturn (uv_stream_t * stream, int backlog, uv_connection_cb cb, int to_return, OPMOCK_MATCHER match_stream, OPMOCK_MATCHER match_backlog, OPMOCK_MATCHER match_cb)
{
    if(uv_listen_struct_inst.callback != NULL)
    {
        uv_listen_MockReset ();
    }

    if(uv_listen_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_listen_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_listen (uv_stream_t * stream, int backlog, uv_connection_cb cb)");
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].stream = (void *)stream;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].backlog = (int)backlog;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].cb = (void *)cb;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].match_stream = match_stream;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].match_backlog = match_backlog;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].match_cb = match_cb;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_listen_struct_inst.calls[uv_listen_struct_inst.expectedCalls].check_params = 1;
    uv_listen_struct_inst.expectedCalls++;
}

int uv_accept(uv_stream_t * server, uv_stream_t * client)
{
    int default_res = (int)uv_accept_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_accept_struct_inst.actualCalls++;

    if (uv_accept_struct_inst.callback != NULL)
    {
        return uv_accept_struct_inst.callback (server, client, uv_accept_struct_inst.actualCalls);
    }
    if (uv_accept_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_accept', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_accept (uv_stream_t * server, uv_stream_t * client)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_accept(uv_stream_t * server, uv_stream_t * client)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_accept_struct_inst.calls[0].check_params == 1) {
        if(uv_accept_struct_inst.calls[0].match_server) {
            void * val1 = (void *) &uv_accept_struct_inst.calls[0].server;
            void * val2 = (void *) &server;
            int match_result = uv_accept_struct_inst.calls[0].match_server(val1, val2, "server", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_accept', %s",uv_accept_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_accept_struct_inst.calls[0].match_client) {
            void * val1 = (void *) &uv_accept_struct_inst.calls[0].client;
            void * val2 = (void *) &client;
            int match_result = uv_accept_struct_inst.calls[0].match_client(val1, val2, "client", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_accept', %s",uv_accept_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_accept_struct_inst.expectedCalls; opmock_i++) {
        uv_accept_struct_inst.calls[opmock_i - 1] = uv_accept_struct_inst.calls[opmock_i];
    }

    uv_accept_struct_inst.expectedCalls--;
    return default_res;
}

void uv_accept_MockReset()
{
    uv_accept_struct_inst.expectedCalls = 0;
    uv_accept_struct_inst.actualCalls = 0;
    uv_accept_struct_inst.callback = NULL;
}

void uv_accept_MockWithCallback(OPMOCK_uv_accept_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_accept_struct_inst.callback = callback;
    uv_accept_struct_inst.expectedCalls = 0;
    uv_accept_struct_inst.actualCalls = 0;
}

void uv_accept_VerifyMock()
{
    if (uv_accept_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_accept'",uv_accept_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_accept_ExpectAndReturn (uv_stream_t * server, uv_stream_t * client, int to_return, OPMOCK_MATCHER match_server, OPMOCK_MATCHER match_client)
{
    if(uv_accept_struct_inst.callback != NULL)
    {
        uv_accept_MockReset ();
    }

    if(uv_accept_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_accept_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_accept (uv_stream_t * server, uv_stream_t * client)");
    uv_accept_struct_inst.calls[uv_accept_struct_inst.expectedCalls].server = (void *)server;
    uv_accept_struct_inst.calls[uv_accept_struct_inst.expectedCalls].client = (void *)client;
    uv_accept_struct_inst.calls[uv_accept_struct_inst.expectedCalls].match_server = match_server;
    uv_accept_struct_inst.calls[uv_accept_struct_inst.expectedCalls].match_client = match_client;
    uv_accept_struct_inst.calls[uv_accept_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_accept_struct_inst.calls[uv_accept_struct_inst.expectedCalls].check_params = 1;
    uv_accept_struct_inst.expectedCalls++;
}

int uv_read_start(uv_stream_t * arg1, uv_alloc_cb alloc_cb, uv_read_cb read_cb)
{
    int default_res = (int)uv_read_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_read_start_struct_inst.actualCalls++;

    if (uv_read_start_struct_inst.callback != NULL)
    {
        return uv_read_start_struct_inst.callback (arg1, alloc_cb, read_cb, uv_read_start_struct_inst.actualCalls);
    }
    if (uv_read_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_read_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_read_start (uv_stream_t * arg1, uv_alloc_cb alloc_cb, uv_read_cb read_cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_read_start(uv_stream_t * arg1, uv_alloc_cb alloc_cb, uv_read_cb read_cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_read_start_struct_inst.calls[0].check_params == 1) {
        if(uv_read_start_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_read_start_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_read_start_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_read_start', %s",uv_read_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_read_start_struct_inst.calls[0].match_alloc_cb) {
            void * val1 = (void *) &uv_read_start_struct_inst.calls[0].alloc_cb;
            void * val2 = (void *) &alloc_cb;
            int match_result = uv_read_start_struct_inst.calls[0].match_alloc_cb(val1, val2, "alloc_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_read_start', %s",uv_read_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_read_start_struct_inst.calls[0].match_read_cb) {
            void * val1 = (void *) &uv_read_start_struct_inst.calls[0].read_cb;
            void * val2 = (void *) &read_cb;
            int match_result = uv_read_start_struct_inst.calls[0].match_read_cb(val1, val2, "read_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_read_start', %s",uv_read_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_read_start_struct_inst.expectedCalls; opmock_i++) {
        uv_read_start_struct_inst.calls[opmock_i - 1] = uv_read_start_struct_inst.calls[opmock_i];
    }

    uv_read_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_read_start_MockReset()
{
    uv_read_start_struct_inst.expectedCalls = 0;
    uv_read_start_struct_inst.actualCalls = 0;
    uv_read_start_struct_inst.callback = NULL;
}

void uv_read_start_MockWithCallback(OPMOCK_uv_read_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_read_start_struct_inst.callback = callback;
    uv_read_start_struct_inst.expectedCalls = 0;
    uv_read_start_struct_inst.actualCalls = 0;
}

void uv_read_start_VerifyMock()
{
    if (uv_read_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_read_start'",uv_read_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_read_start_ExpectAndReturn (uv_stream_t * arg1, uv_alloc_cb alloc_cb, uv_read_cb read_cb, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_alloc_cb, OPMOCK_MATCHER match_read_cb)
{
    if(uv_read_start_struct_inst.callback != NULL)
    {
        uv_read_start_MockReset ();
    }

    if(uv_read_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_read_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_read_start (uv_stream_t * arg1, uv_alloc_cb alloc_cb, uv_read_cb read_cb)");
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].alloc_cb = (void *)alloc_cb;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].read_cb = (void *)read_cb;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].match_alloc_cb = match_alloc_cb;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].match_read_cb = match_read_cb;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_read_start_struct_inst.calls[uv_read_start_struct_inst.expectedCalls].check_params = 1;
    uv_read_start_struct_inst.expectedCalls++;
}

int uv_read_stop(uv_stream_t * arg1)
{
    int default_res = (int)uv_read_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_read_stop_struct_inst.actualCalls++;

    if (uv_read_stop_struct_inst.callback != NULL)
    {
        return uv_read_stop_struct_inst.callback (arg1, uv_read_stop_struct_inst.actualCalls);
    }
    if (uv_read_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_read_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_read_stop (uv_stream_t * arg1)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_read_stop(uv_stream_t * arg1)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_read_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_read_stop_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_read_stop_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_read_stop_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_read_stop', %s",uv_read_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_read_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_read_stop_struct_inst.calls[opmock_i - 1] = uv_read_stop_struct_inst.calls[opmock_i];
    }

    uv_read_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_read_stop_MockReset()
{
    uv_read_stop_struct_inst.expectedCalls = 0;
    uv_read_stop_struct_inst.actualCalls = 0;
    uv_read_stop_struct_inst.callback = NULL;
}

void uv_read_stop_MockWithCallback(OPMOCK_uv_read_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_read_stop_struct_inst.callback = callback;
    uv_read_stop_struct_inst.expectedCalls = 0;
    uv_read_stop_struct_inst.actualCalls = 0;
}

void uv_read_stop_VerifyMock()
{
    if (uv_read_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_read_stop'",uv_read_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_read_stop_ExpectAndReturn (uv_stream_t * arg1, int to_return, OPMOCK_MATCHER match_arg1)
{
    if(uv_read_stop_struct_inst.callback != NULL)
    {
        uv_read_stop_MockReset ();
    }

    if(uv_read_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_read_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_read_stop (uv_stream_t * arg1)");
    uv_read_stop_struct_inst.calls[uv_read_stop_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_read_stop_struct_inst.calls[uv_read_stop_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_read_stop_struct_inst.calls[uv_read_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_read_stop_struct_inst.calls[uv_read_stop_struct_inst.expectedCalls].check_params = 1;
    uv_read_stop_struct_inst.expectedCalls++;
}

int uv_write(uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_write_cb cb)
{
    int default_res = (int)uv_write_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_write_struct_inst.actualCalls++;

    if (uv_write_struct_inst.callback != NULL)
    {
        return uv_write_struct_inst.callback (req, handle, bufs, nbufs, cb, uv_write_struct_inst.actualCalls);
    }
    if (uv_write_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_write', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_write (uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_write_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_write(uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_write_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_write_struct_inst.calls[0].check_params == 1) {
        if(uv_write_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_write_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_write_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write', %s",uv_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_write_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_write_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write', %s",uv_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_write_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_write_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write', %s",uv_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_write_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_write_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write', %s",uv_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_write_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_write_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write', %s",uv_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_write_struct_inst.expectedCalls; opmock_i++) {
        uv_write_struct_inst.calls[opmock_i - 1] = uv_write_struct_inst.calls[opmock_i];
    }

    uv_write_struct_inst.expectedCalls--;
    return default_res;
}

void uv_write_MockReset()
{
    uv_write_struct_inst.expectedCalls = 0;
    uv_write_struct_inst.actualCalls = 0;
    uv_write_struct_inst.callback = NULL;
}

void uv_write_MockWithCallback(OPMOCK_uv_write_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_write_struct_inst.callback = callback;
    uv_write_struct_inst.expectedCalls = 0;
    uv_write_struct_inst.actualCalls = 0;
}

void uv_write_VerifyMock()
{
    if (uv_write_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_write'",uv_write_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_write_ExpectAndReturn (uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_write_cb cb, int to_return, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs, OPMOCK_MATCHER match_cb)
{
    if(uv_write_struct_inst.callback != NULL)
    {
        uv_write_MockReset ();
    }

    if(uv_write_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_write_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_write (uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_write_cb cb)");
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].req = (void *)req;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].handle = (void *)handle;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].cb = (void *)cb;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].match_req = match_req;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].match_handle = match_handle;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].match_cb = match_cb;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_write_struct_inst.calls[uv_write_struct_inst.expectedCalls].check_params = 1;
    uv_write_struct_inst.expectedCalls++;
}

int uv_write2(uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_stream_t * send_handle, uv_write_cb cb)
{
    int default_res = (int)uv_write2_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_write2_struct_inst.actualCalls++;

    if (uv_write2_struct_inst.callback != NULL)
    {
        return uv_write2_struct_inst.callback (req, handle, bufs, nbufs, send_handle, cb, uv_write2_struct_inst.actualCalls);
    }
    if (uv_write2_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_write2', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_write2 (uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_stream_t * send_handle, uv_write_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_write2(uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_stream_t * send_handle, uv_write_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_write2_struct_inst.calls[0].check_params == 1) {
        if(uv_write2_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_write2_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_write2_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write2', %s",uv_write2_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write2_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_write2_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_write2_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write2', %s",uv_write2_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write2_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_write2_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_write2_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write2', %s",uv_write2_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write2_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_write2_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_write2_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write2', %s",uv_write2_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write2_struct_inst.calls[0].match_send_handle) {
            void * val1 = (void *) &uv_write2_struct_inst.calls[0].send_handle;
            void * val2 = (void *) &send_handle;
            int match_result = uv_write2_struct_inst.calls[0].match_send_handle(val1, val2, "send_handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write2', %s",uv_write2_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_write2_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_write2_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_write2_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_write2', %s",uv_write2_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_write2_struct_inst.expectedCalls; opmock_i++) {
        uv_write2_struct_inst.calls[opmock_i - 1] = uv_write2_struct_inst.calls[opmock_i];
    }

    uv_write2_struct_inst.expectedCalls--;
    return default_res;
}

void uv_write2_MockReset()
{
    uv_write2_struct_inst.expectedCalls = 0;
    uv_write2_struct_inst.actualCalls = 0;
    uv_write2_struct_inst.callback = NULL;
}

void uv_write2_MockWithCallback(OPMOCK_uv_write2_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_write2_struct_inst.callback = callback;
    uv_write2_struct_inst.expectedCalls = 0;
    uv_write2_struct_inst.actualCalls = 0;
}

void uv_write2_VerifyMock()
{
    if (uv_write2_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_write2'",uv_write2_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_write2_ExpectAndReturn (uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_stream_t * send_handle, uv_write_cb cb, int to_return, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs, OPMOCK_MATCHER match_send_handle, OPMOCK_MATCHER match_cb)
{
    if(uv_write2_struct_inst.callback != NULL)
    {
        uv_write2_MockReset ();
    }

    if(uv_write2_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_write2_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_write2 (uv_write_t * req, uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, uv_stream_t * send_handle, uv_write_cb cb)");
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].req = (void *)req;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].handle = (void *)handle;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].send_handle = (void *)send_handle;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].cb = (void *)cb;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].match_req = match_req;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].match_handle = match_handle;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].match_send_handle = match_send_handle;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].match_cb = match_cb;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_write2_struct_inst.calls[uv_write2_struct_inst.expectedCalls].check_params = 1;
    uv_write2_struct_inst.expectedCalls++;
}

int uv_try_write(uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs)
{
    int default_res = (int)uv_try_write_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_try_write_struct_inst.actualCalls++;

    if (uv_try_write_struct_inst.callback != NULL)
    {
        return uv_try_write_struct_inst.callback (handle, bufs, nbufs, uv_try_write_struct_inst.actualCalls);
    }
    if (uv_try_write_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_try_write', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_try_write (uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_try_write(uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_try_write_struct_inst.calls[0].check_params == 1) {
        if(uv_try_write_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_try_write_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_try_write_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_try_write', %s",uv_try_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_try_write_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_try_write_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_try_write_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_try_write', %s",uv_try_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_try_write_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_try_write_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_try_write_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_try_write', %s",uv_try_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_try_write_struct_inst.expectedCalls; opmock_i++) {
        uv_try_write_struct_inst.calls[opmock_i - 1] = uv_try_write_struct_inst.calls[opmock_i];
    }

    uv_try_write_struct_inst.expectedCalls--;
    return default_res;
}

void uv_try_write_MockReset()
{
    uv_try_write_struct_inst.expectedCalls = 0;
    uv_try_write_struct_inst.actualCalls = 0;
    uv_try_write_struct_inst.callback = NULL;
}

void uv_try_write_MockWithCallback(OPMOCK_uv_try_write_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_try_write_struct_inst.callback = callback;
    uv_try_write_struct_inst.expectedCalls = 0;
    uv_try_write_struct_inst.actualCalls = 0;
}

void uv_try_write_VerifyMock()
{
    if (uv_try_write_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_try_write'",uv_try_write_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_try_write_ExpectAndReturn (uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs)
{
    if(uv_try_write_struct_inst.callback != NULL)
    {
        uv_try_write_MockReset ();
    }

    if(uv_try_write_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_try_write_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_try_write (uv_stream_t * handle, const uv_buf_t  bufs [], unsigned int nbufs)");
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].handle = (void *)handle;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].match_handle = match_handle;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_try_write_struct_inst.calls[uv_try_write_struct_inst.expectedCalls].check_params = 1;
    uv_try_write_struct_inst.expectedCalls++;
}

int uv_is_readable(const uv_stream_t * handle)
{
    int default_res = (int)uv_is_readable_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_is_readable_struct_inst.actualCalls++;

    if (uv_is_readable_struct_inst.callback != NULL)
    {
        return uv_is_readable_struct_inst.callback (handle, uv_is_readable_struct_inst.actualCalls);
    }
    if (uv_is_readable_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_is_readable', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_is_readable (const uv_stream_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_is_readable(const uv_stream_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_is_readable_struct_inst.calls[0].check_params == 1) {
        if(uv_is_readable_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_is_readable_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_is_readable_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_is_readable', %s",uv_is_readable_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_is_readable_struct_inst.expectedCalls; opmock_i++) {
        uv_is_readable_struct_inst.calls[opmock_i - 1] = uv_is_readable_struct_inst.calls[opmock_i];
    }

    uv_is_readable_struct_inst.expectedCalls--;
    return default_res;
}

void uv_is_readable_MockReset()
{
    uv_is_readable_struct_inst.expectedCalls = 0;
    uv_is_readable_struct_inst.actualCalls = 0;
    uv_is_readable_struct_inst.callback = NULL;
}

void uv_is_readable_MockWithCallback(OPMOCK_uv_is_readable_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_is_readable_struct_inst.callback = callback;
    uv_is_readable_struct_inst.expectedCalls = 0;
    uv_is_readable_struct_inst.actualCalls = 0;
}

void uv_is_readable_VerifyMock()
{
    if (uv_is_readable_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_is_readable'",uv_is_readable_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_is_readable_ExpectAndReturn (const uv_stream_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_is_readable_struct_inst.callback != NULL)
    {
        uv_is_readable_MockReset ();
    }

    if(uv_is_readable_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_is_readable_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_is_readable (const uv_stream_t * handle)");
    uv_is_readable_struct_inst.calls[uv_is_readable_struct_inst.expectedCalls].handle = (void *)handle;
    uv_is_readable_struct_inst.calls[uv_is_readable_struct_inst.expectedCalls].match_handle = match_handle;
    uv_is_readable_struct_inst.calls[uv_is_readable_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_is_readable_struct_inst.calls[uv_is_readable_struct_inst.expectedCalls].check_params = 1;
    uv_is_readable_struct_inst.expectedCalls++;
}

int uv_is_writable(const uv_stream_t * handle)
{
    int default_res = (int)uv_is_writable_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_is_writable_struct_inst.actualCalls++;

    if (uv_is_writable_struct_inst.callback != NULL)
    {
        return uv_is_writable_struct_inst.callback (handle, uv_is_writable_struct_inst.actualCalls);
    }
    if (uv_is_writable_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_is_writable', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_is_writable (const uv_stream_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_is_writable(const uv_stream_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_is_writable_struct_inst.calls[0].check_params == 1) {
        if(uv_is_writable_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_is_writable_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_is_writable_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_is_writable', %s",uv_is_writable_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_is_writable_struct_inst.expectedCalls; opmock_i++) {
        uv_is_writable_struct_inst.calls[opmock_i - 1] = uv_is_writable_struct_inst.calls[opmock_i];
    }

    uv_is_writable_struct_inst.expectedCalls--;
    return default_res;
}

void uv_is_writable_MockReset()
{
    uv_is_writable_struct_inst.expectedCalls = 0;
    uv_is_writable_struct_inst.actualCalls = 0;
    uv_is_writable_struct_inst.callback = NULL;
}

void uv_is_writable_MockWithCallback(OPMOCK_uv_is_writable_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_is_writable_struct_inst.callback = callback;
    uv_is_writable_struct_inst.expectedCalls = 0;
    uv_is_writable_struct_inst.actualCalls = 0;
}

void uv_is_writable_VerifyMock()
{
    if (uv_is_writable_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_is_writable'",uv_is_writable_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_is_writable_ExpectAndReturn (const uv_stream_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_is_writable_struct_inst.callback != NULL)
    {
        uv_is_writable_MockReset ();
    }

    if(uv_is_writable_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_is_writable_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_is_writable (const uv_stream_t * handle)");
    uv_is_writable_struct_inst.calls[uv_is_writable_struct_inst.expectedCalls].handle = (void *)handle;
    uv_is_writable_struct_inst.calls[uv_is_writable_struct_inst.expectedCalls].match_handle = match_handle;
    uv_is_writable_struct_inst.calls[uv_is_writable_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_is_writable_struct_inst.calls[uv_is_writable_struct_inst.expectedCalls].check_params = 1;
    uv_is_writable_struct_inst.expectedCalls++;
}

int uv_stream_set_blocking(uv_stream_t * handle, int blocking)
{
    int default_res = (int)uv_stream_set_blocking_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_stream_set_blocking_struct_inst.actualCalls++;

    if (uv_stream_set_blocking_struct_inst.callback != NULL)
    {
        return uv_stream_set_blocking_struct_inst.callback (handle, blocking, uv_stream_set_blocking_struct_inst.actualCalls);
    }
    if (uv_stream_set_blocking_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_stream_set_blocking', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_stream_set_blocking (uv_stream_t * handle, int blocking)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_stream_set_blocking(uv_stream_t * handle, int blocking)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_stream_set_blocking_struct_inst.calls[0].check_params == 1) {
        if(uv_stream_set_blocking_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_stream_set_blocking_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_stream_set_blocking_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_stream_set_blocking', %s",uv_stream_set_blocking_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_stream_set_blocking_struct_inst.calls[0].match_blocking) {
            void * val1 = (void *) &uv_stream_set_blocking_struct_inst.calls[0].blocking;
            void * val2 = (void *) &blocking;
            int match_result = uv_stream_set_blocking_struct_inst.calls[0].match_blocking(val1, val2, "blocking", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_stream_set_blocking', %s",uv_stream_set_blocking_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_stream_set_blocking_struct_inst.expectedCalls; opmock_i++) {
        uv_stream_set_blocking_struct_inst.calls[opmock_i - 1] = uv_stream_set_blocking_struct_inst.calls[opmock_i];
    }

    uv_stream_set_blocking_struct_inst.expectedCalls--;
    return default_res;
}

void uv_stream_set_blocking_MockReset()
{
    uv_stream_set_blocking_struct_inst.expectedCalls = 0;
    uv_stream_set_blocking_struct_inst.actualCalls = 0;
    uv_stream_set_blocking_struct_inst.callback = NULL;
}

void uv_stream_set_blocking_MockWithCallback(OPMOCK_uv_stream_set_blocking_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_stream_set_blocking_struct_inst.callback = callback;
    uv_stream_set_blocking_struct_inst.expectedCalls = 0;
    uv_stream_set_blocking_struct_inst.actualCalls = 0;
}

void uv_stream_set_blocking_VerifyMock()
{
    if (uv_stream_set_blocking_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_stream_set_blocking'",uv_stream_set_blocking_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_stream_set_blocking_ExpectAndReturn (uv_stream_t * handle, int blocking, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_blocking)
{
    if(uv_stream_set_blocking_struct_inst.callback != NULL)
    {
        uv_stream_set_blocking_MockReset ();
    }

    if(uv_stream_set_blocking_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_stream_set_blocking_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_stream_set_blocking (uv_stream_t * handle, int blocking)");
    uv_stream_set_blocking_struct_inst.calls[uv_stream_set_blocking_struct_inst.expectedCalls].handle = (void *)handle;
    uv_stream_set_blocking_struct_inst.calls[uv_stream_set_blocking_struct_inst.expectedCalls].blocking = (int)blocking;
    uv_stream_set_blocking_struct_inst.calls[uv_stream_set_blocking_struct_inst.expectedCalls].match_handle = match_handle;
    uv_stream_set_blocking_struct_inst.calls[uv_stream_set_blocking_struct_inst.expectedCalls].match_blocking = match_blocking;
    uv_stream_set_blocking_struct_inst.calls[uv_stream_set_blocking_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_stream_set_blocking_struct_inst.calls[uv_stream_set_blocking_struct_inst.expectedCalls].check_params = 1;
    uv_stream_set_blocking_struct_inst.expectedCalls++;
}

int uv_is_closing(const uv_handle_t * handle)
{
    int default_res = (int)uv_is_closing_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_is_closing_struct_inst.actualCalls++;

    if (uv_is_closing_struct_inst.callback != NULL)
    {
        return uv_is_closing_struct_inst.callback (handle, uv_is_closing_struct_inst.actualCalls);
    }
    if (uv_is_closing_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_is_closing', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_is_closing (const uv_handle_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_is_closing(const uv_handle_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_is_closing_struct_inst.calls[0].check_params == 1) {
        if(uv_is_closing_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_is_closing_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_is_closing_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_is_closing', %s",uv_is_closing_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_is_closing_struct_inst.expectedCalls; opmock_i++) {
        uv_is_closing_struct_inst.calls[opmock_i - 1] = uv_is_closing_struct_inst.calls[opmock_i];
    }

    uv_is_closing_struct_inst.expectedCalls--;
    return default_res;
}

void uv_is_closing_MockReset()
{
    uv_is_closing_struct_inst.expectedCalls = 0;
    uv_is_closing_struct_inst.actualCalls = 0;
    uv_is_closing_struct_inst.callback = NULL;
}

void uv_is_closing_MockWithCallback(OPMOCK_uv_is_closing_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_is_closing_struct_inst.callback = callback;
    uv_is_closing_struct_inst.expectedCalls = 0;
    uv_is_closing_struct_inst.actualCalls = 0;
}

void uv_is_closing_VerifyMock()
{
    if (uv_is_closing_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_is_closing'",uv_is_closing_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_is_closing_ExpectAndReturn (const uv_handle_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_is_closing_struct_inst.callback != NULL)
    {
        uv_is_closing_MockReset ();
    }

    if(uv_is_closing_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_is_closing_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_is_closing (const uv_handle_t * handle)");
    uv_is_closing_struct_inst.calls[uv_is_closing_struct_inst.expectedCalls].handle = (void *)handle;
    uv_is_closing_struct_inst.calls[uv_is_closing_struct_inst.expectedCalls].match_handle = match_handle;
    uv_is_closing_struct_inst.calls[uv_is_closing_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_is_closing_struct_inst.calls[uv_is_closing_struct_inst.expectedCalls].check_params = 1;
    uv_is_closing_struct_inst.expectedCalls++;
}

int uv_tcp_init(uv_loop_t * arg1, uv_tcp_t * handle)
{
    int default_res = (int)uv_tcp_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_init_struct_inst.actualCalls++;

    if (uv_tcp_init_struct_inst.callback != NULL)
    {
        return uv_tcp_init_struct_inst.callback (arg1, handle, uv_tcp_init_struct_inst.actualCalls);
    }
    if (uv_tcp_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_init (uv_loop_t * arg1, uv_tcp_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_init(uv_loop_t * arg1, uv_tcp_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_init_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_tcp_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_tcp_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_init', %s",uv_tcp_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_init', %s",uv_tcp_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_init_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_init_struct_inst.calls[opmock_i - 1] = uv_tcp_init_struct_inst.calls[opmock_i];
    }

    uv_tcp_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_init_MockReset()
{
    uv_tcp_init_struct_inst.expectedCalls = 0;
    uv_tcp_init_struct_inst.actualCalls = 0;
    uv_tcp_init_struct_inst.callback = NULL;
}

void uv_tcp_init_MockWithCallback(OPMOCK_uv_tcp_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_init_struct_inst.callback = callback;
    uv_tcp_init_struct_inst.expectedCalls = 0;
    uv_tcp_init_struct_inst.actualCalls = 0;
}

void uv_tcp_init_VerifyMock()
{
    if (uv_tcp_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_init'",uv_tcp_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_init_ExpectAndReturn (uv_loop_t * arg1, uv_tcp_t * handle, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_handle)
{
    if(uv_tcp_init_struct_inst.callback != NULL)
    {
        uv_tcp_init_MockReset ();
    }

    if(uv_tcp_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_init (uv_loop_t * arg1, uv_tcp_t * handle)");
    uv_tcp_init_struct_inst.calls[uv_tcp_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_tcp_init_struct_inst.calls[uv_tcp_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_init_struct_inst.calls[uv_tcp_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_tcp_init_struct_inst.calls[uv_tcp_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_init_struct_inst.calls[uv_tcp_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_init_struct_inst.calls[uv_tcp_init_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_init_struct_inst.expectedCalls++;
}

int uv_tcp_open(uv_tcp_t * handle, uv_os_sock_t sock)
{
    int default_res = (int)uv_tcp_open_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_open_struct_inst.actualCalls++;

    if (uv_tcp_open_struct_inst.callback != NULL)
    {
        return uv_tcp_open_struct_inst.callback (handle, sock, uv_tcp_open_struct_inst.actualCalls);
    }
    if (uv_tcp_open_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_open', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_open (uv_tcp_t * handle, uv_os_sock_t sock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_open(uv_tcp_t * handle, uv_os_sock_t sock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_open_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_open_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_open_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_open_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_open', %s",uv_tcp_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_open_struct_inst.calls[0].match_sock) {
            void * val1 = (void *) &uv_tcp_open_struct_inst.calls[0].sock;
            void * val2 = (void *) &sock;
            int match_result = uv_tcp_open_struct_inst.calls[0].match_sock(val1, val2, "sock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_open', %s",uv_tcp_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_open_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_open_struct_inst.calls[opmock_i - 1] = uv_tcp_open_struct_inst.calls[opmock_i];
    }

    uv_tcp_open_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_open_MockReset()
{
    uv_tcp_open_struct_inst.expectedCalls = 0;
    uv_tcp_open_struct_inst.actualCalls = 0;
    uv_tcp_open_struct_inst.callback = NULL;
}

void uv_tcp_open_MockWithCallback(OPMOCK_uv_tcp_open_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_open_struct_inst.callback = callback;
    uv_tcp_open_struct_inst.expectedCalls = 0;
    uv_tcp_open_struct_inst.actualCalls = 0;
}

void uv_tcp_open_VerifyMock()
{
    if (uv_tcp_open_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_open'",uv_tcp_open_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_open_ExpectAndReturn (uv_tcp_t * handle, uv_os_sock_t sock, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_sock)
{
    if(uv_tcp_open_struct_inst.callback != NULL)
    {
        uv_tcp_open_MockReset ();
    }

    if(uv_tcp_open_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_open_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_open (uv_tcp_t * handle, uv_os_sock_t sock)");
    uv_tcp_open_struct_inst.calls[uv_tcp_open_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_open_struct_inst.calls[uv_tcp_open_struct_inst.expectedCalls].sock = (int)sock;
    uv_tcp_open_struct_inst.calls[uv_tcp_open_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_open_struct_inst.calls[uv_tcp_open_struct_inst.expectedCalls].match_sock = match_sock;
    uv_tcp_open_struct_inst.calls[uv_tcp_open_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_open_struct_inst.calls[uv_tcp_open_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_open_struct_inst.expectedCalls++;
}

int uv_tcp_nodelay(uv_tcp_t * handle, int enable)
{
    int default_res = (int)uv_tcp_nodelay_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_nodelay_struct_inst.actualCalls++;

    if (uv_tcp_nodelay_struct_inst.callback != NULL)
    {
        return uv_tcp_nodelay_struct_inst.callback (handle, enable, uv_tcp_nodelay_struct_inst.actualCalls);
    }
    if (uv_tcp_nodelay_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_nodelay', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_nodelay (uv_tcp_t * handle, int enable)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_nodelay(uv_tcp_t * handle, int enable)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_nodelay_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_nodelay_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_nodelay_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_nodelay_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_nodelay', %s",uv_tcp_nodelay_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_nodelay_struct_inst.calls[0].match_enable) {
            void * val1 = (void *) &uv_tcp_nodelay_struct_inst.calls[0].enable;
            void * val2 = (void *) &enable;
            int match_result = uv_tcp_nodelay_struct_inst.calls[0].match_enable(val1, val2, "enable", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_nodelay', %s",uv_tcp_nodelay_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_nodelay_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_nodelay_struct_inst.calls[opmock_i - 1] = uv_tcp_nodelay_struct_inst.calls[opmock_i];
    }

    uv_tcp_nodelay_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_nodelay_MockReset()
{
    uv_tcp_nodelay_struct_inst.expectedCalls = 0;
    uv_tcp_nodelay_struct_inst.actualCalls = 0;
    uv_tcp_nodelay_struct_inst.callback = NULL;
}

void uv_tcp_nodelay_MockWithCallback(OPMOCK_uv_tcp_nodelay_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_nodelay_struct_inst.callback = callback;
    uv_tcp_nodelay_struct_inst.expectedCalls = 0;
    uv_tcp_nodelay_struct_inst.actualCalls = 0;
}

void uv_tcp_nodelay_VerifyMock()
{
    if (uv_tcp_nodelay_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_nodelay'",uv_tcp_nodelay_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_nodelay_ExpectAndReturn (uv_tcp_t * handle, int enable, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_enable)
{
    if(uv_tcp_nodelay_struct_inst.callback != NULL)
    {
        uv_tcp_nodelay_MockReset ();
    }

    if(uv_tcp_nodelay_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_nodelay_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_nodelay (uv_tcp_t * handle, int enable)");
    uv_tcp_nodelay_struct_inst.calls[uv_tcp_nodelay_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_nodelay_struct_inst.calls[uv_tcp_nodelay_struct_inst.expectedCalls].enable = (int)enable;
    uv_tcp_nodelay_struct_inst.calls[uv_tcp_nodelay_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_nodelay_struct_inst.calls[uv_tcp_nodelay_struct_inst.expectedCalls].match_enable = match_enable;
    uv_tcp_nodelay_struct_inst.calls[uv_tcp_nodelay_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_nodelay_struct_inst.calls[uv_tcp_nodelay_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_nodelay_struct_inst.expectedCalls++;
}

int uv_tcp_keepalive(uv_tcp_t * handle, int enable, unsigned int delay)
{
    int default_res = (int)uv_tcp_keepalive_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_keepalive_struct_inst.actualCalls++;

    if (uv_tcp_keepalive_struct_inst.callback != NULL)
    {
        return uv_tcp_keepalive_struct_inst.callback (handle, enable, delay, uv_tcp_keepalive_struct_inst.actualCalls);
    }
    if (uv_tcp_keepalive_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_keepalive', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_keepalive (uv_tcp_t * handle, int enable, unsigned int delay)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_keepalive(uv_tcp_t * handle, int enable, unsigned int delay)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_keepalive_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_keepalive_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_keepalive_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_keepalive_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_keepalive', %s",uv_tcp_keepalive_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_keepalive_struct_inst.calls[0].match_enable) {
            void * val1 = (void *) &uv_tcp_keepalive_struct_inst.calls[0].enable;
            void * val2 = (void *) &enable;
            int match_result = uv_tcp_keepalive_struct_inst.calls[0].match_enable(val1, val2, "enable", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_keepalive', %s",uv_tcp_keepalive_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_keepalive_struct_inst.calls[0].match_delay) {
            void * val1 = (void *) &uv_tcp_keepalive_struct_inst.calls[0].delay;
            void * val2 = (void *) &delay;
            int match_result = uv_tcp_keepalive_struct_inst.calls[0].match_delay(val1, val2, "delay", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_keepalive', %s",uv_tcp_keepalive_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_keepalive_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_keepalive_struct_inst.calls[opmock_i - 1] = uv_tcp_keepalive_struct_inst.calls[opmock_i];
    }

    uv_tcp_keepalive_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_keepalive_MockReset()
{
    uv_tcp_keepalive_struct_inst.expectedCalls = 0;
    uv_tcp_keepalive_struct_inst.actualCalls = 0;
    uv_tcp_keepalive_struct_inst.callback = NULL;
}

void uv_tcp_keepalive_MockWithCallback(OPMOCK_uv_tcp_keepalive_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_keepalive_struct_inst.callback = callback;
    uv_tcp_keepalive_struct_inst.expectedCalls = 0;
    uv_tcp_keepalive_struct_inst.actualCalls = 0;
}

void uv_tcp_keepalive_VerifyMock()
{
    if (uv_tcp_keepalive_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_keepalive'",uv_tcp_keepalive_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_keepalive_ExpectAndReturn (uv_tcp_t * handle, int enable, unsigned int delay, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_enable, OPMOCK_MATCHER match_delay)
{
    if(uv_tcp_keepalive_struct_inst.callback != NULL)
    {
        uv_tcp_keepalive_MockReset ();
    }

    if(uv_tcp_keepalive_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_keepalive_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_keepalive (uv_tcp_t * handle, int enable, unsigned int delay)");
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].enable = (int)enable;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].delay = (unsigned int)delay;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].match_enable = match_enable;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].match_delay = match_delay;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_keepalive_struct_inst.calls[uv_tcp_keepalive_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_keepalive_struct_inst.expectedCalls++;
}

int uv_tcp_simultaneous_accepts(uv_tcp_t * handle, int enable)
{
    int default_res = (int)uv_tcp_simultaneous_accepts_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_simultaneous_accepts_struct_inst.actualCalls++;

    if (uv_tcp_simultaneous_accepts_struct_inst.callback != NULL)
    {
        return uv_tcp_simultaneous_accepts_struct_inst.callback (handle, enable, uv_tcp_simultaneous_accepts_struct_inst.actualCalls);
    }
    if (uv_tcp_simultaneous_accepts_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_simultaneous_accepts', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_simultaneous_accepts (uv_tcp_t * handle, int enable)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_simultaneous_accepts(uv_tcp_t * handle, int enable)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_simultaneous_accepts_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_simultaneous_accepts_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_simultaneous_accepts_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_simultaneous_accepts_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_simultaneous_accepts', %s",uv_tcp_simultaneous_accepts_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_simultaneous_accepts_struct_inst.calls[0].match_enable) {
            void * val1 = (void *) &uv_tcp_simultaneous_accepts_struct_inst.calls[0].enable;
            void * val2 = (void *) &enable;
            int match_result = uv_tcp_simultaneous_accepts_struct_inst.calls[0].match_enable(val1, val2, "enable", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_simultaneous_accepts', %s",uv_tcp_simultaneous_accepts_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_simultaneous_accepts_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_simultaneous_accepts_struct_inst.calls[opmock_i - 1] = uv_tcp_simultaneous_accepts_struct_inst.calls[opmock_i];
    }

    uv_tcp_simultaneous_accepts_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_simultaneous_accepts_MockReset()
{
    uv_tcp_simultaneous_accepts_struct_inst.expectedCalls = 0;
    uv_tcp_simultaneous_accepts_struct_inst.actualCalls = 0;
    uv_tcp_simultaneous_accepts_struct_inst.callback = NULL;
}

void uv_tcp_simultaneous_accepts_MockWithCallback(OPMOCK_uv_tcp_simultaneous_accepts_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_simultaneous_accepts_struct_inst.callback = callback;
    uv_tcp_simultaneous_accepts_struct_inst.expectedCalls = 0;
    uv_tcp_simultaneous_accepts_struct_inst.actualCalls = 0;
}

void uv_tcp_simultaneous_accepts_VerifyMock()
{
    if (uv_tcp_simultaneous_accepts_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_simultaneous_accepts'",uv_tcp_simultaneous_accepts_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_simultaneous_accepts_ExpectAndReturn (uv_tcp_t * handle, int enable, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_enable)
{
    if(uv_tcp_simultaneous_accepts_struct_inst.callback != NULL)
    {
        uv_tcp_simultaneous_accepts_MockReset ();
    }

    if(uv_tcp_simultaneous_accepts_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_simultaneous_accepts_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_simultaneous_accepts (uv_tcp_t * handle, int enable)");
    uv_tcp_simultaneous_accepts_struct_inst.calls[uv_tcp_simultaneous_accepts_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_simultaneous_accepts_struct_inst.calls[uv_tcp_simultaneous_accepts_struct_inst.expectedCalls].enable = (int)enable;
    uv_tcp_simultaneous_accepts_struct_inst.calls[uv_tcp_simultaneous_accepts_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_simultaneous_accepts_struct_inst.calls[uv_tcp_simultaneous_accepts_struct_inst.expectedCalls].match_enable = match_enable;
    uv_tcp_simultaneous_accepts_struct_inst.calls[uv_tcp_simultaneous_accepts_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_simultaneous_accepts_struct_inst.calls[uv_tcp_simultaneous_accepts_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_simultaneous_accepts_struct_inst.expectedCalls++;
}

int uv_tcp_bind(uv_tcp_t * handle, const struct sockaddr * addr, unsigned int flags)
{
    int default_res = (int)uv_tcp_bind_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_bind_struct_inst.actualCalls++;

    if (uv_tcp_bind_struct_inst.callback != NULL)
    {
        return uv_tcp_bind_struct_inst.callback (handle, addr, flags, uv_tcp_bind_struct_inst.actualCalls);
    }
    if (uv_tcp_bind_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_bind', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_bind (uv_tcp_t * handle, const struct sockaddr * addr, unsigned int flags)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_bind(uv_tcp_t * handle, const struct sockaddr * addr, unsigned int flags)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_bind_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_bind_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_bind_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_bind_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_bind', %s",uv_tcp_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_bind_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_tcp_bind_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_tcp_bind_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_bind', %s",uv_tcp_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_bind_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_tcp_bind_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_tcp_bind_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_bind', %s",uv_tcp_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_bind_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_bind_struct_inst.calls[opmock_i - 1] = uv_tcp_bind_struct_inst.calls[opmock_i];
    }

    uv_tcp_bind_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_bind_MockReset()
{
    uv_tcp_bind_struct_inst.expectedCalls = 0;
    uv_tcp_bind_struct_inst.actualCalls = 0;
    uv_tcp_bind_struct_inst.callback = NULL;
}

void uv_tcp_bind_MockWithCallback(OPMOCK_uv_tcp_bind_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_bind_struct_inst.callback = callback;
    uv_tcp_bind_struct_inst.expectedCalls = 0;
    uv_tcp_bind_struct_inst.actualCalls = 0;
}

void uv_tcp_bind_VerifyMock()
{
    if (uv_tcp_bind_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_bind'",uv_tcp_bind_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_bind_ExpectAndReturn (uv_tcp_t * handle, const struct sockaddr * addr, unsigned int flags, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_addr, OPMOCK_MATCHER match_flags)
{
    if(uv_tcp_bind_struct_inst.callback != NULL)
    {
        uv_tcp_bind_MockReset ();
    }

    if(uv_tcp_bind_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_bind_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_bind (uv_tcp_t * handle, const struct sockaddr * addr, unsigned int flags)");
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].addr = (void *)addr;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].flags = (unsigned int)flags;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].match_addr = match_addr;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].match_flags = match_flags;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_bind_struct_inst.calls[uv_tcp_bind_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_bind_struct_inst.expectedCalls++;
}

int uv_tcp_getsockname(const uv_tcp_t * handle, struct sockaddr * name, int * namelen)
{
    int default_res = (int)uv_tcp_getsockname_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_getsockname_struct_inst.actualCalls++;

    if (uv_tcp_getsockname_struct_inst.callback != NULL)
    {
        return uv_tcp_getsockname_struct_inst.callback (handle, name, namelen, uv_tcp_getsockname_struct_inst.actualCalls);
    }
    if (uv_tcp_getsockname_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_getsockname', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_getsockname (const uv_tcp_t * handle, struct sockaddr * name, int * namelen)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_getsockname(const uv_tcp_t * handle, struct sockaddr * name, int * namelen)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_getsockname_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_getsockname_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_getsockname_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_getsockname_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_getsockname', %s",uv_tcp_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_getsockname_struct_inst.calls[0].match_name) {
            void * val1 = (void *) &uv_tcp_getsockname_struct_inst.calls[0].name;
            void * val2 = (void *) &name;
            int match_result = uv_tcp_getsockname_struct_inst.calls[0].match_name(val1, val2, "name", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_getsockname', %s",uv_tcp_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_getsockname_struct_inst.calls[0].match_namelen) {
            void * val1 = (void *) &uv_tcp_getsockname_struct_inst.calls[0].namelen;
            void * val2 = (void *) &namelen;
            int match_result = uv_tcp_getsockname_struct_inst.calls[0].match_namelen(val1, val2, "namelen", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_getsockname', %s",uv_tcp_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_getsockname_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_getsockname_struct_inst.calls[opmock_i - 1] = uv_tcp_getsockname_struct_inst.calls[opmock_i];
    }

    uv_tcp_getsockname_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_getsockname_MockReset()
{
    uv_tcp_getsockname_struct_inst.expectedCalls = 0;
    uv_tcp_getsockname_struct_inst.actualCalls = 0;
    uv_tcp_getsockname_struct_inst.callback = NULL;
}

void uv_tcp_getsockname_MockWithCallback(OPMOCK_uv_tcp_getsockname_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_getsockname_struct_inst.callback = callback;
    uv_tcp_getsockname_struct_inst.expectedCalls = 0;
    uv_tcp_getsockname_struct_inst.actualCalls = 0;
}

void uv_tcp_getsockname_VerifyMock()
{
    if (uv_tcp_getsockname_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_getsockname'",uv_tcp_getsockname_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_getsockname_ExpectAndReturn (const uv_tcp_t * handle, struct sockaddr * name, int * namelen, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_name, OPMOCK_MATCHER match_namelen)
{
    if(uv_tcp_getsockname_struct_inst.callback != NULL)
    {
        uv_tcp_getsockname_MockReset ();
    }

    if(uv_tcp_getsockname_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_getsockname_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_getsockname (const uv_tcp_t * handle, struct sockaddr * name, int * namelen)");
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].name = (void *)name;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].namelen = (void *)namelen;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].match_name = match_name;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].match_namelen = match_namelen;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_getsockname_struct_inst.calls[uv_tcp_getsockname_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_getsockname_struct_inst.expectedCalls++;
}

int uv_tcp_getpeername(const uv_tcp_t * handle, struct sockaddr * name, int * namelen)
{
    int default_res = (int)uv_tcp_getpeername_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_getpeername_struct_inst.actualCalls++;

    if (uv_tcp_getpeername_struct_inst.callback != NULL)
    {
        return uv_tcp_getpeername_struct_inst.callback (handle, name, namelen, uv_tcp_getpeername_struct_inst.actualCalls);
    }
    if (uv_tcp_getpeername_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_getpeername', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_getpeername (const uv_tcp_t * handle, struct sockaddr * name, int * namelen)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_getpeername(const uv_tcp_t * handle, struct sockaddr * name, int * namelen)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_getpeername_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_getpeername_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_getpeername_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_getpeername_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_getpeername', %s",uv_tcp_getpeername_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_getpeername_struct_inst.calls[0].match_name) {
            void * val1 = (void *) &uv_tcp_getpeername_struct_inst.calls[0].name;
            void * val2 = (void *) &name;
            int match_result = uv_tcp_getpeername_struct_inst.calls[0].match_name(val1, val2, "name", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_getpeername', %s",uv_tcp_getpeername_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_getpeername_struct_inst.calls[0].match_namelen) {
            void * val1 = (void *) &uv_tcp_getpeername_struct_inst.calls[0].namelen;
            void * val2 = (void *) &namelen;
            int match_result = uv_tcp_getpeername_struct_inst.calls[0].match_namelen(val1, val2, "namelen", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_getpeername', %s",uv_tcp_getpeername_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_getpeername_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_getpeername_struct_inst.calls[opmock_i - 1] = uv_tcp_getpeername_struct_inst.calls[opmock_i];
    }

    uv_tcp_getpeername_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_getpeername_MockReset()
{
    uv_tcp_getpeername_struct_inst.expectedCalls = 0;
    uv_tcp_getpeername_struct_inst.actualCalls = 0;
    uv_tcp_getpeername_struct_inst.callback = NULL;
}

void uv_tcp_getpeername_MockWithCallback(OPMOCK_uv_tcp_getpeername_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_getpeername_struct_inst.callback = callback;
    uv_tcp_getpeername_struct_inst.expectedCalls = 0;
    uv_tcp_getpeername_struct_inst.actualCalls = 0;
}

void uv_tcp_getpeername_VerifyMock()
{
    if (uv_tcp_getpeername_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_getpeername'",uv_tcp_getpeername_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_getpeername_ExpectAndReturn (const uv_tcp_t * handle, struct sockaddr * name, int * namelen, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_name, OPMOCK_MATCHER match_namelen)
{
    if(uv_tcp_getpeername_struct_inst.callback != NULL)
    {
        uv_tcp_getpeername_MockReset ();
    }

    if(uv_tcp_getpeername_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_getpeername_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_getpeername (const uv_tcp_t * handle, struct sockaddr * name, int * namelen)");
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].name = (void *)name;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].namelen = (void *)namelen;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].match_name = match_name;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].match_namelen = match_namelen;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_getpeername_struct_inst.calls[uv_tcp_getpeername_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_getpeername_struct_inst.expectedCalls++;
}

int uv_tcp_connect(uv_connect_t * req, uv_tcp_t * handle, const struct sockaddr * addr, uv_connect_cb cb)
{
    int default_res = (int)uv_tcp_connect_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tcp_connect_struct_inst.actualCalls++;

    if (uv_tcp_connect_struct_inst.callback != NULL)
    {
        return uv_tcp_connect_struct_inst.callback (req, handle, addr, cb, uv_tcp_connect_struct_inst.actualCalls);
    }
    if (uv_tcp_connect_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tcp_connect', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tcp_connect (uv_connect_t * req, uv_tcp_t * handle, const struct sockaddr * addr, uv_connect_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tcp_connect(uv_connect_t * req, uv_tcp_t * handle, const struct sockaddr * addr, uv_connect_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tcp_connect_struct_inst.calls[0].check_params == 1) {
        if(uv_tcp_connect_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_tcp_connect_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_tcp_connect_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_connect', %s",uv_tcp_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_connect_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_tcp_connect_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_tcp_connect_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_connect', %s",uv_tcp_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_connect_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_tcp_connect_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_tcp_connect_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_connect', %s",uv_tcp_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tcp_connect_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_tcp_connect_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_tcp_connect_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tcp_connect', %s",uv_tcp_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tcp_connect_struct_inst.expectedCalls; opmock_i++) {
        uv_tcp_connect_struct_inst.calls[opmock_i - 1] = uv_tcp_connect_struct_inst.calls[opmock_i];
    }

    uv_tcp_connect_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tcp_connect_MockReset()
{
    uv_tcp_connect_struct_inst.expectedCalls = 0;
    uv_tcp_connect_struct_inst.actualCalls = 0;
    uv_tcp_connect_struct_inst.callback = NULL;
}

void uv_tcp_connect_MockWithCallback(OPMOCK_uv_tcp_connect_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tcp_connect_struct_inst.callback = callback;
    uv_tcp_connect_struct_inst.expectedCalls = 0;
    uv_tcp_connect_struct_inst.actualCalls = 0;
}

void uv_tcp_connect_VerifyMock()
{
    if (uv_tcp_connect_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tcp_connect'",uv_tcp_connect_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tcp_connect_ExpectAndReturn (uv_connect_t * req, uv_tcp_t * handle, const struct sockaddr * addr, uv_connect_cb cb, int to_return, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_addr, OPMOCK_MATCHER match_cb)
{
    if(uv_tcp_connect_struct_inst.callback != NULL)
    {
        uv_tcp_connect_MockReset ();
    }

    if(uv_tcp_connect_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tcp_connect_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tcp_connect (uv_connect_t * req, uv_tcp_t * handle, const struct sockaddr * addr, uv_connect_cb cb)");
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].req = (void *)req;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].handle = (void *)handle;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].addr = (void *)addr;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].cb = (void *)cb;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].match_req = match_req;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].match_handle = match_handle;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].match_addr = match_addr;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].match_cb = match_cb;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tcp_connect_struct_inst.calls[uv_tcp_connect_struct_inst.expectedCalls].check_params = 1;
    uv_tcp_connect_struct_inst.expectedCalls++;
}

int uv_udp_init(uv_loop_t * arg1, uv_udp_t * handle)
{
    int default_res = (int)uv_udp_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_init_struct_inst.actualCalls++;

    if (uv_udp_init_struct_inst.callback != NULL)
    {
        return uv_udp_init_struct_inst.callback (arg1, handle, uv_udp_init_struct_inst.actualCalls);
    }
    if (uv_udp_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_init (uv_loop_t * arg1, uv_udp_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_init(uv_loop_t * arg1, uv_udp_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_init_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_udp_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_udp_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_init', %s",uv_udp_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_init', %s",uv_udp_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_init_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_init_struct_inst.calls[opmock_i - 1] = uv_udp_init_struct_inst.calls[opmock_i];
    }

    uv_udp_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_init_MockReset()
{
    uv_udp_init_struct_inst.expectedCalls = 0;
    uv_udp_init_struct_inst.actualCalls = 0;
    uv_udp_init_struct_inst.callback = NULL;
}

void uv_udp_init_MockWithCallback(OPMOCK_uv_udp_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_init_struct_inst.callback = callback;
    uv_udp_init_struct_inst.expectedCalls = 0;
    uv_udp_init_struct_inst.actualCalls = 0;
}

void uv_udp_init_VerifyMock()
{
    if (uv_udp_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_init'",uv_udp_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_init_ExpectAndReturn (uv_loop_t * arg1, uv_udp_t * handle, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_handle)
{
    if(uv_udp_init_struct_inst.callback != NULL)
    {
        uv_udp_init_MockReset ();
    }

    if(uv_udp_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_init (uv_loop_t * arg1, uv_udp_t * handle)");
    uv_udp_init_struct_inst.calls[uv_udp_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_udp_init_struct_inst.calls[uv_udp_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_init_struct_inst.calls[uv_udp_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_udp_init_struct_inst.calls[uv_udp_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_init_struct_inst.calls[uv_udp_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_init_struct_inst.calls[uv_udp_init_struct_inst.expectedCalls].check_params = 1;
    uv_udp_init_struct_inst.expectedCalls++;
}

int uv_udp_open(uv_udp_t * handle, uv_os_sock_t sock)
{
    int default_res = (int)uv_udp_open_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_open_struct_inst.actualCalls++;

    if (uv_udp_open_struct_inst.callback != NULL)
    {
        return uv_udp_open_struct_inst.callback (handle, sock, uv_udp_open_struct_inst.actualCalls);
    }
    if (uv_udp_open_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_open', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_open (uv_udp_t * handle, uv_os_sock_t sock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_open(uv_udp_t * handle, uv_os_sock_t sock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_open_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_open_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_open_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_open_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_open', %s",uv_udp_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_open_struct_inst.calls[0].match_sock) {
            void * val1 = (void *) &uv_udp_open_struct_inst.calls[0].sock;
            void * val2 = (void *) &sock;
            int match_result = uv_udp_open_struct_inst.calls[0].match_sock(val1, val2, "sock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_open', %s",uv_udp_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_open_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_open_struct_inst.calls[opmock_i - 1] = uv_udp_open_struct_inst.calls[opmock_i];
    }

    uv_udp_open_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_open_MockReset()
{
    uv_udp_open_struct_inst.expectedCalls = 0;
    uv_udp_open_struct_inst.actualCalls = 0;
    uv_udp_open_struct_inst.callback = NULL;
}

void uv_udp_open_MockWithCallback(OPMOCK_uv_udp_open_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_open_struct_inst.callback = callback;
    uv_udp_open_struct_inst.expectedCalls = 0;
    uv_udp_open_struct_inst.actualCalls = 0;
}

void uv_udp_open_VerifyMock()
{
    if (uv_udp_open_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_open'",uv_udp_open_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_open_ExpectAndReturn (uv_udp_t * handle, uv_os_sock_t sock, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_sock)
{
    if(uv_udp_open_struct_inst.callback != NULL)
    {
        uv_udp_open_MockReset ();
    }

    if(uv_udp_open_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_open_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_open (uv_udp_t * handle, uv_os_sock_t sock)");
    uv_udp_open_struct_inst.calls[uv_udp_open_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_open_struct_inst.calls[uv_udp_open_struct_inst.expectedCalls].sock = (int)sock;
    uv_udp_open_struct_inst.calls[uv_udp_open_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_open_struct_inst.calls[uv_udp_open_struct_inst.expectedCalls].match_sock = match_sock;
    uv_udp_open_struct_inst.calls[uv_udp_open_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_open_struct_inst.calls[uv_udp_open_struct_inst.expectedCalls].check_params = 1;
    uv_udp_open_struct_inst.expectedCalls++;
}

int uv_udp_bind(uv_udp_t * handle, const struct sockaddr * addr, unsigned int flags)
{
    int default_res = (int)uv_udp_bind_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_bind_struct_inst.actualCalls++;

    if (uv_udp_bind_struct_inst.callback != NULL)
    {
        return uv_udp_bind_struct_inst.callback (handle, addr, flags, uv_udp_bind_struct_inst.actualCalls);
    }
    if (uv_udp_bind_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_bind', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_bind (uv_udp_t * handle, const struct sockaddr * addr, unsigned int flags)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_bind(uv_udp_t * handle, const struct sockaddr * addr, unsigned int flags)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_bind_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_bind_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_bind_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_bind_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_bind', %s",uv_udp_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_bind_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_udp_bind_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_udp_bind_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_bind', %s",uv_udp_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_bind_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_udp_bind_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_udp_bind_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_bind', %s",uv_udp_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_bind_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_bind_struct_inst.calls[opmock_i - 1] = uv_udp_bind_struct_inst.calls[opmock_i];
    }

    uv_udp_bind_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_bind_MockReset()
{
    uv_udp_bind_struct_inst.expectedCalls = 0;
    uv_udp_bind_struct_inst.actualCalls = 0;
    uv_udp_bind_struct_inst.callback = NULL;
}

void uv_udp_bind_MockWithCallback(OPMOCK_uv_udp_bind_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_bind_struct_inst.callback = callback;
    uv_udp_bind_struct_inst.expectedCalls = 0;
    uv_udp_bind_struct_inst.actualCalls = 0;
}

void uv_udp_bind_VerifyMock()
{
    if (uv_udp_bind_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_bind'",uv_udp_bind_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_bind_ExpectAndReturn (uv_udp_t * handle, const struct sockaddr * addr, unsigned int flags, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_addr, OPMOCK_MATCHER match_flags)
{
    if(uv_udp_bind_struct_inst.callback != NULL)
    {
        uv_udp_bind_MockReset ();
    }

    if(uv_udp_bind_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_bind_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_bind (uv_udp_t * handle, const struct sockaddr * addr, unsigned int flags)");
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].addr = (void *)addr;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].flags = (unsigned int)flags;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].match_addr = match_addr;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].match_flags = match_flags;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_bind_struct_inst.calls[uv_udp_bind_struct_inst.expectedCalls].check_params = 1;
    uv_udp_bind_struct_inst.expectedCalls++;
}

int uv_udp_getsockname(const uv_udp_t * handle, struct sockaddr * name, int * namelen)
{
    int default_res = (int)uv_udp_getsockname_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_getsockname_struct_inst.actualCalls++;

    if (uv_udp_getsockname_struct_inst.callback != NULL)
    {
        return uv_udp_getsockname_struct_inst.callback (handle, name, namelen, uv_udp_getsockname_struct_inst.actualCalls);
    }
    if (uv_udp_getsockname_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_getsockname', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_getsockname (const uv_udp_t * handle, struct sockaddr * name, int * namelen)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_getsockname(const uv_udp_t * handle, struct sockaddr * name, int * namelen)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_getsockname_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_getsockname_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_getsockname_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_getsockname_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_getsockname', %s",uv_udp_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_getsockname_struct_inst.calls[0].match_name) {
            void * val1 = (void *) &uv_udp_getsockname_struct_inst.calls[0].name;
            void * val2 = (void *) &name;
            int match_result = uv_udp_getsockname_struct_inst.calls[0].match_name(val1, val2, "name", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_getsockname', %s",uv_udp_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_getsockname_struct_inst.calls[0].match_namelen) {
            void * val1 = (void *) &uv_udp_getsockname_struct_inst.calls[0].namelen;
            void * val2 = (void *) &namelen;
            int match_result = uv_udp_getsockname_struct_inst.calls[0].match_namelen(val1, val2, "namelen", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_getsockname', %s",uv_udp_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_getsockname_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_getsockname_struct_inst.calls[opmock_i - 1] = uv_udp_getsockname_struct_inst.calls[opmock_i];
    }

    uv_udp_getsockname_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_getsockname_MockReset()
{
    uv_udp_getsockname_struct_inst.expectedCalls = 0;
    uv_udp_getsockname_struct_inst.actualCalls = 0;
    uv_udp_getsockname_struct_inst.callback = NULL;
}

void uv_udp_getsockname_MockWithCallback(OPMOCK_uv_udp_getsockname_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_getsockname_struct_inst.callback = callback;
    uv_udp_getsockname_struct_inst.expectedCalls = 0;
    uv_udp_getsockname_struct_inst.actualCalls = 0;
}

void uv_udp_getsockname_VerifyMock()
{
    if (uv_udp_getsockname_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_getsockname'",uv_udp_getsockname_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_getsockname_ExpectAndReturn (const uv_udp_t * handle, struct sockaddr * name, int * namelen, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_name, OPMOCK_MATCHER match_namelen)
{
    if(uv_udp_getsockname_struct_inst.callback != NULL)
    {
        uv_udp_getsockname_MockReset ();
    }

    if(uv_udp_getsockname_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_getsockname_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_getsockname (const uv_udp_t * handle, struct sockaddr * name, int * namelen)");
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].name = (void *)name;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].namelen = (void *)namelen;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].match_name = match_name;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].match_namelen = match_namelen;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_getsockname_struct_inst.calls[uv_udp_getsockname_struct_inst.expectedCalls].check_params = 1;
    uv_udp_getsockname_struct_inst.expectedCalls++;
}

int uv_udp_set_membership(uv_udp_t * handle, const char * multicast_addr, const char * interface_addr, uv_membership membership)
{
    int default_res = (int)uv_udp_set_membership_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_set_membership_struct_inst.actualCalls++;

    if (uv_udp_set_membership_struct_inst.callback != NULL)
    {
        return uv_udp_set_membership_struct_inst.callback (handle, multicast_addr, interface_addr, membership, uv_udp_set_membership_struct_inst.actualCalls);
    }
    if (uv_udp_set_membership_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_set_membership', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_set_membership (uv_udp_t * handle, const char * multicast_addr, const char * interface_addr, uv_membership membership)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_set_membership(uv_udp_t * handle, const char * multicast_addr, const char * interface_addr, uv_membership membership)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_set_membership_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_set_membership_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_set_membership_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_set_membership_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_membership', %s",uv_udp_set_membership_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_membership_struct_inst.calls[0].match_multicast_addr) {
            void * val1 = (void *) &uv_udp_set_membership_struct_inst.calls[0].multicast_addr;
            void * val2 = (void *) &multicast_addr;
            int match_result = uv_udp_set_membership_struct_inst.calls[0].match_multicast_addr(val1, val2, "multicast_addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_membership', %s",uv_udp_set_membership_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_membership_struct_inst.calls[0].match_interface_addr) {
            void * val1 = (void *) &uv_udp_set_membership_struct_inst.calls[0].interface_addr;
            void * val2 = (void *) &interface_addr;
            int match_result = uv_udp_set_membership_struct_inst.calls[0].match_interface_addr(val1, val2, "interface_addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_membership', %s",uv_udp_set_membership_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_membership_struct_inst.calls[0].match_membership) {
            void * val1 = (void *) &uv_udp_set_membership_struct_inst.calls[0].membership;
            void * val2 = (void *) &membership;
            int match_result = uv_udp_set_membership_struct_inst.calls[0].match_membership(val1, val2, "membership", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_membership', %s",uv_udp_set_membership_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_set_membership_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_set_membership_struct_inst.calls[opmock_i - 1] = uv_udp_set_membership_struct_inst.calls[opmock_i];
    }

    uv_udp_set_membership_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_set_membership_MockReset()
{
    uv_udp_set_membership_struct_inst.expectedCalls = 0;
    uv_udp_set_membership_struct_inst.actualCalls = 0;
    uv_udp_set_membership_struct_inst.callback = NULL;
}

void uv_udp_set_membership_MockWithCallback(OPMOCK_uv_udp_set_membership_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_set_membership_struct_inst.callback = callback;
    uv_udp_set_membership_struct_inst.expectedCalls = 0;
    uv_udp_set_membership_struct_inst.actualCalls = 0;
}

void uv_udp_set_membership_VerifyMock()
{
    if (uv_udp_set_membership_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_set_membership'",uv_udp_set_membership_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_set_membership_ExpectAndReturn (uv_udp_t * handle, const char * multicast_addr, const char * interface_addr, uv_membership membership, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_multicast_addr, OPMOCK_MATCHER match_interface_addr, OPMOCK_MATCHER match_membership)
{
    if(uv_udp_set_membership_struct_inst.callback != NULL)
    {
        uv_udp_set_membership_MockReset ();
    }

    if(uv_udp_set_membership_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_set_membership_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_set_membership (uv_udp_t * handle, const char * multicast_addr, const char * interface_addr, uv_membership membership)");
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].multicast_addr = (void *)multicast_addr;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].interface_addr = (void *)interface_addr;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].membership = (uv_membership)membership;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].match_multicast_addr = match_multicast_addr;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].match_interface_addr = match_interface_addr;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].match_membership = match_membership;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_set_membership_struct_inst.calls[uv_udp_set_membership_struct_inst.expectedCalls].check_params = 1;
    uv_udp_set_membership_struct_inst.expectedCalls++;
}

int uv_udp_set_multicast_loop(uv_udp_t * handle, int on)
{
    int default_res = (int)uv_udp_set_multicast_loop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_set_multicast_loop_struct_inst.actualCalls++;

    if (uv_udp_set_multicast_loop_struct_inst.callback != NULL)
    {
        return uv_udp_set_multicast_loop_struct_inst.callback (handle, on, uv_udp_set_multicast_loop_struct_inst.actualCalls);
    }
    if (uv_udp_set_multicast_loop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_set_multicast_loop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_set_multicast_loop (uv_udp_t * handle, int on)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_set_multicast_loop(uv_udp_t * handle, int on)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_set_multicast_loop_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_set_multicast_loop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_set_multicast_loop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_set_multicast_loop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_multicast_loop', %s",uv_udp_set_multicast_loop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_multicast_loop_struct_inst.calls[0].match_on) {
            void * val1 = (void *) &uv_udp_set_multicast_loop_struct_inst.calls[0].on;
            void * val2 = (void *) &on;
            int match_result = uv_udp_set_multicast_loop_struct_inst.calls[0].match_on(val1, val2, "on", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_multicast_loop', %s",uv_udp_set_multicast_loop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_set_multicast_loop_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_set_multicast_loop_struct_inst.calls[opmock_i - 1] = uv_udp_set_multicast_loop_struct_inst.calls[opmock_i];
    }

    uv_udp_set_multicast_loop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_set_multicast_loop_MockReset()
{
    uv_udp_set_multicast_loop_struct_inst.expectedCalls = 0;
    uv_udp_set_multicast_loop_struct_inst.actualCalls = 0;
    uv_udp_set_multicast_loop_struct_inst.callback = NULL;
}

void uv_udp_set_multicast_loop_MockWithCallback(OPMOCK_uv_udp_set_multicast_loop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_set_multicast_loop_struct_inst.callback = callback;
    uv_udp_set_multicast_loop_struct_inst.expectedCalls = 0;
    uv_udp_set_multicast_loop_struct_inst.actualCalls = 0;
}

void uv_udp_set_multicast_loop_VerifyMock()
{
    if (uv_udp_set_multicast_loop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_set_multicast_loop'",uv_udp_set_multicast_loop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_set_multicast_loop_ExpectAndReturn (uv_udp_t * handle, int on, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_on)
{
    if(uv_udp_set_multicast_loop_struct_inst.callback != NULL)
    {
        uv_udp_set_multicast_loop_MockReset ();
    }

    if(uv_udp_set_multicast_loop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_set_multicast_loop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_set_multicast_loop (uv_udp_t * handle, int on)");
    uv_udp_set_multicast_loop_struct_inst.calls[uv_udp_set_multicast_loop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_set_multicast_loop_struct_inst.calls[uv_udp_set_multicast_loop_struct_inst.expectedCalls].on = (int)on;
    uv_udp_set_multicast_loop_struct_inst.calls[uv_udp_set_multicast_loop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_set_multicast_loop_struct_inst.calls[uv_udp_set_multicast_loop_struct_inst.expectedCalls].match_on = match_on;
    uv_udp_set_multicast_loop_struct_inst.calls[uv_udp_set_multicast_loop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_set_multicast_loop_struct_inst.calls[uv_udp_set_multicast_loop_struct_inst.expectedCalls].check_params = 1;
    uv_udp_set_multicast_loop_struct_inst.expectedCalls++;
}

int uv_udp_set_multicast_ttl(uv_udp_t * handle, int ttl)
{
    int default_res = (int)uv_udp_set_multicast_ttl_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_set_multicast_ttl_struct_inst.actualCalls++;

    if (uv_udp_set_multicast_ttl_struct_inst.callback != NULL)
    {
        return uv_udp_set_multicast_ttl_struct_inst.callback (handle, ttl, uv_udp_set_multicast_ttl_struct_inst.actualCalls);
    }
    if (uv_udp_set_multicast_ttl_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_set_multicast_ttl', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_set_multicast_ttl (uv_udp_t * handle, int ttl)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_set_multicast_ttl(uv_udp_t * handle, int ttl)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_set_multicast_ttl_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_set_multicast_ttl_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_set_multicast_ttl_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_set_multicast_ttl_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_multicast_ttl', %s",uv_udp_set_multicast_ttl_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_multicast_ttl_struct_inst.calls[0].match_ttl) {
            void * val1 = (void *) &uv_udp_set_multicast_ttl_struct_inst.calls[0].ttl;
            void * val2 = (void *) &ttl;
            int match_result = uv_udp_set_multicast_ttl_struct_inst.calls[0].match_ttl(val1, val2, "ttl", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_multicast_ttl', %s",uv_udp_set_multicast_ttl_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_set_multicast_ttl_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_set_multicast_ttl_struct_inst.calls[opmock_i - 1] = uv_udp_set_multicast_ttl_struct_inst.calls[opmock_i];
    }

    uv_udp_set_multicast_ttl_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_set_multicast_ttl_MockReset()
{
    uv_udp_set_multicast_ttl_struct_inst.expectedCalls = 0;
    uv_udp_set_multicast_ttl_struct_inst.actualCalls = 0;
    uv_udp_set_multicast_ttl_struct_inst.callback = NULL;
}

void uv_udp_set_multicast_ttl_MockWithCallback(OPMOCK_uv_udp_set_multicast_ttl_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_set_multicast_ttl_struct_inst.callback = callback;
    uv_udp_set_multicast_ttl_struct_inst.expectedCalls = 0;
    uv_udp_set_multicast_ttl_struct_inst.actualCalls = 0;
}

void uv_udp_set_multicast_ttl_VerifyMock()
{
    if (uv_udp_set_multicast_ttl_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_set_multicast_ttl'",uv_udp_set_multicast_ttl_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_set_multicast_ttl_ExpectAndReturn (uv_udp_t * handle, int ttl, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_ttl)
{
    if(uv_udp_set_multicast_ttl_struct_inst.callback != NULL)
    {
        uv_udp_set_multicast_ttl_MockReset ();
    }

    if(uv_udp_set_multicast_ttl_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_set_multicast_ttl_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_set_multicast_ttl (uv_udp_t * handle, int ttl)");
    uv_udp_set_multicast_ttl_struct_inst.calls[uv_udp_set_multicast_ttl_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_set_multicast_ttl_struct_inst.calls[uv_udp_set_multicast_ttl_struct_inst.expectedCalls].ttl = (int)ttl;
    uv_udp_set_multicast_ttl_struct_inst.calls[uv_udp_set_multicast_ttl_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_set_multicast_ttl_struct_inst.calls[uv_udp_set_multicast_ttl_struct_inst.expectedCalls].match_ttl = match_ttl;
    uv_udp_set_multicast_ttl_struct_inst.calls[uv_udp_set_multicast_ttl_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_set_multicast_ttl_struct_inst.calls[uv_udp_set_multicast_ttl_struct_inst.expectedCalls].check_params = 1;
    uv_udp_set_multicast_ttl_struct_inst.expectedCalls++;
}

int uv_udp_set_multicast_interface(uv_udp_t * handle, const char * interface_addr)
{
    int default_res = (int)uv_udp_set_multicast_interface_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_set_multicast_interface_struct_inst.actualCalls++;

    if (uv_udp_set_multicast_interface_struct_inst.callback != NULL)
    {
        return uv_udp_set_multicast_interface_struct_inst.callback (handle, interface_addr, uv_udp_set_multicast_interface_struct_inst.actualCalls);
    }
    if (uv_udp_set_multicast_interface_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_set_multicast_interface', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_set_multicast_interface (uv_udp_t * handle, const char * interface_addr)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_set_multicast_interface(uv_udp_t * handle, const char * interface_addr)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_set_multicast_interface_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_set_multicast_interface_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_set_multicast_interface_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_set_multicast_interface_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_multicast_interface', %s",uv_udp_set_multicast_interface_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_multicast_interface_struct_inst.calls[0].match_interface_addr) {
            void * val1 = (void *) &uv_udp_set_multicast_interface_struct_inst.calls[0].interface_addr;
            void * val2 = (void *) &interface_addr;
            int match_result = uv_udp_set_multicast_interface_struct_inst.calls[0].match_interface_addr(val1, val2, "interface_addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_multicast_interface', %s",uv_udp_set_multicast_interface_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_set_multicast_interface_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_set_multicast_interface_struct_inst.calls[opmock_i - 1] = uv_udp_set_multicast_interface_struct_inst.calls[opmock_i];
    }

    uv_udp_set_multicast_interface_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_set_multicast_interface_MockReset()
{
    uv_udp_set_multicast_interface_struct_inst.expectedCalls = 0;
    uv_udp_set_multicast_interface_struct_inst.actualCalls = 0;
    uv_udp_set_multicast_interface_struct_inst.callback = NULL;
}

void uv_udp_set_multicast_interface_MockWithCallback(OPMOCK_uv_udp_set_multicast_interface_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_set_multicast_interface_struct_inst.callback = callback;
    uv_udp_set_multicast_interface_struct_inst.expectedCalls = 0;
    uv_udp_set_multicast_interface_struct_inst.actualCalls = 0;
}

void uv_udp_set_multicast_interface_VerifyMock()
{
    if (uv_udp_set_multicast_interface_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_set_multicast_interface'",uv_udp_set_multicast_interface_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_set_multicast_interface_ExpectAndReturn (uv_udp_t * handle, const char * interface_addr, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_interface_addr)
{
    if(uv_udp_set_multicast_interface_struct_inst.callback != NULL)
    {
        uv_udp_set_multicast_interface_MockReset ();
    }

    if(uv_udp_set_multicast_interface_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_set_multicast_interface_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_set_multicast_interface (uv_udp_t * handle, const char * interface_addr)");
    uv_udp_set_multicast_interface_struct_inst.calls[uv_udp_set_multicast_interface_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_set_multicast_interface_struct_inst.calls[uv_udp_set_multicast_interface_struct_inst.expectedCalls].interface_addr = (void *)interface_addr;
    uv_udp_set_multicast_interface_struct_inst.calls[uv_udp_set_multicast_interface_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_set_multicast_interface_struct_inst.calls[uv_udp_set_multicast_interface_struct_inst.expectedCalls].match_interface_addr = match_interface_addr;
    uv_udp_set_multicast_interface_struct_inst.calls[uv_udp_set_multicast_interface_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_set_multicast_interface_struct_inst.calls[uv_udp_set_multicast_interface_struct_inst.expectedCalls].check_params = 1;
    uv_udp_set_multicast_interface_struct_inst.expectedCalls++;
}

int uv_udp_set_broadcast(uv_udp_t * handle, int on)
{
    int default_res = (int)uv_udp_set_broadcast_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_set_broadcast_struct_inst.actualCalls++;

    if (uv_udp_set_broadcast_struct_inst.callback != NULL)
    {
        return uv_udp_set_broadcast_struct_inst.callback (handle, on, uv_udp_set_broadcast_struct_inst.actualCalls);
    }
    if (uv_udp_set_broadcast_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_set_broadcast', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_set_broadcast (uv_udp_t * handle, int on)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_set_broadcast(uv_udp_t * handle, int on)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_set_broadcast_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_set_broadcast_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_set_broadcast_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_set_broadcast_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_broadcast', %s",uv_udp_set_broadcast_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_broadcast_struct_inst.calls[0].match_on) {
            void * val1 = (void *) &uv_udp_set_broadcast_struct_inst.calls[0].on;
            void * val2 = (void *) &on;
            int match_result = uv_udp_set_broadcast_struct_inst.calls[0].match_on(val1, val2, "on", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_broadcast', %s",uv_udp_set_broadcast_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_set_broadcast_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_set_broadcast_struct_inst.calls[opmock_i - 1] = uv_udp_set_broadcast_struct_inst.calls[opmock_i];
    }

    uv_udp_set_broadcast_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_set_broadcast_MockReset()
{
    uv_udp_set_broadcast_struct_inst.expectedCalls = 0;
    uv_udp_set_broadcast_struct_inst.actualCalls = 0;
    uv_udp_set_broadcast_struct_inst.callback = NULL;
}

void uv_udp_set_broadcast_MockWithCallback(OPMOCK_uv_udp_set_broadcast_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_set_broadcast_struct_inst.callback = callback;
    uv_udp_set_broadcast_struct_inst.expectedCalls = 0;
    uv_udp_set_broadcast_struct_inst.actualCalls = 0;
}

void uv_udp_set_broadcast_VerifyMock()
{
    if (uv_udp_set_broadcast_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_set_broadcast'",uv_udp_set_broadcast_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_set_broadcast_ExpectAndReturn (uv_udp_t * handle, int on, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_on)
{
    if(uv_udp_set_broadcast_struct_inst.callback != NULL)
    {
        uv_udp_set_broadcast_MockReset ();
    }

    if(uv_udp_set_broadcast_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_set_broadcast_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_set_broadcast (uv_udp_t * handle, int on)");
    uv_udp_set_broadcast_struct_inst.calls[uv_udp_set_broadcast_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_set_broadcast_struct_inst.calls[uv_udp_set_broadcast_struct_inst.expectedCalls].on = (int)on;
    uv_udp_set_broadcast_struct_inst.calls[uv_udp_set_broadcast_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_set_broadcast_struct_inst.calls[uv_udp_set_broadcast_struct_inst.expectedCalls].match_on = match_on;
    uv_udp_set_broadcast_struct_inst.calls[uv_udp_set_broadcast_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_set_broadcast_struct_inst.calls[uv_udp_set_broadcast_struct_inst.expectedCalls].check_params = 1;
    uv_udp_set_broadcast_struct_inst.expectedCalls++;
}

int uv_udp_set_ttl(uv_udp_t * handle, int ttl)
{
    int default_res = (int)uv_udp_set_ttl_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_set_ttl_struct_inst.actualCalls++;

    if (uv_udp_set_ttl_struct_inst.callback != NULL)
    {
        return uv_udp_set_ttl_struct_inst.callback (handle, ttl, uv_udp_set_ttl_struct_inst.actualCalls);
    }
    if (uv_udp_set_ttl_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_set_ttl', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_set_ttl (uv_udp_t * handle, int ttl)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_set_ttl(uv_udp_t * handle, int ttl)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_set_ttl_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_set_ttl_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_set_ttl_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_set_ttl_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_ttl', %s",uv_udp_set_ttl_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_set_ttl_struct_inst.calls[0].match_ttl) {
            void * val1 = (void *) &uv_udp_set_ttl_struct_inst.calls[0].ttl;
            void * val2 = (void *) &ttl;
            int match_result = uv_udp_set_ttl_struct_inst.calls[0].match_ttl(val1, val2, "ttl", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_set_ttl', %s",uv_udp_set_ttl_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_set_ttl_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_set_ttl_struct_inst.calls[opmock_i - 1] = uv_udp_set_ttl_struct_inst.calls[opmock_i];
    }

    uv_udp_set_ttl_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_set_ttl_MockReset()
{
    uv_udp_set_ttl_struct_inst.expectedCalls = 0;
    uv_udp_set_ttl_struct_inst.actualCalls = 0;
    uv_udp_set_ttl_struct_inst.callback = NULL;
}

void uv_udp_set_ttl_MockWithCallback(OPMOCK_uv_udp_set_ttl_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_set_ttl_struct_inst.callback = callback;
    uv_udp_set_ttl_struct_inst.expectedCalls = 0;
    uv_udp_set_ttl_struct_inst.actualCalls = 0;
}

void uv_udp_set_ttl_VerifyMock()
{
    if (uv_udp_set_ttl_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_set_ttl'",uv_udp_set_ttl_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_set_ttl_ExpectAndReturn (uv_udp_t * handle, int ttl, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_ttl)
{
    if(uv_udp_set_ttl_struct_inst.callback != NULL)
    {
        uv_udp_set_ttl_MockReset ();
    }

    if(uv_udp_set_ttl_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_set_ttl_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_set_ttl (uv_udp_t * handle, int ttl)");
    uv_udp_set_ttl_struct_inst.calls[uv_udp_set_ttl_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_set_ttl_struct_inst.calls[uv_udp_set_ttl_struct_inst.expectedCalls].ttl = (int)ttl;
    uv_udp_set_ttl_struct_inst.calls[uv_udp_set_ttl_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_set_ttl_struct_inst.calls[uv_udp_set_ttl_struct_inst.expectedCalls].match_ttl = match_ttl;
    uv_udp_set_ttl_struct_inst.calls[uv_udp_set_ttl_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_set_ttl_struct_inst.calls[uv_udp_set_ttl_struct_inst.expectedCalls].check_params = 1;
    uv_udp_set_ttl_struct_inst.expectedCalls++;
}

int uv_udp_send(uv_udp_send_t * req, uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr, uv_udp_send_cb send_cb)
{
    int default_res = (int)uv_udp_send_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_send_struct_inst.actualCalls++;

    if (uv_udp_send_struct_inst.callback != NULL)
    {
        return uv_udp_send_struct_inst.callback (req, handle, bufs, nbufs, addr, send_cb, uv_udp_send_struct_inst.actualCalls);
    }
    if (uv_udp_send_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_send', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_send (uv_udp_send_t * req, uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr, uv_udp_send_cb send_cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_send(uv_udp_send_t * req, uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr, uv_udp_send_cb send_cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_send_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_send_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_udp_send_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_udp_send_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_send', %s",uv_udp_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_send_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_send_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_send_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_send', %s",uv_udp_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_send_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_udp_send_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_udp_send_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_send', %s",uv_udp_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_send_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_udp_send_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_udp_send_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_send', %s",uv_udp_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_send_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_udp_send_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_udp_send_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_send', %s",uv_udp_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_send_struct_inst.calls[0].match_send_cb) {
            void * val1 = (void *) &uv_udp_send_struct_inst.calls[0].send_cb;
            void * val2 = (void *) &send_cb;
            int match_result = uv_udp_send_struct_inst.calls[0].match_send_cb(val1, val2, "send_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_send', %s",uv_udp_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_send_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_send_struct_inst.calls[opmock_i - 1] = uv_udp_send_struct_inst.calls[opmock_i];
    }

    uv_udp_send_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_send_MockReset()
{
    uv_udp_send_struct_inst.expectedCalls = 0;
    uv_udp_send_struct_inst.actualCalls = 0;
    uv_udp_send_struct_inst.callback = NULL;
}

void uv_udp_send_MockWithCallback(OPMOCK_uv_udp_send_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_send_struct_inst.callback = callback;
    uv_udp_send_struct_inst.expectedCalls = 0;
    uv_udp_send_struct_inst.actualCalls = 0;
}

void uv_udp_send_VerifyMock()
{
    if (uv_udp_send_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_send'",uv_udp_send_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_send_ExpectAndReturn (uv_udp_send_t * req, uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr, uv_udp_send_cb send_cb, int to_return, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs, OPMOCK_MATCHER match_addr, OPMOCK_MATCHER match_send_cb)
{
    if(uv_udp_send_struct_inst.callback != NULL)
    {
        uv_udp_send_MockReset ();
    }

    if(uv_udp_send_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_send_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_send (uv_udp_send_t * req, uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr, uv_udp_send_cb send_cb)");
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].req = (void *)req;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].addr = (void *)addr;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].send_cb = (void *)send_cb;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].match_req = match_req;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].match_addr = match_addr;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].match_send_cb = match_send_cb;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_send_struct_inst.calls[uv_udp_send_struct_inst.expectedCalls].check_params = 1;
    uv_udp_send_struct_inst.expectedCalls++;
}

int uv_udp_try_send(uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr)
{
    int default_res = (int)uv_udp_try_send_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_try_send_struct_inst.actualCalls++;

    if (uv_udp_try_send_struct_inst.callback != NULL)
    {
        return uv_udp_try_send_struct_inst.callback (handle, bufs, nbufs, addr, uv_udp_try_send_struct_inst.actualCalls);
    }
    if (uv_udp_try_send_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_try_send', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_try_send (uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_try_send(uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_try_send_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_try_send_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_try_send_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_try_send_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_try_send', %s",uv_udp_try_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_try_send_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_udp_try_send_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_udp_try_send_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_try_send', %s",uv_udp_try_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_try_send_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_udp_try_send_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_udp_try_send_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_try_send', %s",uv_udp_try_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_try_send_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_udp_try_send_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_udp_try_send_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_try_send', %s",uv_udp_try_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_try_send_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_try_send_struct_inst.calls[opmock_i - 1] = uv_udp_try_send_struct_inst.calls[opmock_i];
    }

    uv_udp_try_send_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_try_send_MockReset()
{
    uv_udp_try_send_struct_inst.expectedCalls = 0;
    uv_udp_try_send_struct_inst.actualCalls = 0;
    uv_udp_try_send_struct_inst.callback = NULL;
}

void uv_udp_try_send_MockWithCallback(OPMOCK_uv_udp_try_send_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_try_send_struct_inst.callback = callback;
    uv_udp_try_send_struct_inst.expectedCalls = 0;
    uv_udp_try_send_struct_inst.actualCalls = 0;
}

void uv_udp_try_send_VerifyMock()
{
    if (uv_udp_try_send_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_try_send'",uv_udp_try_send_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_try_send_ExpectAndReturn (uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs, OPMOCK_MATCHER match_addr)
{
    if(uv_udp_try_send_struct_inst.callback != NULL)
    {
        uv_udp_try_send_MockReset ();
    }

    if(uv_udp_try_send_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_try_send_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_try_send (uv_udp_t * handle, const uv_buf_t  bufs [], unsigned int nbufs, const struct sockaddr * addr)");
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].addr = (void *)addr;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].match_addr = match_addr;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_try_send_struct_inst.calls[uv_udp_try_send_struct_inst.expectedCalls].check_params = 1;
    uv_udp_try_send_struct_inst.expectedCalls++;
}

int uv_udp_recv_start(uv_udp_t * handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb)
{
    int default_res = (int)uv_udp_recv_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_recv_start_struct_inst.actualCalls++;

    if (uv_udp_recv_start_struct_inst.callback != NULL)
    {
        return uv_udp_recv_start_struct_inst.callback (handle, alloc_cb, recv_cb, uv_udp_recv_start_struct_inst.actualCalls);
    }
    if (uv_udp_recv_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_recv_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_recv_start (uv_udp_t * handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_recv_start(uv_udp_t * handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_recv_start_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_recv_start_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_recv_start_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_recv_start_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_recv_start', %s",uv_udp_recv_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_recv_start_struct_inst.calls[0].match_alloc_cb) {
            void * val1 = (void *) &uv_udp_recv_start_struct_inst.calls[0].alloc_cb;
            void * val2 = (void *) &alloc_cb;
            int match_result = uv_udp_recv_start_struct_inst.calls[0].match_alloc_cb(val1, val2, "alloc_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_recv_start', %s",uv_udp_recv_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_udp_recv_start_struct_inst.calls[0].match_recv_cb) {
            void * val1 = (void *) &uv_udp_recv_start_struct_inst.calls[0].recv_cb;
            void * val2 = (void *) &recv_cb;
            int match_result = uv_udp_recv_start_struct_inst.calls[0].match_recv_cb(val1, val2, "recv_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_recv_start', %s",uv_udp_recv_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_recv_start_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_recv_start_struct_inst.calls[opmock_i - 1] = uv_udp_recv_start_struct_inst.calls[opmock_i];
    }

    uv_udp_recv_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_recv_start_MockReset()
{
    uv_udp_recv_start_struct_inst.expectedCalls = 0;
    uv_udp_recv_start_struct_inst.actualCalls = 0;
    uv_udp_recv_start_struct_inst.callback = NULL;
}

void uv_udp_recv_start_MockWithCallback(OPMOCK_uv_udp_recv_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_recv_start_struct_inst.callback = callback;
    uv_udp_recv_start_struct_inst.expectedCalls = 0;
    uv_udp_recv_start_struct_inst.actualCalls = 0;
}

void uv_udp_recv_start_VerifyMock()
{
    if (uv_udp_recv_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_recv_start'",uv_udp_recv_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_recv_start_ExpectAndReturn (uv_udp_t * handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_alloc_cb, OPMOCK_MATCHER match_recv_cb)
{
    if(uv_udp_recv_start_struct_inst.callback != NULL)
    {
        uv_udp_recv_start_MockReset ();
    }

    if(uv_udp_recv_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_recv_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_recv_start (uv_udp_t * handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb)");
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].alloc_cb = (void *)alloc_cb;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].recv_cb = (void *)recv_cb;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].match_alloc_cb = match_alloc_cb;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].match_recv_cb = match_recv_cb;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_recv_start_struct_inst.calls[uv_udp_recv_start_struct_inst.expectedCalls].check_params = 1;
    uv_udp_recv_start_struct_inst.expectedCalls++;
}

int uv_udp_recv_stop(uv_udp_t * handle)
{
    int default_res = (int)uv_udp_recv_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_udp_recv_stop_struct_inst.actualCalls++;

    if (uv_udp_recv_stop_struct_inst.callback != NULL)
    {
        return uv_udp_recv_stop_struct_inst.callback (handle, uv_udp_recv_stop_struct_inst.actualCalls);
    }
    if (uv_udp_recv_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_udp_recv_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_udp_recv_stop (uv_udp_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_udp_recv_stop(uv_udp_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_udp_recv_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_udp_recv_stop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_udp_recv_stop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_udp_recv_stop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_udp_recv_stop', %s",uv_udp_recv_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_udp_recv_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_udp_recv_stop_struct_inst.calls[opmock_i - 1] = uv_udp_recv_stop_struct_inst.calls[opmock_i];
    }

    uv_udp_recv_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_udp_recv_stop_MockReset()
{
    uv_udp_recv_stop_struct_inst.expectedCalls = 0;
    uv_udp_recv_stop_struct_inst.actualCalls = 0;
    uv_udp_recv_stop_struct_inst.callback = NULL;
}

void uv_udp_recv_stop_MockWithCallback(OPMOCK_uv_udp_recv_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_udp_recv_stop_struct_inst.callback = callback;
    uv_udp_recv_stop_struct_inst.expectedCalls = 0;
    uv_udp_recv_stop_struct_inst.actualCalls = 0;
}

void uv_udp_recv_stop_VerifyMock()
{
    if (uv_udp_recv_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_udp_recv_stop'",uv_udp_recv_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_udp_recv_stop_ExpectAndReturn (uv_udp_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_udp_recv_stop_struct_inst.callback != NULL)
    {
        uv_udp_recv_stop_MockReset ();
    }

    if(uv_udp_recv_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_udp_recv_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_udp_recv_stop (uv_udp_t * handle)");
    uv_udp_recv_stop_struct_inst.calls[uv_udp_recv_stop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_udp_recv_stop_struct_inst.calls[uv_udp_recv_stop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_udp_recv_stop_struct_inst.calls[uv_udp_recv_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_udp_recv_stop_struct_inst.calls[uv_udp_recv_stop_struct_inst.expectedCalls].check_params = 1;
    uv_udp_recv_stop_struct_inst.expectedCalls++;
}

int uv_tty_init(uv_loop_t * arg1, uv_tty_t * arg2, uv_file fd, int readable)
{
    int default_res = (int)uv_tty_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tty_init_struct_inst.actualCalls++;

    if (uv_tty_init_struct_inst.callback != NULL)
    {
        return uv_tty_init_struct_inst.callback (arg1, arg2, fd, readable, uv_tty_init_struct_inst.actualCalls);
    }
    if (uv_tty_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tty_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tty_init (uv_loop_t * arg1, uv_tty_t * arg2, uv_file fd, int readable)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tty_init(uv_loop_t * arg1, uv_tty_t * arg2, uv_file fd, int readable)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tty_init_struct_inst.calls[0].check_params == 1) {
        if(uv_tty_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_tty_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_tty_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_init', %s",uv_tty_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tty_init_struct_inst.calls[0].match_arg2) {
            void * val1 = (void *) &uv_tty_init_struct_inst.calls[0].arg2;
            void * val2 = (void *) &arg2;
            int match_result = uv_tty_init_struct_inst.calls[0].match_arg2(val1, val2, "arg2", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_init', %s",uv_tty_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tty_init_struct_inst.calls[0].match_fd) {
            void * val1 = (void *) &uv_tty_init_struct_inst.calls[0].fd;
            void * val2 = (void *) &fd;
            int match_result = uv_tty_init_struct_inst.calls[0].match_fd(val1, val2, "fd", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_init', %s",uv_tty_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tty_init_struct_inst.calls[0].match_readable) {
            void * val1 = (void *) &uv_tty_init_struct_inst.calls[0].readable;
            void * val2 = (void *) &readable;
            int match_result = uv_tty_init_struct_inst.calls[0].match_readable(val1, val2, "readable", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_init', %s",uv_tty_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tty_init_struct_inst.expectedCalls; opmock_i++) {
        uv_tty_init_struct_inst.calls[opmock_i - 1] = uv_tty_init_struct_inst.calls[opmock_i];
    }

    uv_tty_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tty_init_MockReset()
{
    uv_tty_init_struct_inst.expectedCalls = 0;
    uv_tty_init_struct_inst.actualCalls = 0;
    uv_tty_init_struct_inst.callback = NULL;
}

void uv_tty_init_MockWithCallback(OPMOCK_uv_tty_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tty_init_struct_inst.callback = callback;
    uv_tty_init_struct_inst.expectedCalls = 0;
    uv_tty_init_struct_inst.actualCalls = 0;
}

void uv_tty_init_VerifyMock()
{
    if (uv_tty_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tty_init'",uv_tty_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tty_init_ExpectAndReturn (uv_loop_t * arg1, uv_tty_t * arg2, uv_file fd, int readable, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_arg2, OPMOCK_MATCHER match_fd, OPMOCK_MATCHER match_readable)
{
    if(uv_tty_init_struct_inst.callback != NULL)
    {
        uv_tty_init_MockReset ();
    }

    if(uv_tty_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tty_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tty_init (uv_loop_t * arg1, uv_tty_t * arg2, uv_file fd, int readable)");
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].arg2 = (void *)arg2;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].fd = (int)fd;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].readable = (int)readable;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].match_arg2 = match_arg2;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].match_fd = match_fd;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].match_readable = match_readable;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tty_init_struct_inst.calls[uv_tty_init_struct_inst.expectedCalls].check_params = 1;
    uv_tty_init_struct_inst.expectedCalls++;
}

int uv_tty_set_mode(uv_tty_t * arg1, int mode)
{
    int default_res = (int)uv_tty_set_mode_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tty_set_mode_struct_inst.actualCalls++;

    if (uv_tty_set_mode_struct_inst.callback != NULL)
    {
        return uv_tty_set_mode_struct_inst.callback (arg1, mode, uv_tty_set_mode_struct_inst.actualCalls);
    }
    if (uv_tty_set_mode_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tty_set_mode', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tty_set_mode (uv_tty_t * arg1, int mode)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tty_set_mode(uv_tty_t * arg1, int mode)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tty_set_mode_struct_inst.calls[0].check_params == 1) {
        if(uv_tty_set_mode_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_tty_set_mode_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_tty_set_mode_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_set_mode', %s",uv_tty_set_mode_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tty_set_mode_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_tty_set_mode_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_tty_set_mode_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_set_mode', %s",uv_tty_set_mode_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tty_set_mode_struct_inst.expectedCalls; opmock_i++) {
        uv_tty_set_mode_struct_inst.calls[opmock_i - 1] = uv_tty_set_mode_struct_inst.calls[opmock_i];
    }

    uv_tty_set_mode_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tty_set_mode_MockReset()
{
    uv_tty_set_mode_struct_inst.expectedCalls = 0;
    uv_tty_set_mode_struct_inst.actualCalls = 0;
    uv_tty_set_mode_struct_inst.callback = NULL;
}

void uv_tty_set_mode_MockWithCallback(OPMOCK_uv_tty_set_mode_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tty_set_mode_struct_inst.callback = callback;
    uv_tty_set_mode_struct_inst.expectedCalls = 0;
    uv_tty_set_mode_struct_inst.actualCalls = 0;
}

void uv_tty_set_mode_VerifyMock()
{
    if (uv_tty_set_mode_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tty_set_mode'",uv_tty_set_mode_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tty_set_mode_ExpectAndReturn (uv_tty_t * arg1, int mode, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_mode)
{
    if(uv_tty_set_mode_struct_inst.callback != NULL)
    {
        uv_tty_set_mode_MockReset ();
    }

    if(uv_tty_set_mode_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tty_set_mode_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tty_set_mode (uv_tty_t * arg1, int mode)");
    uv_tty_set_mode_struct_inst.calls[uv_tty_set_mode_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_tty_set_mode_struct_inst.calls[uv_tty_set_mode_struct_inst.expectedCalls].mode = (int)mode;
    uv_tty_set_mode_struct_inst.calls[uv_tty_set_mode_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_tty_set_mode_struct_inst.calls[uv_tty_set_mode_struct_inst.expectedCalls].match_mode = match_mode;
    uv_tty_set_mode_struct_inst.calls[uv_tty_set_mode_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tty_set_mode_struct_inst.calls[uv_tty_set_mode_struct_inst.expectedCalls].check_params = 1;
    uv_tty_set_mode_struct_inst.expectedCalls++;
}

int uv_tty_reset_mode()
{
    int default_res = (int)uv_tty_reset_mode_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tty_reset_mode_struct_inst.actualCalls++;

    if (uv_tty_reset_mode_struct_inst.callback != NULL)
    {
        return uv_tty_reset_mode_struct_inst.callback (uv_tty_reset_mode_struct_inst.actualCalls);
    }
    if (uv_tty_reset_mode_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tty_reset_mode', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tty_reset_mode ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tty_reset_mode()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tty_reset_mode_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_tty_reset_mode_struct_inst.expectedCalls; opmock_i++) {
        uv_tty_reset_mode_struct_inst.calls[opmock_i - 1] = uv_tty_reset_mode_struct_inst.calls[opmock_i];
    }

    uv_tty_reset_mode_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tty_reset_mode_MockReset()
{
    uv_tty_reset_mode_struct_inst.expectedCalls = 0;
    uv_tty_reset_mode_struct_inst.actualCalls = 0;
    uv_tty_reset_mode_struct_inst.callback = NULL;
}

void uv_tty_reset_mode_MockWithCallback(OPMOCK_uv_tty_reset_mode_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tty_reset_mode_struct_inst.callback = callback;
    uv_tty_reset_mode_struct_inst.expectedCalls = 0;
    uv_tty_reset_mode_struct_inst.actualCalls = 0;
}

void uv_tty_reset_mode_VerifyMock()
{
    if (uv_tty_reset_mode_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tty_reset_mode'",uv_tty_reset_mode_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tty_reset_mode_ExpectAndReturn (int to_return)
{
    if(uv_tty_reset_mode_struct_inst.callback != NULL)
    {
        uv_tty_reset_mode_MockReset ();
    }

    if(uv_tty_reset_mode_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tty_reset_mode_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tty_reset_mode ()");
    uv_tty_reset_mode_struct_inst.calls[uv_tty_reset_mode_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tty_reset_mode_struct_inst.calls[uv_tty_reset_mode_struct_inst.expectedCalls].check_params = 1;
    uv_tty_reset_mode_struct_inst.expectedCalls++;
}

int uv_tty_get_winsize(uv_tty_t * arg1, int * width, int * height)
{
    int default_res = (int)uv_tty_get_winsize_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_tty_get_winsize_struct_inst.actualCalls++;

    if (uv_tty_get_winsize_struct_inst.callback != NULL)
    {
        return uv_tty_get_winsize_struct_inst.callback (arg1, width, height, uv_tty_get_winsize_struct_inst.actualCalls);
    }
    if (uv_tty_get_winsize_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_tty_get_winsize', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_tty_get_winsize (uv_tty_t * arg1, int * width, int * height)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_tty_get_winsize(uv_tty_t * arg1, int * width, int * height)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_tty_get_winsize_struct_inst.calls[0].check_params == 1) {
        if(uv_tty_get_winsize_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_tty_get_winsize_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_tty_get_winsize_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_get_winsize', %s",uv_tty_get_winsize_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tty_get_winsize_struct_inst.calls[0].match_width) {
            void * val1 = (void *) &uv_tty_get_winsize_struct_inst.calls[0].width;
            void * val2 = (void *) &width;
            int match_result = uv_tty_get_winsize_struct_inst.calls[0].match_width(val1, val2, "width", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_get_winsize', %s",uv_tty_get_winsize_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_tty_get_winsize_struct_inst.calls[0].match_height) {
            void * val1 = (void *) &uv_tty_get_winsize_struct_inst.calls[0].height;
            void * val2 = (void *) &height;
            int match_result = uv_tty_get_winsize_struct_inst.calls[0].match_height(val1, val2, "height", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_tty_get_winsize', %s",uv_tty_get_winsize_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_tty_get_winsize_struct_inst.expectedCalls; opmock_i++) {
        uv_tty_get_winsize_struct_inst.calls[opmock_i - 1] = uv_tty_get_winsize_struct_inst.calls[opmock_i];
    }

    uv_tty_get_winsize_struct_inst.expectedCalls--;
    return default_res;
}

void uv_tty_get_winsize_MockReset()
{
    uv_tty_get_winsize_struct_inst.expectedCalls = 0;
    uv_tty_get_winsize_struct_inst.actualCalls = 0;
    uv_tty_get_winsize_struct_inst.callback = NULL;
}

void uv_tty_get_winsize_MockWithCallback(OPMOCK_uv_tty_get_winsize_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_tty_get_winsize_struct_inst.callback = callback;
    uv_tty_get_winsize_struct_inst.expectedCalls = 0;
    uv_tty_get_winsize_struct_inst.actualCalls = 0;
}

void uv_tty_get_winsize_VerifyMock()
{
    if (uv_tty_get_winsize_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_tty_get_winsize'",uv_tty_get_winsize_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_tty_get_winsize_ExpectAndReturn (uv_tty_t * arg1, int * width, int * height, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_width, OPMOCK_MATCHER match_height)
{
    if(uv_tty_get_winsize_struct_inst.callback != NULL)
    {
        uv_tty_get_winsize_MockReset ();
    }

    if(uv_tty_get_winsize_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_tty_get_winsize_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_tty_get_winsize (uv_tty_t * arg1, int * width, int * height)");
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].width = (void *)width;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].height = (void *)height;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].match_width = match_width;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].match_height = match_height;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_tty_get_winsize_struct_inst.calls[uv_tty_get_winsize_struct_inst.expectedCalls].check_params = 1;
    uv_tty_get_winsize_struct_inst.expectedCalls++;
}

uv_handle_type uv_guess_handle(uv_file file)
{
    uv_handle_type default_res = (uv_handle_type)uv_guess_handle_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_guess_handle_struct_inst.actualCalls++;

    if (uv_guess_handle_struct_inst.callback != NULL)
    {
        return uv_guess_handle_struct_inst.callback (file, uv_guess_handle_struct_inst.actualCalls);
    }
    if (uv_guess_handle_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_guess_handle', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uv_handle_type uv_guess_handle (uv_file file)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uv_handle_type uv_guess_handle(uv_file file)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_guess_handle_struct_inst.calls[0].check_params == 1) {
        if(uv_guess_handle_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_guess_handle_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_guess_handle_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_guess_handle', %s",uv_guess_handle_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_guess_handle_struct_inst.expectedCalls; opmock_i++) {
        uv_guess_handle_struct_inst.calls[opmock_i - 1] = uv_guess_handle_struct_inst.calls[opmock_i];
    }

    uv_guess_handle_struct_inst.expectedCalls--;
    return default_res;
}

void uv_guess_handle_MockReset()
{
    uv_guess_handle_struct_inst.expectedCalls = 0;
    uv_guess_handle_struct_inst.actualCalls = 0;
    uv_guess_handle_struct_inst.callback = NULL;
}

void uv_guess_handle_MockWithCallback(OPMOCK_uv_guess_handle_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_guess_handle_struct_inst.callback = callback;
    uv_guess_handle_struct_inst.expectedCalls = 0;
    uv_guess_handle_struct_inst.actualCalls = 0;
}

void uv_guess_handle_VerifyMock()
{
    if (uv_guess_handle_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_guess_handle'",uv_guess_handle_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_guess_handle_ExpectAndReturn (uv_file file, uv_handle_type to_return, OPMOCK_MATCHER match_file)
{
    if(uv_guess_handle_struct_inst.callback != NULL)
    {
        uv_guess_handle_MockReset ();
    }

    if(uv_guess_handle_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_guess_handle_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uv_handle_type uv_guess_handle (uv_file file)");
    uv_guess_handle_struct_inst.calls[uv_guess_handle_struct_inst.expectedCalls].file = (int)file;
    uv_guess_handle_struct_inst.calls[uv_guess_handle_struct_inst.expectedCalls].match_file = match_file;
    uv_guess_handle_struct_inst.calls[uv_guess_handle_struct_inst.expectedCalls].to_return = (uv_handle_type) to_return;
    uv_guess_handle_struct_inst.calls[uv_guess_handle_struct_inst.expectedCalls].check_params = 1;
    uv_guess_handle_struct_inst.expectedCalls++;
}

int uv_pipe_init(uv_loop_t * arg1, uv_pipe_t * handle, int ipc)
{
    int default_res = (int)uv_pipe_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_pipe_init_struct_inst.actualCalls++;

    if (uv_pipe_init_struct_inst.callback != NULL)
    {
        return uv_pipe_init_struct_inst.callback (arg1, handle, ipc, uv_pipe_init_struct_inst.actualCalls);
    }
    if (uv_pipe_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_pipe_init (uv_loop_t * arg1, uv_pipe_t * handle, int ipc)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_pipe_init(uv_loop_t * arg1, uv_pipe_t * handle, int ipc)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_init_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_pipe_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_pipe_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_init', %s",uv_pipe_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_init', %s",uv_pipe_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_init_struct_inst.calls[0].match_ipc) {
            void * val1 = (void *) &uv_pipe_init_struct_inst.calls[0].ipc;
            void * val2 = (void *) &ipc;
            int match_result = uv_pipe_init_struct_inst.calls[0].match_ipc(val1, val2, "ipc", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_init', %s",uv_pipe_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_init_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_init_struct_inst.calls[opmock_i - 1] = uv_pipe_init_struct_inst.calls[opmock_i];
    }

    uv_pipe_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_pipe_init_MockReset()
{
    uv_pipe_init_struct_inst.expectedCalls = 0;
    uv_pipe_init_struct_inst.actualCalls = 0;
    uv_pipe_init_struct_inst.callback = NULL;
}

void uv_pipe_init_MockWithCallback(OPMOCK_uv_pipe_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_init_struct_inst.callback = callback;
    uv_pipe_init_struct_inst.expectedCalls = 0;
    uv_pipe_init_struct_inst.actualCalls = 0;
}

void uv_pipe_init_VerifyMock()
{
    if (uv_pipe_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_init'",uv_pipe_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_init_ExpectAndReturn (uv_loop_t * arg1, uv_pipe_t * handle, int ipc, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_ipc)
{
    if(uv_pipe_init_struct_inst.callback != NULL)
    {
        uv_pipe_init_MockReset ();
    }

    if(uv_pipe_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_pipe_init (uv_loop_t * arg1, uv_pipe_t * handle, int ipc)");
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].ipc = (int)ipc;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].match_ipc = match_ipc;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_pipe_init_struct_inst.calls[uv_pipe_init_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_init_struct_inst.expectedCalls++;
}

int uv_pipe_open(uv_pipe_t * arg1, uv_file file)
{
    int default_res = (int)uv_pipe_open_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_pipe_open_struct_inst.actualCalls++;

    if (uv_pipe_open_struct_inst.callback != NULL)
    {
        return uv_pipe_open_struct_inst.callback (arg1, file, uv_pipe_open_struct_inst.actualCalls);
    }
    if (uv_pipe_open_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_open', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_pipe_open (uv_pipe_t * arg1, uv_file file)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_pipe_open(uv_pipe_t * arg1, uv_file file)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_open_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_open_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_pipe_open_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_pipe_open_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_open', %s",uv_pipe_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_open_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_pipe_open_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_pipe_open_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_open', %s",uv_pipe_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_open_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_open_struct_inst.calls[opmock_i - 1] = uv_pipe_open_struct_inst.calls[opmock_i];
    }

    uv_pipe_open_struct_inst.expectedCalls--;
    return default_res;
}

void uv_pipe_open_MockReset()
{
    uv_pipe_open_struct_inst.expectedCalls = 0;
    uv_pipe_open_struct_inst.actualCalls = 0;
    uv_pipe_open_struct_inst.callback = NULL;
}

void uv_pipe_open_MockWithCallback(OPMOCK_uv_pipe_open_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_open_struct_inst.callback = callback;
    uv_pipe_open_struct_inst.expectedCalls = 0;
    uv_pipe_open_struct_inst.actualCalls = 0;
}

void uv_pipe_open_VerifyMock()
{
    if (uv_pipe_open_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_open'",uv_pipe_open_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_open_ExpectAndReturn (uv_pipe_t * arg1, uv_file file, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_file)
{
    if(uv_pipe_open_struct_inst.callback != NULL)
    {
        uv_pipe_open_MockReset ();
    }

    if(uv_pipe_open_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_open_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_pipe_open (uv_pipe_t * arg1, uv_file file)");
    uv_pipe_open_struct_inst.calls[uv_pipe_open_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_pipe_open_struct_inst.calls[uv_pipe_open_struct_inst.expectedCalls].file = (int)file;
    uv_pipe_open_struct_inst.calls[uv_pipe_open_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_pipe_open_struct_inst.calls[uv_pipe_open_struct_inst.expectedCalls].match_file = match_file;
    uv_pipe_open_struct_inst.calls[uv_pipe_open_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_pipe_open_struct_inst.calls[uv_pipe_open_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_open_struct_inst.expectedCalls++;
}

int uv_pipe_bind(uv_pipe_t * handle, const char * name)
{
    int default_res = (int)uv_pipe_bind_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_pipe_bind_struct_inst.actualCalls++;

    if (uv_pipe_bind_struct_inst.callback != NULL)
    {
        return uv_pipe_bind_struct_inst.callback (handle, name, uv_pipe_bind_struct_inst.actualCalls);
    }
    if (uv_pipe_bind_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_bind', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_pipe_bind (uv_pipe_t * handle, const char * name)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_pipe_bind(uv_pipe_t * handle, const char * name)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_bind_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_bind_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_bind_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_bind_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_bind', %s",uv_pipe_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_bind_struct_inst.calls[0].match_name) {
            void * val1 = (void *) &uv_pipe_bind_struct_inst.calls[0].name;
            void * val2 = (void *) &name;
            int match_result = uv_pipe_bind_struct_inst.calls[0].match_name(val1, val2, "name", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_bind', %s",uv_pipe_bind_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_bind_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_bind_struct_inst.calls[opmock_i - 1] = uv_pipe_bind_struct_inst.calls[opmock_i];
    }

    uv_pipe_bind_struct_inst.expectedCalls--;
    return default_res;
}

void uv_pipe_bind_MockReset()
{
    uv_pipe_bind_struct_inst.expectedCalls = 0;
    uv_pipe_bind_struct_inst.actualCalls = 0;
    uv_pipe_bind_struct_inst.callback = NULL;
}

void uv_pipe_bind_MockWithCallback(OPMOCK_uv_pipe_bind_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_bind_struct_inst.callback = callback;
    uv_pipe_bind_struct_inst.expectedCalls = 0;
    uv_pipe_bind_struct_inst.actualCalls = 0;
}

void uv_pipe_bind_VerifyMock()
{
    if (uv_pipe_bind_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_bind'",uv_pipe_bind_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_bind_ExpectAndReturn (uv_pipe_t * handle, const char * name, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_name)
{
    if(uv_pipe_bind_struct_inst.callback != NULL)
    {
        uv_pipe_bind_MockReset ();
    }

    if(uv_pipe_bind_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_bind_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_pipe_bind (uv_pipe_t * handle, const char * name)");
    uv_pipe_bind_struct_inst.calls[uv_pipe_bind_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_bind_struct_inst.calls[uv_pipe_bind_struct_inst.expectedCalls].name = (void *)name;
    uv_pipe_bind_struct_inst.calls[uv_pipe_bind_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_bind_struct_inst.calls[uv_pipe_bind_struct_inst.expectedCalls].match_name = match_name;
    uv_pipe_bind_struct_inst.calls[uv_pipe_bind_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_pipe_bind_struct_inst.calls[uv_pipe_bind_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_bind_struct_inst.expectedCalls++;
}

void uv_pipe_connect(uv_connect_t * req, uv_pipe_t * handle, const char * name, uv_connect_cb cb)
{
    int opmock_i;
    uv_pipe_connect_struct_inst.actualCalls++;

    if (uv_pipe_connect_struct_inst.callback != NULL)
    {
        uv_pipe_connect_struct_inst.callback (req, handle, name, cb, uv_pipe_connect_struct_inst.actualCalls);
        return;
    }
    if (uv_pipe_connect_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_connect', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_pipe_connect (uv_connect_t * req, uv_pipe_t * handle, const char * name, uv_connect_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_pipe_connect(uv_connect_t * req, uv_pipe_t * handle, const char * name, uv_connect_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_connect_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_connect_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_pipe_connect_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_pipe_connect_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_connect', %s",uv_pipe_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_connect_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_connect_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_connect_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_connect', %s",uv_pipe_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_connect_struct_inst.calls[0].match_name) {
            void * val1 = (void *) &uv_pipe_connect_struct_inst.calls[0].name;
            void * val2 = (void *) &name;
            int match_result = uv_pipe_connect_struct_inst.calls[0].match_name(val1, val2, "name", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_connect', %s",uv_pipe_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_connect_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_pipe_connect_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_pipe_connect_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_connect', %s",uv_pipe_connect_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_connect_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_connect_struct_inst.calls[opmock_i - 1] = uv_pipe_connect_struct_inst.calls[opmock_i];
    }

    uv_pipe_connect_struct_inst.expectedCalls--;
}

void uv_pipe_connect_MockReset()
{
    uv_pipe_connect_struct_inst.expectedCalls = 0;
    uv_pipe_connect_struct_inst.actualCalls = 0;
    uv_pipe_connect_struct_inst.callback = NULL;
}

void uv_pipe_connect_MockWithCallback(OPMOCK_uv_pipe_connect_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_connect_struct_inst.callback = callback;
    uv_pipe_connect_struct_inst.expectedCalls = 0;
    uv_pipe_connect_struct_inst.actualCalls = 0;
}

void uv_pipe_connect_VerifyMock()
{
    if (uv_pipe_connect_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_connect'",uv_pipe_connect_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_connect_ExpectAndReturn (uv_connect_t * req, uv_pipe_t * handle, const char * name, uv_connect_cb cb, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_name, OPMOCK_MATCHER match_cb)
{
    if(uv_pipe_connect_struct_inst.callback != NULL)
    {
        uv_pipe_connect_MockReset ();
    }

    if(uv_pipe_connect_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_connect_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_pipe_connect (uv_connect_t * req, uv_pipe_t * handle, const char * name, uv_connect_cb cb)");
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].req = (void *)req;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].name = (void *)name;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].cb = (void *)cb;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].match_req = match_req;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].match_name = match_name;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].match_cb = match_cb;
    uv_pipe_connect_struct_inst.calls[uv_pipe_connect_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_connect_struct_inst.expectedCalls++;
}

int uv_pipe_getsockname(const uv_pipe_t * handle, char * buf, size_t * len)
{
    int default_res = (int)uv_pipe_getsockname_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_pipe_getsockname_struct_inst.actualCalls++;

    if (uv_pipe_getsockname_struct_inst.callback != NULL)
    {
        return uv_pipe_getsockname_struct_inst.callback (handle, buf, len, uv_pipe_getsockname_struct_inst.actualCalls);
    }
    if (uv_pipe_getsockname_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_getsockname', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_pipe_getsockname (const uv_pipe_t * handle, char * buf, size_t * len)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_pipe_getsockname(const uv_pipe_t * handle, char * buf, size_t * len)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_getsockname_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_getsockname_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_getsockname_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_getsockname_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_getsockname', %s",uv_pipe_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_getsockname_struct_inst.calls[0].match_buf) {
            void * val1 = (void *) &uv_pipe_getsockname_struct_inst.calls[0].buf;
            void * val2 = (void *) &buf;
            int match_result = uv_pipe_getsockname_struct_inst.calls[0].match_buf(val1, val2, "buf", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_getsockname', %s",uv_pipe_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_getsockname_struct_inst.calls[0].match_len) {
            void * val1 = (void *) &uv_pipe_getsockname_struct_inst.calls[0].len;
            void * val2 = (void *) &len;
            int match_result = uv_pipe_getsockname_struct_inst.calls[0].match_len(val1, val2, "len", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_getsockname', %s",uv_pipe_getsockname_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_getsockname_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_getsockname_struct_inst.calls[opmock_i - 1] = uv_pipe_getsockname_struct_inst.calls[opmock_i];
    }

    uv_pipe_getsockname_struct_inst.expectedCalls--;
    return default_res;
}

void uv_pipe_getsockname_MockReset()
{
    uv_pipe_getsockname_struct_inst.expectedCalls = 0;
    uv_pipe_getsockname_struct_inst.actualCalls = 0;
    uv_pipe_getsockname_struct_inst.callback = NULL;
}

void uv_pipe_getsockname_MockWithCallback(OPMOCK_uv_pipe_getsockname_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_getsockname_struct_inst.callback = callback;
    uv_pipe_getsockname_struct_inst.expectedCalls = 0;
    uv_pipe_getsockname_struct_inst.actualCalls = 0;
}

void uv_pipe_getsockname_VerifyMock()
{
    if (uv_pipe_getsockname_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_getsockname'",uv_pipe_getsockname_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_getsockname_ExpectAndReturn (const uv_pipe_t * handle, char * buf, size_t * len, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_buf, OPMOCK_MATCHER match_len)
{
    if(uv_pipe_getsockname_struct_inst.callback != NULL)
    {
        uv_pipe_getsockname_MockReset ();
    }

    if(uv_pipe_getsockname_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_getsockname_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_pipe_getsockname (const uv_pipe_t * handle, char * buf, size_t * len)");
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].buf = (void *)buf;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].len = (void *)len;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].match_buf = match_buf;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].match_len = match_len;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_pipe_getsockname_struct_inst.calls[uv_pipe_getsockname_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_getsockname_struct_inst.expectedCalls++;
}

void uv_pipe_pending_instances(uv_pipe_t * handle, int count)
{
    int opmock_i;
    uv_pipe_pending_instances_struct_inst.actualCalls++;

    if (uv_pipe_pending_instances_struct_inst.callback != NULL)
    {
        uv_pipe_pending_instances_struct_inst.callback (handle, count, uv_pipe_pending_instances_struct_inst.actualCalls);
        return;
    }
    if (uv_pipe_pending_instances_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_pending_instances', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_pipe_pending_instances (uv_pipe_t * handle, int count)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_pipe_pending_instances(uv_pipe_t * handle, int count)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_pending_instances_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_pending_instances_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_pending_instances_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_pending_instances_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_pending_instances', %s",uv_pipe_pending_instances_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_pipe_pending_instances_struct_inst.calls[0].match_count) {
            void * val1 = (void *) &uv_pipe_pending_instances_struct_inst.calls[0].count;
            void * val2 = (void *) &count;
            int match_result = uv_pipe_pending_instances_struct_inst.calls[0].match_count(val1, val2, "count", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_pending_instances', %s",uv_pipe_pending_instances_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_pending_instances_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_pending_instances_struct_inst.calls[opmock_i - 1] = uv_pipe_pending_instances_struct_inst.calls[opmock_i];
    }

    uv_pipe_pending_instances_struct_inst.expectedCalls--;
}

void uv_pipe_pending_instances_MockReset()
{
    uv_pipe_pending_instances_struct_inst.expectedCalls = 0;
    uv_pipe_pending_instances_struct_inst.actualCalls = 0;
    uv_pipe_pending_instances_struct_inst.callback = NULL;
}

void uv_pipe_pending_instances_MockWithCallback(OPMOCK_uv_pipe_pending_instances_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_pending_instances_struct_inst.callback = callback;
    uv_pipe_pending_instances_struct_inst.expectedCalls = 0;
    uv_pipe_pending_instances_struct_inst.actualCalls = 0;
}

void uv_pipe_pending_instances_VerifyMock()
{
    if (uv_pipe_pending_instances_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_pending_instances'",uv_pipe_pending_instances_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_pending_instances_ExpectAndReturn (uv_pipe_t * handle, int count, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_count)
{
    if(uv_pipe_pending_instances_struct_inst.callback != NULL)
    {
        uv_pipe_pending_instances_MockReset ();
    }

    if(uv_pipe_pending_instances_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_pending_instances_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_pipe_pending_instances (uv_pipe_t * handle, int count)");
    uv_pipe_pending_instances_struct_inst.calls[uv_pipe_pending_instances_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_pending_instances_struct_inst.calls[uv_pipe_pending_instances_struct_inst.expectedCalls].count = (int)count;
    uv_pipe_pending_instances_struct_inst.calls[uv_pipe_pending_instances_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_pending_instances_struct_inst.calls[uv_pipe_pending_instances_struct_inst.expectedCalls].match_count = match_count;
    uv_pipe_pending_instances_struct_inst.calls[uv_pipe_pending_instances_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_pending_instances_struct_inst.expectedCalls++;
}

int uv_pipe_pending_count(uv_pipe_t * handle)
{
    int default_res = (int)uv_pipe_pending_count_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_pipe_pending_count_struct_inst.actualCalls++;

    if (uv_pipe_pending_count_struct_inst.callback != NULL)
    {
        return uv_pipe_pending_count_struct_inst.callback (handle, uv_pipe_pending_count_struct_inst.actualCalls);
    }
    if (uv_pipe_pending_count_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_pending_count', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_pipe_pending_count (uv_pipe_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_pipe_pending_count(uv_pipe_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_pending_count_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_pending_count_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_pending_count_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_pending_count_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_pending_count', %s",uv_pipe_pending_count_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_pending_count_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_pending_count_struct_inst.calls[opmock_i - 1] = uv_pipe_pending_count_struct_inst.calls[opmock_i];
    }

    uv_pipe_pending_count_struct_inst.expectedCalls--;
    return default_res;
}

void uv_pipe_pending_count_MockReset()
{
    uv_pipe_pending_count_struct_inst.expectedCalls = 0;
    uv_pipe_pending_count_struct_inst.actualCalls = 0;
    uv_pipe_pending_count_struct_inst.callback = NULL;
}

void uv_pipe_pending_count_MockWithCallback(OPMOCK_uv_pipe_pending_count_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_pending_count_struct_inst.callback = callback;
    uv_pipe_pending_count_struct_inst.expectedCalls = 0;
    uv_pipe_pending_count_struct_inst.actualCalls = 0;
}

void uv_pipe_pending_count_VerifyMock()
{
    if (uv_pipe_pending_count_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_pending_count'",uv_pipe_pending_count_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_pending_count_ExpectAndReturn (uv_pipe_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_pipe_pending_count_struct_inst.callback != NULL)
    {
        uv_pipe_pending_count_MockReset ();
    }

    if(uv_pipe_pending_count_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_pending_count_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_pipe_pending_count (uv_pipe_t * handle)");
    uv_pipe_pending_count_struct_inst.calls[uv_pipe_pending_count_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_pending_count_struct_inst.calls[uv_pipe_pending_count_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_pending_count_struct_inst.calls[uv_pipe_pending_count_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_pipe_pending_count_struct_inst.calls[uv_pipe_pending_count_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_pending_count_struct_inst.expectedCalls++;
}

uv_handle_type uv_pipe_pending_type(uv_pipe_t * handle)
{
    uv_handle_type default_res = (uv_handle_type)uv_pipe_pending_type_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_pipe_pending_type_struct_inst.actualCalls++;

    if (uv_pipe_pending_type_struct_inst.callback != NULL)
    {
        return uv_pipe_pending_type_struct_inst.callback (handle, uv_pipe_pending_type_struct_inst.actualCalls);
    }
    if (uv_pipe_pending_type_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_pipe_pending_type', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uv_handle_type uv_pipe_pending_type (uv_pipe_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uv_handle_type uv_pipe_pending_type(uv_pipe_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_pipe_pending_type_struct_inst.calls[0].check_params == 1) {
        if(uv_pipe_pending_type_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_pipe_pending_type_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_pipe_pending_type_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_pipe_pending_type', %s",uv_pipe_pending_type_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_pipe_pending_type_struct_inst.expectedCalls; opmock_i++) {
        uv_pipe_pending_type_struct_inst.calls[opmock_i - 1] = uv_pipe_pending_type_struct_inst.calls[opmock_i];
    }

    uv_pipe_pending_type_struct_inst.expectedCalls--;
    return default_res;
}

void uv_pipe_pending_type_MockReset()
{
    uv_pipe_pending_type_struct_inst.expectedCalls = 0;
    uv_pipe_pending_type_struct_inst.actualCalls = 0;
    uv_pipe_pending_type_struct_inst.callback = NULL;
}

void uv_pipe_pending_type_MockWithCallback(OPMOCK_uv_pipe_pending_type_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_pipe_pending_type_struct_inst.callback = callback;
    uv_pipe_pending_type_struct_inst.expectedCalls = 0;
    uv_pipe_pending_type_struct_inst.actualCalls = 0;
}

void uv_pipe_pending_type_VerifyMock()
{
    if (uv_pipe_pending_type_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_pipe_pending_type'",uv_pipe_pending_type_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_pipe_pending_type_ExpectAndReturn (uv_pipe_t * handle, uv_handle_type to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_pipe_pending_type_struct_inst.callback != NULL)
    {
        uv_pipe_pending_type_MockReset ();
    }

    if(uv_pipe_pending_type_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_pipe_pending_type_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uv_handle_type uv_pipe_pending_type (uv_pipe_t * handle)");
    uv_pipe_pending_type_struct_inst.calls[uv_pipe_pending_type_struct_inst.expectedCalls].handle = (void *)handle;
    uv_pipe_pending_type_struct_inst.calls[uv_pipe_pending_type_struct_inst.expectedCalls].match_handle = match_handle;
    uv_pipe_pending_type_struct_inst.calls[uv_pipe_pending_type_struct_inst.expectedCalls].to_return = (uv_handle_type) to_return;
    uv_pipe_pending_type_struct_inst.calls[uv_pipe_pending_type_struct_inst.expectedCalls].check_params = 1;
    uv_pipe_pending_type_struct_inst.expectedCalls++;
}

int uv_poll_init(uv_loop_t * loop, uv_poll_t * handle, int fd)
{
    int default_res = (int)uv_poll_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_poll_init_struct_inst.actualCalls++;

    if (uv_poll_init_struct_inst.callback != NULL)
    {
        return uv_poll_init_struct_inst.callback (loop, handle, fd, uv_poll_init_struct_inst.actualCalls);
    }
    if (uv_poll_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_poll_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_poll_init (uv_loop_t * loop, uv_poll_t * handle, int fd)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_poll_init(uv_loop_t * loop, uv_poll_t * handle, int fd)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_poll_init_struct_inst.calls[0].check_params == 1) {
        if(uv_poll_init_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_poll_init_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_poll_init_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_init', %s",uv_poll_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_poll_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_poll_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_poll_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_init', %s",uv_poll_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_poll_init_struct_inst.calls[0].match_fd) {
            void * val1 = (void *) &uv_poll_init_struct_inst.calls[0].fd;
            void * val2 = (void *) &fd;
            int match_result = uv_poll_init_struct_inst.calls[0].match_fd(val1, val2, "fd", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_init', %s",uv_poll_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_poll_init_struct_inst.expectedCalls; opmock_i++) {
        uv_poll_init_struct_inst.calls[opmock_i - 1] = uv_poll_init_struct_inst.calls[opmock_i];
    }

    uv_poll_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_poll_init_MockReset()
{
    uv_poll_init_struct_inst.expectedCalls = 0;
    uv_poll_init_struct_inst.actualCalls = 0;
    uv_poll_init_struct_inst.callback = NULL;
}

void uv_poll_init_MockWithCallback(OPMOCK_uv_poll_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_poll_init_struct_inst.callback = callback;
    uv_poll_init_struct_inst.expectedCalls = 0;
    uv_poll_init_struct_inst.actualCalls = 0;
}

void uv_poll_init_VerifyMock()
{
    if (uv_poll_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_poll_init'",uv_poll_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_poll_init_ExpectAndReturn (uv_loop_t * loop, uv_poll_t * handle, int fd, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_fd)
{
    if(uv_poll_init_struct_inst.callback != NULL)
    {
        uv_poll_init_MockReset ();
    }

    if(uv_poll_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_poll_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_poll_init (uv_loop_t * loop, uv_poll_t * handle, int fd)");
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].loop = (void *)loop;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].fd = (int)fd;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].match_loop = match_loop;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].match_fd = match_fd;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_poll_init_struct_inst.calls[uv_poll_init_struct_inst.expectedCalls].check_params = 1;
    uv_poll_init_struct_inst.expectedCalls++;
}

int uv_poll_init_socket(uv_loop_t * loop, uv_poll_t * handle, uv_os_sock_t socket)
{
    int default_res = (int)uv_poll_init_socket_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_poll_init_socket_struct_inst.actualCalls++;

    if (uv_poll_init_socket_struct_inst.callback != NULL)
    {
        return uv_poll_init_socket_struct_inst.callback (loop, handle, socket, uv_poll_init_socket_struct_inst.actualCalls);
    }
    if (uv_poll_init_socket_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_poll_init_socket', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_poll_init_socket (uv_loop_t * loop, uv_poll_t * handle, uv_os_sock_t socket)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_poll_init_socket(uv_loop_t * loop, uv_poll_t * handle, uv_os_sock_t socket)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_poll_init_socket_struct_inst.calls[0].check_params == 1) {
        if(uv_poll_init_socket_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_poll_init_socket_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_poll_init_socket_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_init_socket', %s",uv_poll_init_socket_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_poll_init_socket_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_poll_init_socket_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_poll_init_socket_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_init_socket', %s",uv_poll_init_socket_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_poll_init_socket_struct_inst.calls[0].match_socket) {
            void * val1 = (void *) &uv_poll_init_socket_struct_inst.calls[0].socket;
            void * val2 = (void *) &socket;
            int match_result = uv_poll_init_socket_struct_inst.calls[0].match_socket(val1, val2, "socket", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_init_socket', %s",uv_poll_init_socket_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_poll_init_socket_struct_inst.expectedCalls; opmock_i++) {
        uv_poll_init_socket_struct_inst.calls[opmock_i - 1] = uv_poll_init_socket_struct_inst.calls[opmock_i];
    }

    uv_poll_init_socket_struct_inst.expectedCalls--;
    return default_res;
}

void uv_poll_init_socket_MockReset()
{
    uv_poll_init_socket_struct_inst.expectedCalls = 0;
    uv_poll_init_socket_struct_inst.actualCalls = 0;
    uv_poll_init_socket_struct_inst.callback = NULL;
}

void uv_poll_init_socket_MockWithCallback(OPMOCK_uv_poll_init_socket_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_poll_init_socket_struct_inst.callback = callback;
    uv_poll_init_socket_struct_inst.expectedCalls = 0;
    uv_poll_init_socket_struct_inst.actualCalls = 0;
}

void uv_poll_init_socket_VerifyMock()
{
    if (uv_poll_init_socket_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_poll_init_socket'",uv_poll_init_socket_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_poll_init_socket_ExpectAndReturn (uv_loop_t * loop, uv_poll_t * handle, uv_os_sock_t socket, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_socket)
{
    if(uv_poll_init_socket_struct_inst.callback != NULL)
    {
        uv_poll_init_socket_MockReset ();
    }

    if(uv_poll_init_socket_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_poll_init_socket_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_poll_init_socket (uv_loop_t * loop, uv_poll_t * handle, uv_os_sock_t socket)");
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].loop = (void *)loop;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].handle = (void *)handle;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].socket = (int)socket;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].match_loop = match_loop;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].match_handle = match_handle;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].match_socket = match_socket;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_poll_init_socket_struct_inst.calls[uv_poll_init_socket_struct_inst.expectedCalls].check_params = 1;
    uv_poll_init_socket_struct_inst.expectedCalls++;
}

int uv_poll_start(uv_poll_t * handle, int events, uv_poll_cb cb)
{
    int default_res = (int)uv_poll_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_poll_start_struct_inst.actualCalls++;

    if (uv_poll_start_struct_inst.callback != NULL)
    {
        return uv_poll_start_struct_inst.callback (handle, events, cb, uv_poll_start_struct_inst.actualCalls);
    }
    if (uv_poll_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_poll_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_poll_start (uv_poll_t * handle, int events, uv_poll_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_poll_start(uv_poll_t * handle, int events, uv_poll_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_poll_start_struct_inst.calls[0].check_params == 1) {
        if(uv_poll_start_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_poll_start_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_poll_start_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_start', %s",uv_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_poll_start_struct_inst.calls[0].match_events) {
            void * val1 = (void *) &uv_poll_start_struct_inst.calls[0].events;
            void * val2 = (void *) &events;
            int match_result = uv_poll_start_struct_inst.calls[0].match_events(val1, val2, "events", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_start', %s",uv_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_poll_start_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_poll_start_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_poll_start_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_start', %s",uv_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_poll_start_struct_inst.expectedCalls; opmock_i++) {
        uv_poll_start_struct_inst.calls[opmock_i - 1] = uv_poll_start_struct_inst.calls[opmock_i];
    }

    uv_poll_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_poll_start_MockReset()
{
    uv_poll_start_struct_inst.expectedCalls = 0;
    uv_poll_start_struct_inst.actualCalls = 0;
    uv_poll_start_struct_inst.callback = NULL;
}

void uv_poll_start_MockWithCallback(OPMOCK_uv_poll_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_poll_start_struct_inst.callback = callback;
    uv_poll_start_struct_inst.expectedCalls = 0;
    uv_poll_start_struct_inst.actualCalls = 0;
}

void uv_poll_start_VerifyMock()
{
    if (uv_poll_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_poll_start'",uv_poll_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_poll_start_ExpectAndReturn (uv_poll_t * handle, int events, uv_poll_cb cb, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_events, OPMOCK_MATCHER match_cb)
{
    if(uv_poll_start_struct_inst.callback != NULL)
    {
        uv_poll_start_MockReset ();
    }

    if(uv_poll_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_poll_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_poll_start (uv_poll_t * handle, int events, uv_poll_cb cb)");
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].handle = (void *)handle;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].events = (int)events;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].cb = (void *)cb;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].match_handle = match_handle;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].match_events = match_events;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].match_cb = match_cb;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_poll_start_struct_inst.calls[uv_poll_start_struct_inst.expectedCalls].check_params = 1;
    uv_poll_start_struct_inst.expectedCalls++;
}

int uv_poll_stop(uv_poll_t * handle)
{
    int default_res = (int)uv_poll_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_poll_stop_struct_inst.actualCalls++;

    if (uv_poll_stop_struct_inst.callback != NULL)
    {
        return uv_poll_stop_struct_inst.callback (handle, uv_poll_stop_struct_inst.actualCalls);
    }
    if (uv_poll_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_poll_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_poll_stop (uv_poll_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_poll_stop(uv_poll_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_poll_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_poll_stop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_poll_stop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_poll_stop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_poll_stop', %s",uv_poll_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_poll_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_poll_stop_struct_inst.calls[opmock_i - 1] = uv_poll_stop_struct_inst.calls[opmock_i];
    }

    uv_poll_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_poll_stop_MockReset()
{
    uv_poll_stop_struct_inst.expectedCalls = 0;
    uv_poll_stop_struct_inst.actualCalls = 0;
    uv_poll_stop_struct_inst.callback = NULL;
}

void uv_poll_stop_MockWithCallback(OPMOCK_uv_poll_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_poll_stop_struct_inst.callback = callback;
    uv_poll_stop_struct_inst.expectedCalls = 0;
    uv_poll_stop_struct_inst.actualCalls = 0;
}

void uv_poll_stop_VerifyMock()
{
    if (uv_poll_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_poll_stop'",uv_poll_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_poll_stop_ExpectAndReturn (uv_poll_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_poll_stop_struct_inst.callback != NULL)
    {
        uv_poll_stop_MockReset ();
    }

    if(uv_poll_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_poll_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_poll_stop (uv_poll_t * handle)");
    uv_poll_stop_struct_inst.calls[uv_poll_stop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_poll_stop_struct_inst.calls[uv_poll_stop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_poll_stop_struct_inst.calls[uv_poll_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_poll_stop_struct_inst.calls[uv_poll_stop_struct_inst.expectedCalls].check_params = 1;
    uv_poll_stop_struct_inst.expectedCalls++;
}

int uv_prepare_init(uv_loop_t * arg1, uv_prepare_t * prepare)
{
    int default_res = (int)uv_prepare_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_prepare_init_struct_inst.actualCalls++;

    if (uv_prepare_init_struct_inst.callback != NULL)
    {
        return uv_prepare_init_struct_inst.callback (arg1, prepare, uv_prepare_init_struct_inst.actualCalls);
    }
    if (uv_prepare_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_prepare_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_prepare_init (uv_loop_t * arg1, uv_prepare_t * prepare)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_prepare_init(uv_loop_t * arg1, uv_prepare_t * prepare)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_prepare_init_struct_inst.calls[0].check_params == 1) {
        if(uv_prepare_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_prepare_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_prepare_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_prepare_init', %s",uv_prepare_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_prepare_init_struct_inst.calls[0].match_prepare) {
            void * val1 = (void *) &uv_prepare_init_struct_inst.calls[0].prepare;
            void * val2 = (void *) &prepare;
            int match_result = uv_prepare_init_struct_inst.calls[0].match_prepare(val1, val2, "prepare", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_prepare_init', %s",uv_prepare_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_prepare_init_struct_inst.expectedCalls; opmock_i++) {
        uv_prepare_init_struct_inst.calls[opmock_i - 1] = uv_prepare_init_struct_inst.calls[opmock_i];
    }

    uv_prepare_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_prepare_init_MockReset()
{
    uv_prepare_init_struct_inst.expectedCalls = 0;
    uv_prepare_init_struct_inst.actualCalls = 0;
    uv_prepare_init_struct_inst.callback = NULL;
}

void uv_prepare_init_MockWithCallback(OPMOCK_uv_prepare_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_prepare_init_struct_inst.callback = callback;
    uv_prepare_init_struct_inst.expectedCalls = 0;
    uv_prepare_init_struct_inst.actualCalls = 0;
}

void uv_prepare_init_VerifyMock()
{
    if (uv_prepare_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_prepare_init'",uv_prepare_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_prepare_init_ExpectAndReturn (uv_loop_t * arg1, uv_prepare_t * prepare, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_prepare)
{
    if(uv_prepare_init_struct_inst.callback != NULL)
    {
        uv_prepare_init_MockReset ();
    }

    if(uv_prepare_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_prepare_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_prepare_init (uv_loop_t * arg1, uv_prepare_t * prepare)");
    uv_prepare_init_struct_inst.calls[uv_prepare_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_prepare_init_struct_inst.calls[uv_prepare_init_struct_inst.expectedCalls].prepare = (void *)prepare;
    uv_prepare_init_struct_inst.calls[uv_prepare_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_prepare_init_struct_inst.calls[uv_prepare_init_struct_inst.expectedCalls].match_prepare = match_prepare;
    uv_prepare_init_struct_inst.calls[uv_prepare_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_prepare_init_struct_inst.calls[uv_prepare_init_struct_inst.expectedCalls].check_params = 1;
    uv_prepare_init_struct_inst.expectedCalls++;
}

int uv_prepare_start(uv_prepare_t * prepare, uv_prepare_cb cb)
{
    int default_res = (int)uv_prepare_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_prepare_start_struct_inst.actualCalls++;

    if (uv_prepare_start_struct_inst.callback != NULL)
    {
        return uv_prepare_start_struct_inst.callback (prepare, cb, uv_prepare_start_struct_inst.actualCalls);
    }
    if (uv_prepare_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_prepare_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_prepare_start (uv_prepare_t * prepare, uv_prepare_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_prepare_start(uv_prepare_t * prepare, uv_prepare_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_prepare_start_struct_inst.calls[0].check_params == 1) {
        if(uv_prepare_start_struct_inst.calls[0].match_prepare) {
            void * val1 = (void *) &uv_prepare_start_struct_inst.calls[0].prepare;
            void * val2 = (void *) &prepare;
            int match_result = uv_prepare_start_struct_inst.calls[0].match_prepare(val1, val2, "prepare", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_prepare_start', %s",uv_prepare_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_prepare_start_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_prepare_start_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_prepare_start_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_prepare_start', %s",uv_prepare_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_prepare_start_struct_inst.expectedCalls; opmock_i++) {
        uv_prepare_start_struct_inst.calls[opmock_i - 1] = uv_prepare_start_struct_inst.calls[opmock_i];
    }

    uv_prepare_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_prepare_start_MockReset()
{
    uv_prepare_start_struct_inst.expectedCalls = 0;
    uv_prepare_start_struct_inst.actualCalls = 0;
    uv_prepare_start_struct_inst.callback = NULL;
}

void uv_prepare_start_MockWithCallback(OPMOCK_uv_prepare_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_prepare_start_struct_inst.callback = callback;
    uv_prepare_start_struct_inst.expectedCalls = 0;
    uv_prepare_start_struct_inst.actualCalls = 0;
}

void uv_prepare_start_VerifyMock()
{
    if (uv_prepare_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_prepare_start'",uv_prepare_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_prepare_start_ExpectAndReturn (uv_prepare_t * prepare, uv_prepare_cb cb, int to_return, OPMOCK_MATCHER match_prepare, OPMOCK_MATCHER match_cb)
{
    if(uv_prepare_start_struct_inst.callback != NULL)
    {
        uv_prepare_start_MockReset ();
    }

    if(uv_prepare_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_prepare_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_prepare_start (uv_prepare_t * prepare, uv_prepare_cb cb)");
    uv_prepare_start_struct_inst.calls[uv_prepare_start_struct_inst.expectedCalls].prepare = (void *)prepare;
    uv_prepare_start_struct_inst.calls[uv_prepare_start_struct_inst.expectedCalls].cb = (void *)cb;
    uv_prepare_start_struct_inst.calls[uv_prepare_start_struct_inst.expectedCalls].match_prepare = match_prepare;
    uv_prepare_start_struct_inst.calls[uv_prepare_start_struct_inst.expectedCalls].match_cb = match_cb;
    uv_prepare_start_struct_inst.calls[uv_prepare_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_prepare_start_struct_inst.calls[uv_prepare_start_struct_inst.expectedCalls].check_params = 1;
    uv_prepare_start_struct_inst.expectedCalls++;
}

int uv_prepare_stop(uv_prepare_t * prepare)
{
    int default_res = (int)uv_prepare_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_prepare_stop_struct_inst.actualCalls++;

    if (uv_prepare_stop_struct_inst.callback != NULL)
    {
        return uv_prepare_stop_struct_inst.callback (prepare, uv_prepare_stop_struct_inst.actualCalls);
    }
    if (uv_prepare_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_prepare_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_prepare_stop (uv_prepare_t * prepare)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_prepare_stop(uv_prepare_t * prepare)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_prepare_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_prepare_stop_struct_inst.calls[0].match_prepare) {
            void * val1 = (void *) &uv_prepare_stop_struct_inst.calls[0].prepare;
            void * val2 = (void *) &prepare;
            int match_result = uv_prepare_stop_struct_inst.calls[0].match_prepare(val1, val2, "prepare", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_prepare_stop', %s",uv_prepare_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_prepare_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_prepare_stop_struct_inst.calls[opmock_i - 1] = uv_prepare_stop_struct_inst.calls[opmock_i];
    }

    uv_prepare_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_prepare_stop_MockReset()
{
    uv_prepare_stop_struct_inst.expectedCalls = 0;
    uv_prepare_stop_struct_inst.actualCalls = 0;
    uv_prepare_stop_struct_inst.callback = NULL;
}

void uv_prepare_stop_MockWithCallback(OPMOCK_uv_prepare_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_prepare_stop_struct_inst.callback = callback;
    uv_prepare_stop_struct_inst.expectedCalls = 0;
    uv_prepare_stop_struct_inst.actualCalls = 0;
}

void uv_prepare_stop_VerifyMock()
{
    if (uv_prepare_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_prepare_stop'",uv_prepare_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_prepare_stop_ExpectAndReturn (uv_prepare_t * prepare, int to_return, OPMOCK_MATCHER match_prepare)
{
    if(uv_prepare_stop_struct_inst.callback != NULL)
    {
        uv_prepare_stop_MockReset ();
    }

    if(uv_prepare_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_prepare_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_prepare_stop (uv_prepare_t * prepare)");
    uv_prepare_stop_struct_inst.calls[uv_prepare_stop_struct_inst.expectedCalls].prepare = (void *)prepare;
    uv_prepare_stop_struct_inst.calls[uv_prepare_stop_struct_inst.expectedCalls].match_prepare = match_prepare;
    uv_prepare_stop_struct_inst.calls[uv_prepare_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_prepare_stop_struct_inst.calls[uv_prepare_stop_struct_inst.expectedCalls].check_params = 1;
    uv_prepare_stop_struct_inst.expectedCalls++;
}

int uv_check_init(uv_loop_t * arg1, uv_check_t * check)
{
    int default_res = (int)uv_check_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_check_init_struct_inst.actualCalls++;

    if (uv_check_init_struct_inst.callback != NULL)
    {
        return uv_check_init_struct_inst.callback (arg1, check, uv_check_init_struct_inst.actualCalls);
    }
    if (uv_check_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_check_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_check_init (uv_loop_t * arg1, uv_check_t * check)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_check_init(uv_loop_t * arg1, uv_check_t * check)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_check_init_struct_inst.calls[0].check_params == 1) {
        if(uv_check_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_check_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_check_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_check_init', %s",uv_check_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_check_init_struct_inst.calls[0].match_check) {
            void * val1 = (void *) &uv_check_init_struct_inst.calls[0].check;
            void * val2 = (void *) &check;
            int match_result = uv_check_init_struct_inst.calls[0].match_check(val1, val2, "check", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_check_init', %s",uv_check_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_check_init_struct_inst.expectedCalls; opmock_i++) {
        uv_check_init_struct_inst.calls[opmock_i - 1] = uv_check_init_struct_inst.calls[opmock_i];
    }

    uv_check_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_check_init_MockReset()
{
    uv_check_init_struct_inst.expectedCalls = 0;
    uv_check_init_struct_inst.actualCalls = 0;
    uv_check_init_struct_inst.callback = NULL;
}

void uv_check_init_MockWithCallback(OPMOCK_uv_check_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_check_init_struct_inst.callback = callback;
    uv_check_init_struct_inst.expectedCalls = 0;
    uv_check_init_struct_inst.actualCalls = 0;
}

void uv_check_init_VerifyMock()
{
    if (uv_check_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_check_init'",uv_check_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_check_init_ExpectAndReturn (uv_loop_t * arg1, uv_check_t * check, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_check)
{
    if(uv_check_init_struct_inst.callback != NULL)
    {
        uv_check_init_MockReset ();
    }

    if(uv_check_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_check_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_check_init (uv_loop_t * arg1, uv_check_t * check)");
    uv_check_init_struct_inst.calls[uv_check_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_check_init_struct_inst.calls[uv_check_init_struct_inst.expectedCalls].check = (void *)check;
    uv_check_init_struct_inst.calls[uv_check_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_check_init_struct_inst.calls[uv_check_init_struct_inst.expectedCalls].match_check = match_check;
    uv_check_init_struct_inst.calls[uv_check_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_check_init_struct_inst.calls[uv_check_init_struct_inst.expectedCalls].check_params = 1;
    uv_check_init_struct_inst.expectedCalls++;
}

int uv_check_start(uv_check_t * check, uv_check_cb cb)
{
    int default_res = (int)uv_check_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_check_start_struct_inst.actualCalls++;

    if (uv_check_start_struct_inst.callback != NULL)
    {
        return uv_check_start_struct_inst.callback (check, cb, uv_check_start_struct_inst.actualCalls);
    }
    if (uv_check_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_check_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_check_start (uv_check_t * check, uv_check_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_check_start(uv_check_t * check, uv_check_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_check_start_struct_inst.calls[0].check_params == 1) {
        if(uv_check_start_struct_inst.calls[0].match_check) {
            void * val1 = (void *) &uv_check_start_struct_inst.calls[0].check;
            void * val2 = (void *) &check;
            int match_result = uv_check_start_struct_inst.calls[0].match_check(val1, val2, "check", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_check_start', %s",uv_check_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_check_start_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_check_start_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_check_start_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_check_start', %s",uv_check_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_check_start_struct_inst.expectedCalls; opmock_i++) {
        uv_check_start_struct_inst.calls[opmock_i - 1] = uv_check_start_struct_inst.calls[opmock_i];
    }

    uv_check_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_check_start_MockReset()
{
    uv_check_start_struct_inst.expectedCalls = 0;
    uv_check_start_struct_inst.actualCalls = 0;
    uv_check_start_struct_inst.callback = NULL;
}

void uv_check_start_MockWithCallback(OPMOCK_uv_check_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_check_start_struct_inst.callback = callback;
    uv_check_start_struct_inst.expectedCalls = 0;
    uv_check_start_struct_inst.actualCalls = 0;
}

void uv_check_start_VerifyMock()
{
    if (uv_check_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_check_start'",uv_check_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_check_start_ExpectAndReturn (uv_check_t * check, uv_check_cb cb, int to_return, OPMOCK_MATCHER match_check, OPMOCK_MATCHER match_cb)
{
    if(uv_check_start_struct_inst.callback != NULL)
    {
        uv_check_start_MockReset ();
    }

    if(uv_check_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_check_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_check_start (uv_check_t * check, uv_check_cb cb)");
    uv_check_start_struct_inst.calls[uv_check_start_struct_inst.expectedCalls].check = (void *)check;
    uv_check_start_struct_inst.calls[uv_check_start_struct_inst.expectedCalls].cb = (void *)cb;
    uv_check_start_struct_inst.calls[uv_check_start_struct_inst.expectedCalls].match_check = match_check;
    uv_check_start_struct_inst.calls[uv_check_start_struct_inst.expectedCalls].match_cb = match_cb;
    uv_check_start_struct_inst.calls[uv_check_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_check_start_struct_inst.calls[uv_check_start_struct_inst.expectedCalls].check_params = 1;
    uv_check_start_struct_inst.expectedCalls++;
}

int uv_check_stop(uv_check_t * check)
{
    int default_res = (int)uv_check_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_check_stop_struct_inst.actualCalls++;

    if (uv_check_stop_struct_inst.callback != NULL)
    {
        return uv_check_stop_struct_inst.callback (check, uv_check_stop_struct_inst.actualCalls);
    }
    if (uv_check_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_check_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_check_stop (uv_check_t * check)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_check_stop(uv_check_t * check)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_check_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_check_stop_struct_inst.calls[0].match_check) {
            void * val1 = (void *) &uv_check_stop_struct_inst.calls[0].check;
            void * val2 = (void *) &check;
            int match_result = uv_check_stop_struct_inst.calls[0].match_check(val1, val2, "check", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_check_stop', %s",uv_check_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_check_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_check_stop_struct_inst.calls[opmock_i - 1] = uv_check_stop_struct_inst.calls[opmock_i];
    }

    uv_check_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_check_stop_MockReset()
{
    uv_check_stop_struct_inst.expectedCalls = 0;
    uv_check_stop_struct_inst.actualCalls = 0;
    uv_check_stop_struct_inst.callback = NULL;
}

void uv_check_stop_MockWithCallback(OPMOCK_uv_check_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_check_stop_struct_inst.callback = callback;
    uv_check_stop_struct_inst.expectedCalls = 0;
    uv_check_stop_struct_inst.actualCalls = 0;
}

void uv_check_stop_VerifyMock()
{
    if (uv_check_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_check_stop'",uv_check_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_check_stop_ExpectAndReturn (uv_check_t * check, int to_return, OPMOCK_MATCHER match_check)
{
    if(uv_check_stop_struct_inst.callback != NULL)
    {
        uv_check_stop_MockReset ();
    }

    if(uv_check_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_check_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_check_stop (uv_check_t * check)");
    uv_check_stop_struct_inst.calls[uv_check_stop_struct_inst.expectedCalls].check = (void *)check;
    uv_check_stop_struct_inst.calls[uv_check_stop_struct_inst.expectedCalls].match_check = match_check;
    uv_check_stop_struct_inst.calls[uv_check_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_check_stop_struct_inst.calls[uv_check_stop_struct_inst.expectedCalls].check_params = 1;
    uv_check_stop_struct_inst.expectedCalls++;
}

int uv_idle_init(uv_loop_t * arg1, uv_idle_t * idle)
{
    int default_res = (int)uv_idle_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_idle_init_struct_inst.actualCalls++;

    if (uv_idle_init_struct_inst.callback != NULL)
    {
        return uv_idle_init_struct_inst.callback (arg1, idle, uv_idle_init_struct_inst.actualCalls);
    }
    if (uv_idle_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_idle_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_idle_init (uv_loop_t * arg1, uv_idle_t * idle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_idle_init(uv_loop_t * arg1, uv_idle_t * idle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_idle_init_struct_inst.calls[0].check_params == 1) {
        if(uv_idle_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_idle_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_idle_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_idle_init', %s",uv_idle_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_idle_init_struct_inst.calls[0].match_idle) {
            void * val1 = (void *) &uv_idle_init_struct_inst.calls[0].idle;
            void * val2 = (void *) &idle;
            int match_result = uv_idle_init_struct_inst.calls[0].match_idle(val1, val2, "idle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_idle_init', %s",uv_idle_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_idle_init_struct_inst.expectedCalls; opmock_i++) {
        uv_idle_init_struct_inst.calls[opmock_i - 1] = uv_idle_init_struct_inst.calls[opmock_i];
    }

    uv_idle_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_idle_init_MockReset()
{
    uv_idle_init_struct_inst.expectedCalls = 0;
    uv_idle_init_struct_inst.actualCalls = 0;
    uv_idle_init_struct_inst.callback = NULL;
}

void uv_idle_init_MockWithCallback(OPMOCK_uv_idle_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_idle_init_struct_inst.callback = callback;
    uv_idle_init_struct_inst.expectedCalls = 0;
    uv_idle_init_struct_inst.actualCalls = 0;
}

void uv_idle_init_VerifyMock()
{
    if (uv_idle_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_idle_init'",uv_idle_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_idle_init_ExpectAndReturn (uv_loop_t * arg1, uv_idle_t * idle, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_idle)
{
    if(uv_idle_init_struct_inst.callback != NULL)
    {
        uv_idle_init_MockReset ();
    }

    if(uv_idle_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_idle_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_idle_init (uv_loop_t * arg1, uv_idle_t * idle)");
    uv_idle_init_struct_inst.calls[uv_idle_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_idle_init_struct_inst.calls[uv_idle_init_struct_inst.expectedCalls].idle = (void *)idle;
    uv_idle_init_struct_inst.calls[uv_idle_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_idle_init_struct_inst.calls[uv_idle_init_struct_inst.expectedCalls].match_idle = match_idle;
    uv_idle_init_struct_inst.calls[uv_idle_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_idle_init_struct_inst.calls[uv_idle_init_struct_inst.expectedCalls].check_params = 1;
    uv_idle_init_struct_inst.expectedCalls++;
}

int uv_idle_start(uv_idle_t * idle, uv_idle_cb cb)
{
    int default_res = (int)uv_idle_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_idle_start_struct_inst.actualCalls++;

    if (uv_idle_start_struct_inst.callback != NULL)
    {
        return uv_idle_start_struct_inst.callback (idle, cb, uv_idle_start_struct_inst.actualCalls);
    }
    if (uv_idle_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_idle_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_idle_start (uv_idle_t * idle, uv_idle_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_idle_start(uv_idle_t * idle, uv_idle_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_idle_start_struct_inst.calls[0].check_params == 1) {
        if(uv_idle_start_struct_inst.calls[0].match_idle) {
            void * val1 = (void *) &uv_idle_start_struct_inst.calls[0].idle;
            void * val2 = (void *) &idle;
            int match_result = uv_idle_start_struct_inst.calls[0].match_idle(val1, val2, "idle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_idle_start', %s",uv_idle_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_idle_start_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_idle_start_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_idle_start_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_idle_start', %s",uv_idle_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_idle_start_struct_inst.expectedCalls; opmock_i++) {
        uv_idle_start_struct_inst.calls[opmock_i - 1] = uv_idle_start_struct_inst.calls[opmock_i];
    }

    uv_idle_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_idle_start_MockReset()
{
    uv_idle_start_struct_inst.expectedCalls = 0;
    uv_idle_start_struct_inst.actualCalls = 0;
    uv_idle_start_struct_inst.callback = NULL;
}

void uv_idle_start_MockWithCallback(OPMOCK_uv_idle_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_idle_start_struct_inst.callback = callback;
    uv_idle_start_struct_inst.expectedCalls = 0;
    uv_idle_start_struct_inst.actualCalls = 0;
}

void uv_idle_start_VerifyMock()
{
    if (uv_idle_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_idle_start'",uv_idle_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_idle_start_ExpectAndReturn (uv_idle_t * idle, uv_idle_cb cb, int to_return, OPMOCK_MATCHER match_idle, OPMOCK_MATCHER match_cb)
{
    if(uv_idle_start_struct_inst.callback != NULL)
    {
        uv_idle_start_MockReset ();
    }

    if(uv_idle_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_idle_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_idle_start (uv_idle_t * idle, uv_idle_cb cb)");
    uv_idle_start_struct_inst.calls[uv_idle_start_struct_inst.expectedCalls].idle = (void *)idle;
    uv_idle_start_struct_inst.calls[uv_idle_start_struct_inst.expectedCalls].cb = (void *)cb;
    uv_idle_start_struct_inst.calls[uv_idle_start_struct_inst.expectedCalls].match_idle = match_idle;
    uv_idle_start_struct_inst.calls[uv_idle_start_struct_inst.expectedCalls].match_cb = match_cb;
    uv_idle_start_struct_inst.calls[uv_idle_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_idle_start_struct_inst.calls[uv_idle_start_struct_inst.expectedCalls].check_params = 1;
    uv_idle_start_struct_inst.expectedCalls++;
}

int uv_idle_stop(uv_idle_t * idle)
{
    int default_res = (int)uv_idle_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_idle_stop_struct_inst.actualCalls++;

    if (uv_idle_stop_struct_inst.callback != NULL)
    {
        return uv_idle_stop_struct_inst.callback (idle, uv_idle_stop_struct_inst.actualCalls);
    }
    if (uv_idle_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_idle_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_idle_stop (uv_idle_t * idle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_idle_stop(uv_idle_t * idle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_idle_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_idle_stop_struct_inst.calls[0].match_idle) {
            void * val1 = (void *) &uv_idle_stop_struct_inst.calls[0].idle;
            void * val2 = (void *) &idle;
            int match_result = uv_idle_stop_struct_inst.calls[0].match_idle(val1, val2, "idle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_idle_stop', %s",uv_idle_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_idle_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_idle_stop_struct_inst.calls[opmock_i - 1] = uv_idle_stop_struct_inst.calls[opmock_i];
    }

    uv_idle_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_idle_stop_MockReset()
{
    uv_idle_stop_struct_inst.expectedCalls = 0;
    uv_idle_stop_struct_inst.actualCalls = 0;
    uv_idle_stop_struct_inst.callback = NULL;
}

void uv_idle_stop_MockWithCallback(OPMOCK_uv_idle_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_idle_stop_struct_inst.callback = callback;
    uv_idle_stop_struct_inst.expectedCalls = 0;
    uv_idle_stop_struct_inst.actualCalls = 0;
}

void uv_idle_stop_VerifyMock()
{
    if (uv_idle_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_idle_stop'",uv_idle_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_idle_stop_ExpectAndReturn (uv_idle_t * idle, int to_return, OPMOCK_MATCHER match_idle)
{
    if(uv_idle_stop_struct_inst.callback != NULL)
    {
        uv_idle_stop_MockReset ();
    }

    if(uv_idle_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_idle_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_idle_stop (uv_idle_t * idle)");
    uv_idle_stop_struct_inst.calls[uv_idle_stop_struct_inst.expectedCalls].idle = (void *)idle;
    uv_idle_stop_struct_inst.calls[uv_idle_stop_struct_inst.expectedCalls].match_idle = match_idle;
    uv_idle_stop_struct_inst.calls[uv_idle_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_idle_stop_struct_inst.calls[uv_idle_stop_struct_inst.expectedCalls].check_params = 1;
    uv_idle_stop_struct_inst.expectedCalls++;
}

int uv_async_init(uv_loop_t * arg1, uv_async_t * async, uv_async_cb async_cb)
{
    int default_res = (int)uv_async_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_async_init_struct_inst.actualCalls++;

    if (uv_async_init_struct_inst.callback != NULL)
    {
        return uv_async_init_struct_inst.callback (arg1, async, async_cb, uv_async_init_struct_inst.actualCalls);
    }
    if (uv_async_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_async_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_async_init (uv_loop_t * arg1, uv_async_t * async, uv_async_cb async_cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_async_init(uv_loop_t * arg1, uv_async_t * async, uv_async_cb async_cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_async_init_struct_inst.calls[0].check_params == 1) {
        if(uv_async_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_async_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_async_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_async_init', %s",uv_async_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_async_init_struct_inst.calls[0].match_async) {
            void * val1 = (void *) &uv_async_init_struct_inst.calls[0].async;
            void * val2 = (void *) &async;
            int match_result = uv_async_init_struct_inst.calls[0].match_async(val1, val2, "async", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_async_init', %s",uv_async_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_async_init_struct_inst.calls[0].match_async_cb) {
            void * val1 = (void *) &uv_async_init_struct_inst.calls[0].async_cb;
            void * val2 = (void *) &async_cb;
            int match_result = uv_async_init_struct_inst.calls[0].match_async_cb(val1, val2, "async_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_async_init', %s",uv_async_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_async_init_struct_inst.expectedCalls; opmock_i++) {
        uv_async_init_struct_inst.calls[opmock_i - 1] = uv_async_init_struct_inst.calls[opmock_i];
    }

    uv_async_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_async_init_MockReset()
{
    uv_async_init_struct_inst.expectedCalls = 0;
    uv_async_init_struct_inst.actualCalls = 0;
    uv_async_init_struct_inst.callback = NULL;
}

void uv_async_init_MockWithCallback(OPMOCK_uv_async_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_async_init_struct_inst.callback = callback;
    uv_async_init_struct_inst.expectedCalls = 0;
    uv_async_init_struct_inst.actualCalls = 0;
}

void uv_async_init_VerifyMock()
{
    if (uv_async_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_async_init'",uv_async_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_async_init_ExpectAndReturn (uv_loop_t * arg1, uv_async_t * async, uv_async_cb async_cb, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_async, OPMOCK_MATCHER match_async_cb)
{
    if(uv_async_init_struct_inst.callback != NULL)
    {
        uv_async_init_MockReset ();
    }

    if(uv_async_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_async_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_async_init (uv_loop_t * arg1, uv_async_t * async, uv_async_cb async_cb)");
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].async = (void *)async;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].async_cb = (void *)async_cb;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].match_async = match_async;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].match_async_cb = match_async_cb;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_async_init_struct_inst.calls[uv_async_init_struct_inst.expectedCalls].check_params = 1;
    uv_async_init_struct_inst.expectedCalls++;
}

int uv_async_send(uv_async_t * async)
{
    int default_res = (int)uv_async_send_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_async_send_struct_inst.actualCalls++;

    if (uv_async_send_struct_inst.callback != NULL)
    {
        return uv_async_send_struct_inst.callback (async, uv_async_send_struct_inst.actualCalls);
    }
    if (uv_async_send_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_async_send', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_async_send (uv_async_t * async)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_async_send(uv_async_t * async)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_async_send_struct_inst.calls[0].check_params == 1) {
        if(uv_async_send_struct_inst.calls[0].match_async) {
            void * val1 = (void *) &uv_async_send_struct_inst.calls[0].async;
            void * val2 = (void *) &async;
            int match_result = uv_async_send_struct_inst.calls[0].match_async(val1, val2, "async", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_async_send', %s",uv_async_send_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_async_send_struct_inst.expectedCalls; opmock_i++) {
        uv_async_send_struct_inst.calls[opmock_i - 1] = uv_async_send_struct_inst.calls[opmock_i];
    }

    uv_async_send_struct_inst.expectedCalls--;
    return default_res;
}

void uv_async_send_MockReset()
{
    uv_async_send_struct_inst.expectedCalls = 0;
    uv_async_send_struct_inst.actualCalls = 0;
    uv_async_send_struct_inst.callback = NULL;
}

void uv_async_send_MockWithCallback(OPMOCK_uv_async_send_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_async_send_struct_inst.callback = callback;
    uv_async_send_struct_inst.expectedCalls = 0;
    uv_async_send_struct_inst.actualCalls = 0;
}

void uv_async_send_VerifyMock()
{
    if (uv_async_send_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_async_send'",uv_async_send_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_async_send_ExpectAndReturn (uv_async_t * async, int to_return, OPMOCK_MATCHER match_async)
{
    if(uv_async_send_struct_inst.callback != NULL)
    {
        uv_async_send_MockReset ();
    }

    if(uv_async_send_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_async_send_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_async_send (uv_async_t * async)");
    uv_async_send_struct_inst.calls[uv_async_send_struct_inst.expectedCalls].async = (void *)async;
    uv_async_send_struct_inst.calls[uv_async_send_struct_inst.expectedCalls].match_async = match_async;
    uv_async_send_struct_inst.calls[uv_async_send_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_async_send_struct_inst.calls[uv_async_send_struct_inst.expectedCalls].check_params = 1;
    uv_async_send_struct_inst.expectedCalls++;
}

int uv_timer_init(uv_loop_t * arg1, uv_timer_t * handle)
{
    int default_res = (int)uv_timer_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_timer_init_struct_inst.actualCalls++;

    if (uv_timer_init_struct_inst.callback != NULL)
    {
        return uv_timer_init_struct_inst.callback (arg1, handle, uv_timer_init_struct_inst.actualCalls);
    }
    if (uv_timer_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_timer_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_timer_init (uv_loop_t * arg1, uv_timer_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_timer_init(uv_loop_t * arg1, uv_timer_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_timer_init_struct_inst.calls[0].check_params == 1) {
        if(uv_timer_init_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_timer_init_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_timer_init_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_init', %s",uv_timer_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_timer_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_timer_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_timer_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_init', %s",uv_timer_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_timer_init_struct_inst.expectedCalls; opmock_i++) {
        uv_timer_init_struct_inst.calls[opmock_i - 1] = uv_timer_init_struct_inst.calls[opmock_i];
    }

    uv_timer_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_timer_init_MockReset()
{
    uv_timer_init_struct_inst.expectedCalls = 0;
    uv_timer_init_struct_inst.actualCalls = 0;
    uv_timer_init_struct_inst.callback = NULL;
}

void uv_timer_init_MockWithCallback(OPMOCK_uv_timer_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_timer_init_struct_inst.callback = callback;
    uv_timer_init_struct_inst.expectedCalls = 0;
    uv_timer_init_struct_inst.actualCalls = 0;
}

void uv_timer_init_VerifyMock()
{
    if (uv_timer_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_timer_init'",uv_timer_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_timer_init_ExpectAndReturn (uv_loop_t * arg1, uv_timer_t * handle, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_handle)
{
    if(uv_timer_init_struct_inst.callback != NULL)
    {
        uv_timer_init_MockReset ();
    }

    if(uv_timer_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_timer_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_timer_init (uv_loop_t * arg1, uv_timer_t * handle)");
    uv_timer_init_struct_inst.calls[uv_timer_init_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_timer_init_struct_inst.calls[uv_timer_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_timer_init_struct_inst.calls[uv_timer_init_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_timer_init_struct_inst.calls[uv_timer_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_timer_init_struct_inst.calls[uv_timer_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_timer_init_struct_inst.calls[uv_timer_init_struct_inst.expectedCalls].check_params = 1;
    uv_timer_init_struct_inst.expectedCalls++;
}

int uv_timer_start(uv_timer_t * handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat)
{
    int default_res = (int)uv_timer_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_timer_start_struct_inst.actualCalls++;

    if (uv_timer_start_struct_inst.callback != NULL)
    {
        return uv_timer_start_struct_inst.callback (handle, cb, timeout, repeat, uv_timer_start_struct_inst.actualCalls);
    }
    if (uv_timer_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_timer_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_timer_start (uv_timer_t * handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_timer_start(uv_timer_t * handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_timer_start_struct_inst.calls[0].check_params == 1) {
        if(uv_timer_start_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_timer_start_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_timer_start_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_start', %s",uv_timer_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_timer_start_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_timer_start_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_timer_start_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_start', %s",uv_timer_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_timer_start_struct_inst.calls[0].match_timeout) {
            void * val1 = (void *) &uv_timer_start_struct_inst.calls[0].timeout;
            void * val2 = (void *) &timeout;
            int match_result = uv_timer_start_struct_inst.calls[0].match_timeout(val1, val2, "timeout", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_start', %s",uv_timer_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_timer_start_struct_inst.calls[0].match_repeat) {
            void * val1 = (void *) &uv_timer_start_struct_inst.calls[0].repeat;
            void * val2 = (void *) &repeat;
            int match_result = uv_timer_start_struct_inst.calls[0].match_repeat(val1, val2, "repeat", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_start', %s",uv_timer_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_timer_start_struct_inst.expectedCalls; opmock_i++) {
        uv_timer_start_struct_inst.calls[opmock_i - 1] = uv_timer_start_struct_inst.calls[opmock_i];
    }

    uv_timer_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_timer_start_MockReset()
{
    uv_timer_start_struct_inst.expectedCalls = 0;
    uv_timer_start_struct_inst.actualCalls = 0;
    uv_timer_start_struct_inst.callback = NULL;
}

void uv_timer_start_MockWithCallback(OPMOCK_uv_timer_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_timer_start_struct_inst.callback = callback;
    uv_timer_start_struct_inst.expectedCalls = 0;
    uv_timer_start_struct_inst.actualCalls = 0;
}

void uv_timer_start_VerifyMock()
{
    if (uv_timer_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_timer_start'",uv_timer_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_timer_start_ExpectAndReturn (uv_timer_t * handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_cb, OPMOCK_MATCHER match_timeout, OPMOCK_MATCHER match_repeat)
{
    if(uv_timer_start_struct_inst.callback != NULL)
    {
        uv_timer_start_MockReset ();
    }

    if(uv_timer_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_timer_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_timer_start (uv_timer_t * handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat)");
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].handle = (void *)handle;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].cb = (void *)cb;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].timeout = (unsigned long long)timeout;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].repeat = (unsigned long long)repeat;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].match_handle = match_handle;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].match_cb = match_cb;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].match_timeout = match_timeout;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].match_repeat = match_repeat;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_timer_start_struct_inst.calls[uv_timer_start_struct_inst.expectedCalls].check_params = 1;
    uv_timer_start_struct_inst.expectedCalls++;
}

int uv_timer_stop(uv_timer_t * handle)
{
    int default_res = (int)uv_timer_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_timer_stop_struct_inst.actualCalls++;

    if (uv_timer_stop_struct_inst.callback != NULL)
    {
        return uv_timer_stop_struct_inst.callback (handle, uv_timer_stop_struct_inst.actualCalls);
    }
    if (uv_timer_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_timer_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_timer_stop (uv_timer_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_timer_stop(uv_timer_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_timer_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_timer_stop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_timer_stop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_timer_stop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_stop', %s",uv_timer_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_timer_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_timer_stop_struct_inst.calls[opmock_i - 1] = uv_timer_stop_struct_inst.calls[opmock_i];
    }

    uv_timer_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_timer_stop_MockReset()
{
    uv_timer_stop_struct_inst.expectedCalls = 0;
    uv_timer_stop_struct_inst.actualCalls = 0;
    uv_timer_stop_struct_inst.callback = NULL;
}

void uv_timer_stop_MockWithCallback(OPMOCK_uv_timer_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_timer_stop_struct_inst.callback = callback;
    uv_timer_stop_struct_inst.expectedCalls = 0;
    uv_timer_stop_struct_inst.actualCalls = 0;
}

void uv_timer_stop_VerifyMock()
{
    if (uv_timer_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_timer_stop'",uv_timer_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_timer_stop_ExpectAndReturn (uv_timer_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_timer_stop_struct_inst.callback != NULL)
    {
        uv_timer_stop_MockReset ();
    }

    if(uv_timer_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_timer_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_timer_stop (uv_timer_t * handle)");
    uv_timer_stop_struct_inst.calls[uv_timer_stop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_timer_stop_struct_inst.calls[uv_timer_stop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_timer_stop_struct_inst.calls[uv_timer_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_timer_stop_struct_inst.calls[uv_timer_stop_struct_inst.expectedCalls].check_params = 1;
    uv_timer_stop_struct_inst.expectedCalls++;
}

int uv_timer_again(uv_timer_t * handle)
{
    int default_res = (int)uv_timer_again_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_timer_again_struct_inst.actualCalls++;

    if (uv_timer_again_struct_inst.callback != NULL)
    {
        return uv_timer_again_struct_inst.callback (handle, uv_timer_again_struct_inst.actualCalls);
    }
    if (uv_timer_again_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_timer_again', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_timer_again (uv_timer_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_timer_again(uv_timer_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_timer_again_struct_inst.calls[0].check_params == 1) {
        if(uv_timer_again_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_timer_again_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_timer_again_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_again', %s",uv_timer_again_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_timer_again_struct_inst.expectedCalls; opmock_i++) {
        uv_timer_again_struct_inst.calls[opmock_i - 1] = uv_timer_again_struct_inst.calls[opmock_i];
    }

    uv_timer_again_struct_inst.expectedCalls--;
    return default_res;
}

void uv_timer_again_MockReset()
{
    uv_timer_again_struct_inst.expectedCalls = 0;
    uv_timer_again_struct_inst.actualCalls = 0;
    uv_timer_again_struct_inst.callback = NULL;
}

void uv_timer_again_MockWithCallback(OPMOCK_uv_timer_again_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_timer_again_struct_inst.callback = callback;
    uv_timer_again_struct_inst.expectedCalls = 0;
    uv_timer_again_struct_inst.actualCalls = 0;
}

void uv_timer_again_VerifyMock()
{
    if (uv_timer_again_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_timer_again'",uv_timer_again_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_timer_again_ExpectAndReturn (uv_timer_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_timer_again_struct_inst.callback != NULL)
    {
        uv_timer_again_MockReset ();
    }

    if(uv_timer_again_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_timer_again_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_timer_again (uv_timer_t * handle)");
    uv_timer_again_struct_inst.calls[uv_timer_again_struct_inst.expectedCalls].handle = (void *)handle;
    uv_timer_again_struct_inst.calls[uv_timer_again_struct_inst.expectedCalls].match_handle = match_handle;
    uv_timer_again_struct_inst.calls[uv_timer_again_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_timer_again_struct_inst.calls[uv_timer_again_struct_inst.expectedCalls].check_params = 1;
    uv_timer_again_struct_inst.expectedCalls++;
}

void uv_timer_set_repeat(uv_timer_t * handle, uint64_t repeat)
{
    int opmock_i;
    uv_timer_set_repeat_struct_inst.actualCalls++;

    if (uv_timer_set_repeat_struct_inst.callback != NULL)
    {
        uv_timer_set_repeat_struct_inst.callback (handle, repeat, uv_timer_set_repeat_struct_inst.actualCalls);
        return;
    }
    if (uv_timer_set_repeat_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_timer_set_repeat', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_timer_set_repeat (uv_timer_t * handle, uint64_t repeat)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_timer_set_repeat(uv_timer_t * handle, uint64_t repeat)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_timer_set_repeat_struct_inst.calls[0].check_params == 1) {
        if(uv_timer_set_repeat_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_timer_set_repeat_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_timer_set_repeat_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_set_repeat', %s",uv_timer_set_repeat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_timer_set_repeat_struct_inst.calls[0].match_repeat) {
            void * val1 = (void *) &uv_timer_set_repeat_struct_inst.calls[0].repeat;
            void * val2 = (void *) &repeat;
            int match_result = uv_timer_set_repeat_struct_inst.calls[0].match_repeat(val1, val2, "repeat", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_set_repeat', %s",uv_timer_set_repeat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_timer_set_repeat_struct_inst.expectedCalls; opmock_i++) {
        uv_timer_set_repeat_struct_inst.calls[opmock_i - 1] = uv_timer_set_repeat_struct_inst.calls[opmock_i];
    }

    uv_timer_set_repeat_struct_inst.expectedCalls--;
}

void uv_timer_set_repeat_MockReset()
{
    uv_timer_set_repeat_struct_inst.expectedCalls = 0;
    uv_timer_set_repeat_struct_inst.actualCalls = 0;
    uv_timer_set_repeat_struct_inst.callback = NULL;
}

void uv_timer_set_repeat_MockWithCallback(OPMOCK_uv_timer_set_repeat_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_timer_set_repeat_struct_inst.callback = callback;
    uv_timer_set_repeat_struct_inst.expectedCalls = 0;
    uv_timer_set_repeat_struct_inst.actualCalls = 0;
}

void uv_timer_set_repeat_VerifyMock()
{
    if (uv_timer_set_repeat_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_timer_set_repeat'",uv_timer_set_repeat_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_timer_set_repeat_ExpectAndReturn (uv_timer_t * handle, uint64_t repeat, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_repeat)
{
    if(uv_timer_set_repeat_struct_inst.callback != NULL)
    {
        uv_timer_set_repeat_MockReset ();
    }

    if(uv_timer_set_repeat_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_timer_set_repeat_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_timer_set_repeat (uv_timer_t * handle, uint64_t repeat)");
    uv_timer_set_repeat_struct_inst.calls[uv_timer_set_repeat_struct_inst.expectedCalls].handle = (void *)handle;
    uv_timer_set_repeat_struct_inst.calls[uv_timer_set_repeat_struct_inst.expectedCalls].repeat = (unsigned long long)repeat;
    uv_timer_set_repeat_struct_inst.calls[uv_timer_set_repeat_struct_inst.expectedCalls].match_handle = match_handle;
    uv_timer_set_repeat_struct_inst.calls[uv_timer_set_repeat_struct_inst.expectedCalls].match_repeat = match_repeat;
    uv_timer_set_repeat_struct_inst.calls[uv_timer_set_repeat_struct_inst.expectedCalls].check_params = 1;
    uv_timer_set_repeat_struct_inst.expectedCalls++;
}

uint64_t uv_timer_get_repeat(const uv_timer_t * handle)
{
    uint64_t default_res = (uint64_t)uv_timer_get_repeat_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_timer_get_repeat_struct_inst.actualCalls++;

    if (uv_timer_get_repeat_struct_inst.callback != NULL)
    {
        return uv_timer_get_repeat_struct_inst.callback (handle, uv_timer_get_repeat_struct_inst.actualCalls);
    }
    if (uv_timer_get_repeat_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_timer_get_repeat', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uint64_t uv_timer_get_repeat (const uv_timer_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uint64_t uv_timer_get_repeat(const uv_timer_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_timer_get_repeat_struct_inst.calls[0].check_params == 1) {
        if(uv_timer_get_repeat_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_timer_get_repeat_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_timer_get_repeat_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_timer_get_repeat', %s",uv_timer_get_repeat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_timer_get_repeat_struct_inst.expectedCalls; opmock_i++) {
        uv_timer_get_repeat_struct_inst.calls[opmock_i - 1] = uv_timer_get_repeat_struct_inst.calls[opmock_i];
    }

    uv_timer_get_repeat_struct_inst.expectedCalls--;
    return default_res;
}

void uv_timer_get_repeat_MockReset()
{
    uv_timer_get_repeat_struct_inst.expectedCalls = 0;
    uv_timer_get_repeat_struct_inst.actualCalls = 0;
    uv_timer_get_repeat_struct_inst.callback = NULL;
}

void uv_timer_get_repeat_MockWithCallback(OPMOCK_uv_timer_get_repeat_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_timer_get_repeat_struct_inst.callback = callback;
    uv_timer_get_repeat_struct_inst.expectedCalls = 0;
    uv_timer_get_repeat_struct_inst.actualCalls = 0;
}

void uv_timer_get_repeat_VerifyMock()
{
    if (uv_timer_get_repeat_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_timer_get_repeat'",uv_timer_get_repeat_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_timer_get_repeat_ExpectAndReturn (const uv_timer_t * handle, uint64_t to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_timer_get_repeat_struct_inst.callback != NULL)
    {
        uv_timer_get_repeat_MockReset ();
    }

    if(uv_timer_get_repeat_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_timer_get_repeat_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uint64_t uv_timer_get_repeat (const uv_timer_t * handle)");
    uv_timer_get_repeat_struct_inst.calls[uv_timer_get_repeat_struct_inst.expectedCalls].handle = (void *)handle;
    uv_timer_get_repeat_struct_inst.calls[uv_timer_get_repeat_struct_inst.expectedCalls].match_handle = match_handle;
    uv_timer_get_repeat_struct_inst.calls[uv_timer_get_repeat_struct_inst.expectedCalls].to_return = (unsigned long long) to_return;
    uv_timer_get_repeat_struct_inst.calls[uv_timer_get_repeat_struct_inst.expectedCalls].check_params = 1;
    uv_timer_get_repeat_struct_inst.expectedCalls++;
}

int uv_getaddrinfo(uv_loop_t * loop, uv_getaddrinfo_t * req, uv_getaddrinfo_cb getaddrinfo_cb, const char * node, const char * service, const struct addrinfo * hints)
{
    int default_res = (int)uv_getaddrinfo_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_getaddrinfo_struct_inst.actualCalls++;

    if (uv_getaddrinfo_struct_inst.callback != NULL)
    {
        return uv_getaddrinfo_struct_inst.callback (loop, req, getaddrinfo_cb, node, service, hints, uv_getaddrinfo_struct_inst.actualCalls);
    }
    if (uv_getaddrinfo_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_getaddrinfo', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_getaddrinfo (uv_loop_t * loop, uv_getaddrinfo_t * req, uv_getaddrinfo_cb getaddrinfo_cb, const char * node, const char * service, const struct addrinfo * hints)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_getaddrinfo(uv_loop_t * loop, uv_getaddrinfo_t * req, uv_getaddrinfo_cb getaddrinfo_cb, const char * node, const char * service, const struct addrinfo * hints)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_getaddrinfo_struct_inst.calls[0].check_params == 1) {
        if(uv_getaddrinfo_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_getaddrinfo_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_getaddrinfo_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getaddrinfo', %s",uv_getaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getaddrinfo_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_getaddrinfo_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_getaddrinfo_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getaddrinfo', %s",uv_getaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getaddrinfo_struct_inst.calls[0].match_getaddrinfo_cb) {
            void * val1 = (void *) &uv_getaddrinfo_struct_inst.calls[0].getaddrinfo_cb;
            void * val2 = (void *) &getaddrinfo_cb;
            int match_result = uv_getaddrinfo_struct_inst.calls[0].match_getaddrinfo_cb(val1, val2, "getaddrinfo_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getaddrinfo', %s",uv_getaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getaddrinfo_struct_inst.calls[0].match_node) {
            void * val1 = (void *) &uv_getaddrinfo_struct_inst.calls[0].node;
            void * val2 = (void *) &node;
            int match_result = uv_getaddrinfo_struct_inst.calls[0].match_node(val1, val2, "node", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getaddrinfo', %s",uv_getaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getaddrinfo_struct_inst.calls[0].match_service) {
            void * val1 = (void *) &uv_getaddrinfo_struct_inst.calls[0].service;
            void * val2 = (void *) &service;
            int match_result = uv_getaddrinfo_struct_inst.calls[0].match_service(val1, val2, "service", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getaddrinfo', %s",uv_getaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getaddrinfo_struct_inst.calls[0].match_hints) {
            void * val1 = (void *) &uv_getaddrinfo_struct_inst.calls[0].hints;
            void * val2 = (void *) &hints;
            int match_result = uv_getaddrinfo_struct_inst.calls[0].match_hints(val1, val2, "hints", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getaddrinfo', %s",uv_getaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_getaddrinfo_struct_inst.expectedCalls; opmock_i++) {
        uv_getaddrinfo_struct_inst.calls[opmock_i - 1] = uv_getaddrinfo_struct_inst.calls[opmock_i];
    }

    uv_getaddrinfo_struct_inst.expectedCalls--;
    return default_res;
}

void uv_getaddrinfo_MockReset()
{
    uv_getaddrinfo_struct_inst.expectedCalls = 0;
    uv_getaddrinfo_struct_inst.actualCalls = 0;
    uv_getaddrinfo_struct_inst.callback = NULL;
}

void uv_getaddrinfo_MockWithCallback(OPMOCK_uv_getaddrinfo_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_getaddrinfo_struct_inst.callback = callback;
    uv_getaddrinfo_struct_inst.expectedCalls = 0;
    uv_getaddrinfo_struct_inst.actualCalls = 0;
}

void uv_getaddrinfo_VerifyMock()
{
    if (uv_getaddrinfo_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_getaddrinfo'",uv_getaddrinfo_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_getaddrinfo_ExpectAndReturn (uv_loop_t * loop, uv_getaddrinfo_t * req, uv_getaddrinfo_cb getaddrinfo_cb, const char * node, const char * service, const struct addrinfo * hints, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_getaddrinfo_cb, OPMOCK_MATCHER match_node, OPMOCK_MATCHER match_service, OPMOCK_MATCHER match_hints)
{
    if(uv_getaddrinfo_struct_inst.callback != NULL)
    {
        uv_getaddrinfo_MockReset ();
    }

    if(uv_getaddrinfo_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_getaddrinfo_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_getaddrinfo (uv_loop_t * loop, uv_getaddrinfo_t * req, uv_getaddrinfo_cb getaddrinfo_cb, const char * node, const char * service, const struct addrinfo * hints)");
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].loop = (void *)loop;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].req = (void *)req;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].getaddrinfo_cb = (void *)getaddrinfo_cb;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].node = (void *)node;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].service = (void *)service;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].hints = (void *)hints;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].match_loop = match_loop;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].match_req = match_req;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].match_getaddrinfo_cb = match_getaddrinfo_cb;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].match_node = match_node;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].match_service = match_service;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].match_hints = match_hints;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_getaddrinfo_struct_inst.calls[uv_getaddrinfo_struct_inst.expectedCalls].check_params = 1;
    uv_getaddrinfo_struct_inst.expectedCalls++;
}

void uv_freeaddrinfo(struct addrinfo * ai)
{
    int opmock_i;
    uv_freeaddrinfo_struct_inst.actualCalls++;

    if (uv_freeaddrinfo_struct_inst.callback != NULL)
    {
        uv_freeaddrinfo_struct_inst.callback (ai, uv_freeaddrinfo_struct_inst.actualCalls);
        return;
    }
    if (uv_freeaddrinfo_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_freeaddrinfo', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_freeaddrinfo (struct addrinfo * ai)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_freeaddrinfo(struct addrinfo * ai)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_freeaddrinfo_struct_inst.calls[0].check_params == 1) {
        if(uv_freeaddrinfo_struct_inst.calls[0].match_ai) {
            void * val1 = (void *) &uv_freeaddrinfo_struct_inst.calls[0].ai;
            void * val2 = (void *) &ai;
            int match_result = uv_freeaddrinfo_struct_inst.calls[0].match_ai(val1, val2, "ai", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_freeaddrinfo', %s",uv_freeaddrinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_freeaddrinfo_struct_inst.expectedCalls; opmock_i++) {
        uv_freeaddrinfo_struct_inst.calls[opmock_i - 1] = uv_freeaddrinfo_struct_inst.calls[opmock_i];
    }

    uv_freeaddrinfo_struct_inst.expectedCalls--;
}

void uv_freeaddrinfo_MockReset()
{
    uv_freeaddrinfo_struct_inst.expectedCalls = 0;
    uv_freeaddrinfo_struct_inst.actualCalls = 0;
    uv_freeaddrinfo_struct_inst.callback = NULL;
}

void uv_freeaddrinfo_MockWithCallback(OPMOCK_uv_freeaddrinfo_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_freeaddrinfo_struct_inst.callback = callback;
    uv_freeaddrinfo_struct_inst.expectedCalls = 0;
    uv_freeaddrinfo_struct_inst.actualCalls = 0;
}

void uv_freeaddrinfo_VerifyMock()
{
    if (uv_freeaddrinfo_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_freeaddrinfo'",uv_freeaddrinfo_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_freeaddrinfo_ExpectAndReturn (struct addrinfo * ai, OPMOCK_MATCHER match_ai)
{
    if(uv_freeaddrinfo_struct_inst.callback != NULL)
    {
        uv_freeaddrinfo_MockReset ();
    }

    if(uv_freeaddrinfo_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_freeaddrinfo_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_freeaddrinfo (struct addrinfo * ai)");
    uv_freeaddrinfo_struct_inst.calls[uv_freeaddrinfo_struct_inst.expectedCalls].ai = (void *)ai;
    uv_freeaddrinfo_struct_inst.calls[uv_freeaddrinfo_struct_inst.expectedCalls].match_ai = match_ai;
    uv_freeaddrinfo_struct_inst.calls[uv_freeaddrinfo_struct_inst.expectedCalls].check_params = 1;
    uv_freeaddrinfo_struct_inst.expectedCalls++;
}

int uv_getnameinfo(uv_loop_t * loop, uv_getnameinfo_t * req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr * addr, int flags)
{
    int default_res = (int)uv_getnameinfo_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_getnameinfo_struct_inst.actualCalls++;

    if (uv_getnameinfo_struct_inst.callback != NULL)
    {
        return uv_getnameinfo_struct_inst.callback (loop, req, getnameinfo_cb, addr, flags, uv_getnameinfo_struct_inst.actualCalls);
    }
    if (uv_getnameinfo_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_getnameinfo', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_getnameinfo (uv_loop_t * loop, uv_getnameinfo_t * req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr * addr, int flags)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_getnameinfo(uv_loop_t * loop, uv_getnameinfo_t * req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr * addr, int flags)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_getnameinfo_struct_inst.calls[0].check_params == 1) {
        if(uv_getnameinfo_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_getnameinfo_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_getnameinfo_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getnameinfo', %s",uv_getnameinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getnameinfo_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_getnameinfo_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_getnameinfo_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getnameinfo', %s",uv_getnameinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getnameinfo_struct_inst.calls[0].match_getnameinfo_cb) {
            void * val1 = (void *) &uv_getnameinfo_struct_inst.calls[0].getnameinfo_cb;
            void * val2 = (void *) &getnameinfo_cb;
            int match_result = uv_getnameinfo_struct_inst.calls[0].match_getnameinfo_cb(val1, val2, "getnameinfo_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getnameinfo', %s",uv_getnameinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getnameinfo_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_getnameinfo_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_getnameinfo_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getnameinfo', %s",uv_getnameinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_getnameinfo_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_getnameinfo_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_getnameinfo_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getnameinfo', %s",uv_getnameinfo_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_getnameinfo_struct_inst.expectedCalls; opmock_i++) {
        uv_getnameinfo_struct_inst.calls[opmock_i - 1] = uv_getnameinfo_struct_inst.calls[opmock_i];
    }

    uv_getnameinfo_struct_inst.expectedCalls--;
    return default_res;
}

void uv_getnameinfo_MockReset()
{
    uv_getnameinfo_struct_inst.expectedCalls = 0;
    uv_getnameinfo_struct_inst.actualCalls = 0;
    uv_getnameinfo_struct_inst.callback = NULL;
}

void uv_getnameinfo_MockWithCallback(OPMOCK_uv_getnameinfo_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_getnameinfo_struct_inst.callback = callback;
    uv_getnameinfo_struct_inst.expectedCalls = 0;
    uv_getnameinfo_struct_inst.actualCalls = 0;
}

void uv_getnameinfo_VerifyMock()
{
    if (uv_getnameinfo_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_getnameinfo'",uv_getnameinfo_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_getnameinfo_ExpectAndReturn (uv_loop_t * loop, uv_getnameinfo_t * req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr * addr, int flags, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_getnameinfo_cb, OPMOCK_MATCHER match_addr, OPMOCK_MATCHER match_flags)
{
    if(uv_getnameinfo_struct_inst.callback != NULL)
    {
        uv_getnameinfo_MockReset ();
    }

    if(uv_getnameinfo_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_getnameinfo_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_getnameinfo (uv_loop_t * loop, uv_getnameinfo_t * req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr * addr, int flags)");
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].loop = (void *)loop;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].req = (void *)req;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].getnameinfo_cb = (void *)getnameinfo_cb;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].addr = (void *)addr;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].flags = (int)flags;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].match_loop = match_loop;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].match_req = match_req;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].match_getnameinfo_cb = match_getnameinfo_cb;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].match_addr = match_addr;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].match_flags = match_flags;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_getnameinfo_struct_inst.calls[uv_getnameinfo_struct_inst.expectedCalls].check_params = 1;
    uv_getnameinfo_struct_inst.expectedCalls++;
}

int uv_spawn(uv_loop_t * loop, uv_process_t * handle, const uv_process_options_t * options)
{
    int default_res = (int)uv_spawn_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_spawn_struct_inst.actualCalls++;

    if (uv_spawn_struct_inst.callback != NULL)
    {
        return uv_spawn_struct_inst.callback (loop, handle, options, uv_spawn_struct_inst.actualCalls);
    }
    if (uv_spawn_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_spawn', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_spawn (uv_loop_t * loop, uv_process_t * handle, const uv_process_options_t * options)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_spawn(uv_loop_t * loop, uv_process_t * handle, const uv_process_options_t * options)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_spawn_struct_inst.calls[0].check_params == 1) {
        if(uv_spawn_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_spawn_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_spawn_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_spawn', %s",uv_spawn_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_spawn_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_spawn_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_spawn_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_spawn', %s",uv_spawn_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_spawn_struct_inst.calls[0].match_options) {
            void * val1 = (void *) &uv_spawn_struct_inst.calls[0].options;
            void * val2 = (void *) &options;
            int match_result = uv_spawn_struct_inst.calls[0].match_options(val1, val2, "options", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_spawn', %s",uv_spawn_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_spawn_struct_inst.expectedCalls; opmock_i++) {
        uv_spawn_struct_inst.calls[opmock_i - 1] = uv_spawn_struct_inst.calls[opmock_i];
    }

    uv_spawn_struct_inst.expectedCalls--;
    return default_res;
}

void uv_spawn_MockReset()
{
    uv_spawn_struct_inst.expectedCalls = 0;
    uv_spawn_struct_inst.actualCalls = 0;
    uv_spawn_struct_inst.callback = NULL;
}

void uv_spawn_MockWithCallback(OPMOCK_uv_spawn_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_spawn_struct_inst.callback = callback;
    uv_spawn_struct_inst.expectedCalls = 0;
    uv_spawn_struct_inst.actualCalls = 0;
}

void uv_spawn_VerifyMock()
{
    if (uv_spawn_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_spawn'",uv_spawn_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_spawn_ExpectAndReturn (uv_loop_t * loop, uv_process_t * handle, const uv_process_options_t * options, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_options)
{
    if(uv_spawn_struct_inst.callback != NULL)
    {
        uv_spawn_MockReset ();
    }

    if(uv_spawn_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_spawn_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_spawn (uv_loop_t * loop, uv_process_t * handle, const uv_process_options_t * options)");
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].loop = (void *)loop;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].handle = (void *)handle;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].options = (void *)options;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].match_loop = match_loop;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].match_handle = match_handle;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].match_options = match_options;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_spawn_struct_inst.calls[uv_spawn_struct_inst.expectedCalls].check_params = 1;
    uv_spawn_struct_inst.expectedCalls++;
}

int uv_process_kill(uv_process_t * arg1, int signum)
{
    int default_res = (int)uv_process_kill_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_process_kill_struct_inst.actualCalls++;

    if (uv_process_kill_struct_inst.callback != NULL)
    {
        return uv_process_kill_struct_inst.callback (arg1, signum, uv_process_kill_struct_inst.actualCalls);
    }
    if (uv_process_kill_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_process_kill', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_process_kill (uv_process_t * arg1, int signum)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_process_kill(uv_process_t * arg1, int signum)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_process_kill_struct_inst.calls[0].check_params == 1) {
        if(uv_process_kill_struct_inst.calls[0].match_arg1) {
            void * val1 = (void *) &uv_process_kill_struct_inst.calls[0].arg1;
            void * val2 = (void *) &arg1;
            int match_result = uv_process_kill_struct_inst.calls[0].match_arg1(val1, val2, "arg1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_process_kill', %s",uv_process_kill_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_process_kill_struct_inst.calls[0].match_signum) {
            void * val1 = (void *) &uv_process_kill_struct_inst.calls[0].signum;
            void * val2 = (void *) &signum;
            int match_result = uv_process_kill_struct_inst.calls[0].match_signum(val1, val2, "signum", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_process_kill', %s",uv_process_kill_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_process_kill_struct_inst.expectedCalls; opmock_i++) {
        uv_process_kill_struct_inst.calls[opmock_i - 1] = uv_process_kill_struct_inst.calls[opmock_i];
    }

    uv_process_kill_struct_inst.expectedCalls--;
    return default_res;
}

void uv_process_kill_MockReset()
{
    uv_process_kill_struct_inst.expectedCalls = 0;
    uv_process_kill_struct_inst.actualCalls = 0;
    uv_process_kill_struct_inst.callback = NULL;
}

void uv_process_kill_MockWithCallback(OPMOCK_uv_process_kill_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_process_kill_struct_inst.callback = callback;
    uv_process_kill_struct_inst.expectedCalls = 0;
    uv_process_kill_struct_inst.actualCalls = 0;
}

void uv_process_kill_VerifyMock()
{
    if (uv_process_kill_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_process_kill'",uv_process_kill_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_process_kill_ExpectAndReturn (uv_process_t * arg1, int signum, int to_return, OPMOCK_MATCHER match_arg1, OPMOCK_MATCHER match_signum)
{
    if(uv_process_kill_struct_inst.callback != NULL)
    {
        uv_process_kill_MockReset ();
    }

    if(uv_process_kill_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_process_kill_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_process_kill (uv_process_t * arg1, int signum)");
    uv_process_kill_struct_inst.calls[uv_process_kill_struct_inst.expectedCalls].arg1 = (void *)arg1;
    uv_process_kill_struct_inst.calls[uv_process_kill_struct_inst.expectedCalls].signum = (int)signum;
    uv_process_kill_struct_inst.calls[uv_process_kill_struct_inst.expectedCalls].match_arg1 = match_arg1;
    uv_process_kill_struct_inst.calls[uv_process_kill_struct_inst.expectedCalls].match_signum = match_signum;
    uv_process_kill_struct_inst.calls[uv_process_kill_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_process_kill_struct_inst.calls[uv_process_kill_struct_inst.expectedCalls].check_params = 1;
    uv_process_kill_struct_inst.expectedCalls++;
}

int uv_kill(int pid, int signum)
{
    int default_res = (int)uv_kill_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_kill_struct_inst.actualCalls++;

    if (uv_kill_struct_inst.callback != NULL)
    {
        return uv_kill_struct_inst.callback (pid, signum, uv_kill_struct_inst.actualCalls);
    }
    if (uv_kill_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_kill', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_kill (int pid, int signum)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_kill(int pid, int signum)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_kill_struct_inst.calls[0].check_params == 1) {
        if(uv_kill_struct_inst.calls[0].match_pid) {
            void * val1 = (void *) &uv_kill_struct_inst.calls[0].pid;
            void * val2 = (void *) &pid;
            int match_result = uv_kill_struct_inst.calls[0].match_pid(val1, val2, "pid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_kill', %s",uv_kill_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_kill_struct_inst.calls[0].match_signum) {
            void * val1 = (void *) &uv_kill_struct_inst.calls[0].signum;
            void * val2 = (void *) &signum;
            int match_result = uv_kill_struct_inst.calls[0].match_signum(val1, val2, "signum", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_kill', %s",uv_kill_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_kill_struct_inst.expectedCalls; opmock_i++) {
        uv_kill_struct_inst.calls[opmock_i - 1] = uv_kill_struct_inst.calls[opmock_i];
    }

    uv_kill_struct_inst.expectedCalls--;
    return default_res;
}

void uv_kill_MockReset()
{
    uv_kill_struct_inst.expectedCalls = 0;
    uv_kill_struct_inst.actualCalls = 0;
    uv_kill_struct_inst.callback = NULL;
}

void uv_kill_MockWithCallback(OPMOCK_uv_kill_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_kill_struct_inst.callback = callback;
    uv_kill_struct_inst.expectedCalls = 0;
    uv_kill_struct_inst.actualCalls = 0;
}

void uv_kill_VerifyMock()
{
    if (uv_kill_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_kill'",uv_kill_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_kill_ExpectAndReturn (int pid, int signum, int to_return, OPMOCK_MATCHER match_pid, OPMOCK_MATCHER match_signum)
{
    if(uv_kill_struct_inst.callback != NULL)
    {
        uv_kill_MockReset ();
    }

    if(uv_kill_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_kill_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_kill (int pid, int signum)");
    uv_kill_struct_inst.calls[uv_kill_struct_inst.expectedCalls].pid = (int)pid;
    uv_kill_struct_inst.calls[uv_kill_struct_inst.expectedCalls].signum = (int)signum;
    uv_kill_struct_inst.calls[uv_kill_struct_inst.expectedCalls].match_pid = match_pid;
    uv_kill_struct_inst.calls[uv_kill_struct_inst.expectedCalls].match_signum = match_signum;
    uv_kill_struct_inst.calls[uv_kill_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_kill_struct_inst.calls[uv_kill_struct_inst.expectedCalls].check_params = 1;
    uv_kill_struct_inst.expectedCalls++;
}

int uv_queue_work(uv_loop_t * loop, uv_work_t * req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)
{
    int default_res = (int)uv_queue_work_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_queue_work_struct_inst.actualCalls++;

    if (uv_queue_work_struct_inst.callback != NULL)
    {
        return uv_queue_work_struct_inst.callback (loop, req, work_cb, after_work_cb, uv_queue_work_struct_inst.actualCalls);
    }
    if (uv_queue_work_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_queue_work', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_queue_work (uv_loop_t * loop, uv_work_t * req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_queue_work(uv_loop_t * loop, uv_work_t * req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_queue_work_struct_inst.calls[0].check_params == 1) {
        if(uv_queue_work_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_queue_work_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_queue_work_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_queue_work', %s",uv_queue_work_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_queue_work_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_queue_work_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_queue_work_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_queue_work', %s",uv_queue_work_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_queue_work_struct_inst.calls[0].match_work_cb) {
            void * val1 = (void *) &uv_queue_work_struct_inst.calls[0].work_cb;
            void * val2 = (void *) &work_cb;
            int match_result = uv_queue_work_struct_inst.calls[0].match_work_cb(val1, val2, "work_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_queue_work', %s",uv_queue_work_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_queue_work_struct_inst.calls[0].match_after_work_cb) {
            void * val1 = (void *) &uv_queue_work_struct_inst.calls[0].after_work_cb;
            void * val2 = (void *) &after_work_cb;
            int match_result = uv_queue_work_struct_inst.calls[0].match_after_work_cb(val1, val2, "after_work_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_queue_work', %s",uv_queue_work_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_queue_work_struct_inst.expectedCalls; opmock_i++) {
        uv_queue_work_struct_inst.calls[opmock_i - 1] = uv_queue_work_struct_inst.calls[opmock_i];
    }

    uv_queue_work_struct_inst.expectedCalls--;
    return default_res;
}

void uv_queue_work_MockReset()
{
    uv_queue_work_struct_inst.expectedCalls = 0;
    uv_queue_work_struct_inst.actualCalls = 0;
    uv_queue_work_struct_inst.callback = NULL;
}

void uv_queue_work_MockWithCallback(OPMOCK_uv_queue_work_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_queue_work_struct_inst.callback = callback;
    uv_queue_work_struct_inst.expectedCalls = 0;
    uv_queue_work_struct_inst.actualCalls = 0;
}

void uv_queue_work_VerifyMock()
{
    if (uv_queue_work_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_queue_work'",uv_queue_work_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_queue_work_ExpectAndReturn (uv_loop_t * loop, uv_work_t * req, uv_work_cb work_cb, uv_after_work_cb after_work_cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_work_cb, OPMOCK_MATCHER match_after_work_cb)
{
    if(uv_queue_work_struct_inst.callback != NULL)
    {
        uv_queue_work_MockReset ();
    }

    if(uv_queue_work_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_queue_work_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_queue_work (uv_loop_t * loop, uv_work_t * req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)");
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].loop = (void *)loop;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].req = (void *)req;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].work_cb = (void *)work_cb;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].after_work_cb = (void *)after_work_cb;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].match_loop = match_loop;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].match_req = match_req;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].match_work_cb = match_work_cb;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].match_after_work_cb = match_after_work_cb;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_queue_work_struct_inst.calls[uv_queue_work_struct_inst.expectedCalls].check_params = 1;
    uv_queue_work_struct_inst.expectedCalls++;
}

int uv_cancel(uv_req_t * req)
{
    int default_res = (int)uv_cancel_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_cancel_struct_inst.actualCalls++;

    if (uv_cancel_struct_inst.callback != NULL)
    {
        return uv_cancel_struct_inst.callback (req, uv_cancel_struct_inst.actualCalls);
    }
    if (uv_cancel_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cancel', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_cancel (uv_req_t * req)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_cancel(uv_req_t * req)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cancel_struct_inst.calls[0].check_params == 1) {
        if(uv_cancel_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_cancel_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_cancel_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cancel', %s",uv_cancel_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cancel_struct_inst.expectedCalls; opmock_i++) {
        uv_cancel_struct_inst.calls[opmock_i - 1] = uv_cancel_struct_inst.calls[opmock_i];
    }

    uv_cancel_struct_inst.expectedCalls--;
    return default_res;
}

void uv_cancel_MockReset()
{
    uv_cancel_struct_inst.expectedCalls = 0;
    uv_cancel_struct_inst.actualCalls = 0;
    uv_cancel_struct_inst.callback = NULL;
}

void uv_cancel_MockWithCallback(OPMOCK_uv_cancel_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cancel_struct_inst.callback = callback;
    uv_cancel_struct_inst.expectedCalls = 0;
    uv_cancel_struct_inst.actualCalls = 0;
}

void uv_cancel_VerifyMock()
{
    if (uv_cancel_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cancel'",uv_cancel_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cancel_ExpectAndReturn (uv_req_t * req, int to_return, OPMOCK_MATCHER match_req)
{
    if(uv_cancel_struct_inst.callback != NULL)
    {
        uv_cancel_MockReset ();
    }

    if(uv_cancel_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cancel_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_cancel (uv_req_t * req)");
    uv_cancel_struct_inst.calls[uv_cancel_struct_inst.expectedCalls].req = (void *)req;
    uv_cancel_struct_inst.calls[uv_cancel_struct_inst.expectedCalls].match_req = match_req;
    uv_cancel_struct_inst.calls[uv_cancel_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_cancel_struct_inst.calls[uv_cancel_struct_inst.expectedCalls].check_params = 1;
    uv_cancel_struct_inst.expectedCalls++;
}

char ** uv_setup_args(int argc, char ** argv)
{
    char ** default_res = (char **)uv_setup_args_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_setup_args_struct_inst.actualCalls++;

    if (uv_setup_args_struct_inst.callback != NULL)
    {
        return uv_setup_args_struct_inst.callback (argc, argv, uv_setup_args_struct_inst.actualCalls);
    }
    if (uv_setup_args_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_setup_args', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "char ** uv_setup_args (int argc, char ** argv)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'char ** uv_setup_args(int argc, char ** argv)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_setup_args_struct_inst.calls[0].check_params == 1) {
        if(uv_setup_args_struct_inst.calls[0].match_argc) {
            void * val1 = (void *) &uv_setup_args_struct_inst.calls[0].argc;
            void * val2 = (void *) &argc;
            int match_result = uv_setup_args_struct_inst.calls[0].match_argc(val1, val2, "argc", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_setup_args', %s",uv_setup_args_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_setup_args_struct_inst.calls[0].match_argv) {
            void * val1 = (void *) &uv_setup_args_struct_inst.calls[0].argv;
            void * val2 = (void *) &argv;
            int match_result = uv_setup_args_struct_inst.calls[0].match_argv(val1, val2, "argv", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_setup_args', %s",uv_setup_args_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_setup_args_struct_inst.expectedCalls; opmock_i++) {
        uv_setup_args_struct_inst.calls[opmock_i - 1] = uv_setup_args_struct_inst.calls[opmock_i];
    }

    uv_setup_args_struct_inst.expectedCalls--;
    return default_res;
}

void uv_setup_args_MockReset()
{
    uv_setup_args_struct_inst.expectedCalls = 0;
    uv_setup_args_struct_inst.actualCalls = 0;
    uv_setup_args_struct_inst.callback = NULL;
}

void uv_setup_args_MockWithCallback(OPMOCK_uv_setup_args_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_setup_args_struct_inst.callback = callback;
    uv_setup_args_struct_inst.expectedCalls = 0;
    uv_setup_args_struct_inst.actualCalls = 0;
}

void uv_setup_args_VerifyMock()
{
    if (uv_setup_args_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_setup_args'",uv_setup_args_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_setup_args_ExpectAndReturn (int argc, char ** argv, char ** to_return, OPMOCK_MATCHER match_argc, OPMOCK_MATCHER match_argv)
{
    if(uv_setup_args_struct_inst.callback != NULL)
    {
        uv_setup_args_MockReset ();
    }

    if(uv_setup_args_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_setup_args_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"char ** uv_setup_args (int argc, char ** argv)");
    uv_setup_args_struct_inst.calls[uv_setup_args_struct_inst.expectedCalls].argc = (int)argc;
    uv_setup_args_struct_inst.calls[uv_setup_args_struct_inst.expectedCalls].argv = (void *)argv;
    uv_setup_args_struct_inst.calls[uv_setup_args_struct_inst.expectedCalls].match_argc = match_argc;
    uv_setup_args_struct_inst.calls[uv_setup_args_struct_inst.expectedCalls].match_argv = match_argv;
    uv_setup_args_struct_inst.calls[uv_setup_args_struct_inst.expectedCalls].to_return = (char **) to_return;
    uv_setup_args_struct_inst.calls[uv_setup_args_struct_inst.expectedCalls].check_params = 1;
    uv_setup_args_struct_inst.expectedCalls++;
}

int uv_get_process_title(char * buffer, size_t size)
{
    int default_res = (int)uv_get_process_title_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_get_process_title_struct_inst.actualCalls++;

    if (uv_get_process_title_struct_inst.callback != NULL)
    {
        return uv_get_process_title_struct_inst.callback (buffer, size, uv_get_process_title_struct_inst.actualCalls);
    }
    if (uv_get_process_title_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_get_process_title', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_get_process_title (char * buffer, size_t size)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_get_process_title(char * buffer, size_t size)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_get_process_title_struct_inst.calls[0].check_params == 1) {
        if(uv_get_process_title_struct_inst.calls[0].match_buffer) {
            void * val1 = (void *) &uv_get_process_title_struct_inst.calls[0].buffer;
            void * val2 = (void *) &buffer;
            int match_result = uv_get_process_title_struct_inst.calls[0].match_buffer(val1, val2, "buffer", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_get_process_title', %s",uv_get_process_title_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_get_process_title_struct_inst.calls[0].match_size) {
            void * val1 = (void *) &uv_get_process_title_struct_inst.calls[0].size;
            void * val2 = (void *) &size;
            int match_result = uv_get_process_title_struct_inst.calls[0].match_size(val1, val2, "size", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_get_process_title', %s",uv_get_process_title_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_get_process_title_struct_inst.expectedCalls; opmock_i++) {
        uv_get_process_title_struct_inst.calls[opmock_i - 1] = uv_get_process_title_struct_inst.calls[opmock_i];
    }

    uv_get_process_title_struct_inst.expectedCalls--;
    return default_res;
}

void uv_get_process_title_MockReset()
{
    uv_get_process_title_struct_inst.expectedCalls = 0;
    uv_get_process_title_struct_inst.actualCalls = 0;
    uv_get_process_title_struct_inst.callback = NULL;
}

void uv_get_process_title_MockWithCallback(OPMOCK_uv_get_process_title_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_get_process_title_struct_inst.callback = callback;
    uv_get_process_title_struct_inst.expectedCalls = 0;
    uv_get_process_title_struct_inst.actualCalls = 0;
}

void uv_get_process_title_VerifyMock()
{
    if (uv_get_process_title_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_get_process_title'",uv_get_process_title_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_get_process_title_ExpectAndReturn (char * buffer, size_t size, int to_return, OPMOCK_MATCHER match_buffer, OPMOCK_MATCHER match_size)
{
    if(uv_get_process_title_struct_inst.callback != NULL)
    {
        uv_get_process_title_MockReset ();
    }

    if(uv_get_process_title_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_get_process_title_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_get_process_title (char * buffer, size_t size)");
    uv_get_process_title_struct_inst.calls[uv_get_process_title_struct_inst.expectedCalls].buffer = (void *)buffer;
    uv_get_process_title_struct_inst.calls[uv_get_process_title_struct_inst.expectedCalls].size = (unsigned long)size;
    uv_get_process_title_struct_inst.calls[uv_get_process_title_struct_inst.expectedCalls].match_buffer = match_buffer;
    uv_get_process_title_struct_inst.calls[uv_get_process_title_struct_inst.expectedCalls].match_size = match_size;
    uv_get_process_title_struct_inst.calls[uv_get_process_title_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_get_process_title_struct_inst.calls[uv_get_process_title_struct_inst.expectedCalls].check_params = 1;
    uv_get_process_title_struct_inst.expectedCalls++;
}

int uv_set_process_title(const char * title)
{
    int default_res = (int)uv_set_process_title_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_set_process_title_struct_inst.actualCalls++;

    if (uv_set_process_title_struct_inst.callback != NULL)
    {
        return uv_set_process_title_struct_inst.callback (title, uv_set_process_title_struct_inst.actualCalls);
    }
    if (uv_set_process_title_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_set_process_title', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_set_process_title (const char * title)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_set_process_title(const char * title)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_set_process_title_struct_inst.calls[0].check_params == 1) {
        if(uv_set_process_title_struct_inst.calls[0].match_title) {
            void * val1 = (void *) &uv_set_process_title_struct_inst.calls[0].title;
            void * val2 = (void *) &title;
            int match_result = uv_set_process_title_struct_inst.calls[0].match_title(val1, val2, "title", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_set_process_title', %s",uv_set_process_title_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_set_process_title_struct_inst.expectedCalls; opmock_i++) {
        uv_set_process_title_struct_inst.calls[opmock_i - 1] = uv_set_process_title_struct_inst.calls[opmock_i];
    }

    uv_set_process_title_struct_inst.expectedCalls--;
    return default_res;
}

void uv_set_process_title_MockReset()
{
    uv_set_process_title_struct_inst.expectedCalls = 0;
    uv_set_process_title_struct_inst.actualCalls = 0;
    uv_set_process_title_struct_inst.callback = NULL;
}

void uv_set_process_title_MockWithCallback(OPMOCK_uv_set_process_title_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_set_process_title_struct_inst.callback = callback;
    uv_set_process_title_struct_inst.expectedCalls = 0;
    uv_set_process_title_struct_inst.actualCalls = 0;
}

void uv_set_process_title_VerifyMock()
{
    if (uv_set_process_title_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_set_process_title'",uv_set_process_title_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_set_process_title_ExpectAndReturn (const char * title, int to_return, OPMOCK_MATCHER match_title)
{
    if(uv_set_process_title_struct_inst.callback != NULL)
    {
        uv_set_process_title_MockReset ();
    }

    if(uv_set_process_title_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_set_process_title_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_set_process_title (const char * title)");
    uv_set_process_title_struct_inst.calls[uv_set_process_title_struct_inst.expectedCalls].title = (void *)title;
    uv_set_process_title_struct_inst.calls[uv_set_process_title_struct_inst.expectedCalls].match_title = match_title;
    uv_set_process_title_struct_inst.calls[uv_set_process_title_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_set_process_title_struct_inst.calls[uv_set_process_title_struct_inst.expectedCalls].check_params = 1;
    uv_set_process_title_struct_inst.expectedCalls++;
}

int uv_resident_set_memory(size_t * rss)
{
    int default_res = (int)uv_resident_set_memory_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_resident_set_memory_struct_inst.actualCalls++;

    if (uv_resident_set_memory_struct_inst.callback != NULL)
    {
        return uv_resident_set_memory_struct_inst.callback (rss, uv_resident_set_memory_struct_inst.actualCalls);
    }
    if (uv_resident_set_memory_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_resident_set_memory', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_resident_set_memory (size_t * rss)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_resident_set_memory(size_t * rss)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_resident_set_memory_struct_inst.calls[0].check_params == 1) {
        if(uv_resident_set_memory_struct_inst.calls[0].match_rss) {
            void * val1 = (void *) &uv_resident_set_memory_struct_inst.calls[0].rss;
            void * val2 = (void *) &rss;
            int match_result = uv_resident_set_memory_struct_inst.calls[0].match_rss(val1, val2, "rss", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_resident_set_memory', %s",uv_resident_set_memory_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_resident_set_memory_struct_inst.expectedCalls; opmock_i++) {
        uv_resident_set_memory_struct_inst.calls[opmock_i - 1] = uv_resident_set_memory_struct_inst.calls[opmock_i];
    }

    uv_resident_set_memory_struct_inst.expectedCalls--;
    return default_res;
}

void uv_resident_set_memory_MockReset()
{
    uv_resident_set_memory_struct_inst.expectedCalls = 0;
    uv_resident_set_memory_struct_inst.actualCalls = 0;
    uv_resident_set_memory_struct_inst.callback = NULL;
}

void uv_resident_set_memory_MockWithCallback(OPMOCK_uv_resident_set_memory_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_resident_set_memory_struct_inst.callback = callback;
    uv_resident_set_memory_struct_inst.expectedCalls = 0;
    uv_resident_set_memory_struct_inst.actualCalls = 0;
}

void uv_resident_set_memory_VerifyMock()
{
    if (uv_resident_set_memory_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_resident_set_memory'",uv_resident_set_memory_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_resident_set_memory_ExpectAndReturn (size_t * rss, int to_return, OPMOCK_MATCHER match_rss)
{
    if(uv_resident_set_memory_struct_inst.callback != NULL)
    {
        uv_resident_set_memory_MockReset ();
    }

    if(uv_resident_set_memory_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_resident_set_memory_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_resident_set_memory (size_t * rss)");
    uv_resident_set_memory_struct_inst.calls[uv_resident_set_memory_struct_inst.expectedCalls].rss = (void *)rss;
    uv_resident_set_memory_struct_inst.calls[uv_resident_set_memory_struct_inst.expectedCalls].match_rss = match_rss;
    uv_resident_set_memory_struct_inst.calls[uv_resident_set_memory_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_resident_set_memory_struct_inst.calls[uv_resident_set_memory_struct_inst.expectedCalls].check_params = 1;
    uv_resident_set_memory_struct_inst.expectedCalls++;
}

int uv_uptime(double * uptime)
{
    int default_res = (int)uv_uptime_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_uptime_struct_inst.actualCalls++;

    if (uv_uptime_struct_inst.callback != NULL)
    {
        return uv_uptime_struct_inst.callback (uptime, uv_uptime_struct_inst.actualCalls);
    }
    if (uv_uptime_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_uptime', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_uptime (double * uptime)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_uptime(double * uptime)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_uptime_struct_inst.calls[0].check_params == 1) {
        if(uv_uptime_struct_inst.calls[0].match_uptime) {
            void * val1 = (void *) &uv_uptime_struct_inst.calls[0].uptime;
            void * val2 = (void *) &uptime;
            int match_result = uv_uptime_struct_inst.calls[0].match_uptime(val1, val2, "uptime", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_uptime', %s",uv_uptime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_uptime_struct_inst.expectedCalls; opmock_i++) {
        uv_uptime_struct_inst.calls[opmock_i - 1] = uv_uptime_struct_inst.calls[opmock_i];
    }

    uv_uptime_struct_inst.expectedCalls--;
    return default_res;
}

void uv_uptime_MockReset()
{
    uv_uptime_struct_inst.expectedCalls = 0;
    uv_uptime_struct_inst.actualCalls = 0;
    uv_uptime_struct_inst.callback = NULL;
}

void uv_uptime_MockWithCallback(OPMOCK_uv_uptime_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_uptime_struct_inst.callback = callback;
    uv_uptime_struct_inst.expectedCalls = 0;
    uv_uptime_struct_inst.actualCalls = 0;
}

void uv_uptime_VerifyMock()
{
    if (uv_uptime_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_uptime'",uv_uptime_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_uptime_ExpectAndReturn (double * uptime, int to_return, OPMOCK_MATCHER match_uptime)
{
    if(uv_uptime_struct_inst.callback != NULL)
    {
        uv_uptime_MockReset ();
    }

    if(uv_uptime_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_uptime_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_uptime (double * uptime)");
    uv_uptime_struct_inst.calls[uv_uptime_struct_inst.expectedCalls].uptime = (void *)uptime;
    uv_uptime_struct_inst.calls[uv_uptime_struct_inst.expectedCalls].match_uptime = match_uptime;
    uv_uptime_struct_inst.calls[uv_uptime_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_uptime_struct_inst.calls[uv_uptime_struct_inst.expectedCalls].check_params = 1;
    uv_uptime_struct_inst.expectedCalls++;
}

int uv_getrusage(uv_rusage_t * rusage)
{
    int default_res = (int)uv_getrusage_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_getrusage_struct_inst.actualCalls++;

    if (uv_getrusage_struct_inst.callback != NULL)
    {
        return uv_getrusage_struct_inst.callback (rusage, uv_getrusage_struct_inst.actualCalls);
    }
    if (uv_getrusage_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_getrusage', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_getrusage (uv_rusage_t * rusage)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_getrusage(uv_rusage_t * rusage)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_getrusage_struct_inst.calls[0].check_params == 1) {
        if(uv_getrusage_struct_inst.calls[0].match_rusage) {
            void * val1 = (void *) &uv_getrusage_struct_inst.calls[0].rusage;
            void * val2 = (void *) &rusage;
            int match_result = uv_getrusage_struct_inst.calls[0].match_rusage(val1, val2, "rusage", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_getrusage', %s",uv_getrusage_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_getrusage_struct_inst.expectedCalls; opmock_i++) {
        uv_getrusage_struct_inst.calls[opmock_i - 1] = uv_getrusage_struct_inst.calls[opmock_i];
    }

    uv_getrusage_struct_inst.expectedCalls--;
    return default_res;
}

void uv_getrusage_MockReset()
{
    uv_getrusage_struct_inst.expectedCalls = 0;
    uv_getrusage_struct_inst.actualCalls = 0;
    uv_getrusage_struct_inst.callback = NULL;
}

void uv_getrusage_MockWithCallback(OPMOCK_uv_getrusage_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_getrusage_struct_inst.callback = callback;
    uv_getrusage_struct_inst.expectedCalls = 0;
    uv_getrusage_struct_inst.actualCalls = 0;
}

void uv_getrusage_VerifyMock()
{
    if (uv_getrusage_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_getrusage'",uv_getrusage_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_getrusage_ExpectAndReturn (uv_rusage_t * rusage, int to_return, OPMOCK_MATCHER match_rusage)
{
    if(uv_getrusage_struct_inst.callback != NULL)
    {
        uv_getrusage_MockReset ();
    }

    if(uv_getrusage_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_getrusage_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_getrusage (uv_rusage_t * rusage)");
    uv_getrusage_struct_inst.calls[uv_getrusage_struct_inst.expectedCalls].rusage = (void *)rusage;
    uv_getrusage_struct_inst.calls[uv_getrusage_struct_inst.expectedCalls].match_rusage = match_rusage;
    uv_getrusage_struct_inst.calls[uv_getrusage_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_getrusage_struct_inst.calls[uv_getrusage_struct_inst.expectedCalls].check_params = 1;
    uv_getrusage_struct_inst.expectedCalls++;
}

int uv_cpu_info(uv_cpu_info_t ** cpu_infos, int * count)
{
    int default_res = (int)uv_cpu_info_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_cpu_info_struct_inst.actualCalls++;

    if (uv_cpu_info_struct_inst.callback != NULL)
    {
        return uv_cpu_info_struct_inst.callback (cpu_infos, count, uv_cpu_info_struct_inst.actualCalls);
    }
    if (uv_cpu_info_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cpu_info', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_cpu_info (uv_cpu_info_t ** cpu_infos, int * count)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_cpu_info(uv_cpu_info_t ** cpu_infos, int * count)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cpu_info_struct_inst.calls[0].check_params == 1) {
        if(uv_cpu_info_struct_inst.calls[0].match_cpu_infos) {
            void * val1 = (void *) &uv_cpu_info_struct_inst.calls[0].cpu_infos;
            void * val2 = (void *) &cpu_infos;
            int match_result = uv_cpu_info_struct_inst.calls[0].match_cpu_infos(val1, val2, "cpu_infos", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cpu_info', %s",uv_cpu_info_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_cpu_info_struct_inst.calls[0].match_count) {
            void * val1 = (void *) &uv_cpu_info_struct_inst.calls[0].count;
            void * val2 = (void *) &count;
            int match_result = uv_cpu_info_struct_inst.calls[0].match_count(val1, val2, "count", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cpu_info', %s",uv_cpu_info_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cpu_info_struct_inst.expectedCalls; opmock_i++) {
        uv_cpu_info_struct_inst.calls[opmock_i - 1] = uv_cpu_info_struct_inst.calls[opmock_i];
    }

    uv_cpu_info_struct_inst.expectedCalls--;
    return default_res;
}

void uv_cpu_info_MockReset()
{
    uv_cpu_info_struct_inst.expectedCalls = 0;
    uv_cpu_info_struct_inst.actualCalls = 0;
    uv_cpu_info_struct_inst.callback = NULL;
}

void uv_cpu_info_MockWithCallback(OPMOCK_uv_cpu_info_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cpu_info_struct_inst.callback = callback;
    uv_cpu_info_struct_inst.expectedCalls = 0;
    uv_cpu_info_struct_inst.actualCalls = 0;
}

void uv_cpu_info_VerifyMock()
{
    if (uv_cpu_info_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cpu_info'",uv_cpu_info_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cpu_info_ExpectAndReturn (uv_cpu_info_t ** cpu_infos, int * count, int to_return, OPMOCK_MATCHER match_cpu_infos, OPMOCK_MATCHER match_count)
{
    if(uv_cpu_info_struct_inst.callback != NULL)
    {
        uv_cpu_info_MockReset ();
    }

    if(uv_cpu_info_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cpu_info_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_cpu_info (uv_cpu_info_t ** cpu_infos, int * count)");
    uv_cpu_info_struct_inst.calls[uv_cpu_info_struct_inst.expectedCalls].cpu_infos = (void *)cpu_infos;
    uv_cpu_info_struct_inst.calls[uv_cpu_info_struct_inst.expectedCalls].count = (void *)count;
    uv_cpu_info_struct_inst.calls[uv_cpu_info_struct_inst.expectedCalls].match_cpu_infos = match_cpu_infos;
    uv_cpu_info_struct_inst.calls[uv_cpu_info_struct_inst.expectedCalls].match_count = match_count;
    uv_cpu_info_struct_inst.calls[uv_cpu_info_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_cpu_info_struct_inst.calls[uv_cpu_info_struct_inst.expectedCalls].check_params = 1;
    uv_cpu_info_struct_inst.expectedCalls++;
}

void uv_free_cpu_info(uv_cpu_info_t * cpu_infos, int count)
{
    int opmock_i;
    uv_free_cpu_info_struct_inst.actualCalls++;

    if (uv_free_cpu_info_struct_inst.callback != NULL)
    {
        uv_free_cpu_info_struct_inst.callback (cpu_infos, count, uv_free_cpu_info_struct_inst.actualCalls);
        return;
    }
    if (uv_free_cpu_info_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_free_cpu_info', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_free_cpu_info (uv_cpu_info_t * cpu_infos, int count)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_free_cpu_info(uv_cpu_info_t * cpu_infos, int count)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_free_cpu_info_struct_inst.calls[0].check_params == 1) {
        if(uv_free_cpu_info_struct_inst.calls[0].match_cpu_infos) {
            void * val1 = (void *) &uv_free_cpu_info_struct_inst.calls[0].cpu_infos;
            void * val2 = (void *) &cpu_infos;
            int match_result = uv_free_cpu_info_struct_inst.calls[0].match_cpu_infos(val1, val2, "cpu_infos", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_free_cpu_info', %s",uv_free_cpu_info_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_free_cpu_info_struct_inst.calls[0].match_count) {
            void * val1 = (void *) &uv_free_cpu_info_struct_inst.calls[0].count;
            void * val2 = (void *) &count;
            int match_result = uv_free_cpu_info_struct_inst.calls[0].match_count(val1, val2, "count", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_free_cpu_info', %s",uv_free_cpu_info_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_free_cpu_info_struct_inst.expectedCalls; opmock_i++) {
        uv_free_cpu_info_struct_inst.calls[opmock_i - 1] = uv_free_cpu_info_struct_inst.calls[opmock_i];
    }

    uv_free_cpu_info_struct_inst.expectedCalls--;
}

void uv_free_cpu_info_MockReset()
{
    uv_free_cpu_info_struct_inst.expectedCalls = 0;
    uv_free_cpu_info_struct_inst.actualCalls = 0;
    uv_free_cpu_info_struct_inst.callback = NULL;
}

void uv_free_cpu_info_MockWithCallback(OPMOCK_uv_free_cpu_info_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_free_cpu_info_struct_inst.callback = callback;
    uv_free_cpu_info_struct_inst.expectedCalls = 0;
    uv_free_cpu_info_struct_inst.actualCalls = 0;
}

void uv_free_cpu_info_VerifyMock()
{
    if (uv_free_cpu_info_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_free_cpu_info'",uv_free_cpu_info_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_free_cpu_info_ExpectAndReturn (uv_cpu_info_t * cpu_infos, int count, OPMOCK_MATCHER match_cpu_infos, OPMOCK_MATCHER match_count)
{
    if(uv_free_cpu_info_struct_inst.callback != NULL)
    {
        uv_free_cpu_info_MockReset ();
    }

    if(uv_free_cpu_info_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_free_cpu_info_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_free_cpu_info (uv_cpu_info_t * cpu_infos, int count)");
    uv_free_cpu_info_struct_inst.calls[uv_free_cpu_info_struct_inst.expectedCalls].cpu_infos = (void *)cpu_infos;
    uv_free_cpu_info_struct_inst.calls[uv_free_cpu_info_struct_inst.expectedCalls].count = (int)count;
    uv_free_cpu_info_struct_inst.calls[uv_free_cpu_info_struct_inst.expectedCalls].match_cpu_infos = match_cpu_infos;
    uv_free_cpu_info_struct_inst.calls[uv_free_cpu_info_struct_inst.expectedCalls].match_count = match_count;
    uv_free_cpu_info_struct_inst.calls[uv_free_cpu_info_struct_inst.expectedCalls].check_params = 1;
    uv_free_cpu_info_struct_inst.expectedCalls++;
}

int uv_interface_addresses(uv_interface_address_t ** addresses, int * count)
{
    int default_res = (int)uv_interface_addresses_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_interface_addresses_struct_inst.actualCalls++;

    if (uv_interface_addresses_struct_inst.callback != NULL)
    {
        return uv_interface_addresses_struct_inst.callback (addresses, count, uv_interface_addresses_struct_inst.actualCalls);
    }
    if (uv_interface_addresses_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_interface_addresses', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_interface_addresses (uv_interface_address_t ** addresses, int * count)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_interface_addresses(uv_interface_address_t ** addresses, int * count)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_interface_addresses_struct_inst.calls[0].check_params == 1) {
        if(uv_interface_addresses_struct_inst.calls[0].match_addresses) {
            void * val1 = (void *) &uv_interface_addresses_struct_inst.calls[0].addresses;
            void * val2 = (void *) &addresses;
            int match_result = uv_interface_addresses_struct_inst.calls[0].match_addresses(val1, val2, "addresses", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_interface_addresses', %s",uv_interface_addresses_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_interface_addresses_struct_inst.calls[0].match_count) {
            void * val1 = (void *) &uv_interface_addresses_struct_inst.calls[0].count;
            void * val2 = (void *) &count;
            int match_result = uv_interface_addresses_struct_inst.calls[0].match_count(val1, val2, "count", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_interface_addresses', %s",uv_interface_addresses_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_interface_addresses_struct_inst.expectedCalls; opmock_i++) {
        uv_interface_addresses_struct_inst.calls[opmock_i - 1] = uv_interface_addresses_struct_inst.calls[opmock_i];
    }

    uv_interface_addresses_struct_inst.expectedCalls--;
    return default_res;
}

void uv_interface_addresses_MockReset()
{
    uv_interface_addresses_struct_inst.expectedCalls = 0;
    uv_interface_addresses_struct_inst.actualCalls = 0;
    uv_interface_addresses_struct_inst.callback = NULL;
}

void uv_interface_addresses_MockWithCallback(OPMOCK_uv_interface_addresses_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_interface_addresses_struct_inst.callback = callback;
    uv_interface_addresses_struct_inst.expectedCalls = 0;
    uv_interface_addresses_struct_inst.actualCalls = 0;
}

void uv_interface_addresses_VerifyMock()
{
    if (uv_interface_addresses_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_interface_addresses'",uv_interface_addresses_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_interface_addresses_ExpectAndReturn (uv_interface_address_t ** addresses, int * count, int to_return, OPMOCK_MATCHER match_addresses, OPMOCK_MATCHER match_count)
{
    if(uv_interface_addresses_struct_inst.callback != NULL)
    {
        uv_interface_addresses_MockReset ();
    }

    if(uv_interface_addresses_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_interface_addresses_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_interface_addresses (uv_interface_address_t ** addresses, int * count)");
    uv_interface_addresses_struct_inst.calls[uv_interface_addresses_struct_inst.expectedCalls].addresses = (void *)addresses;
    uv_interface_addresses_struct_inst.calls[uv_interface_addresses_struct_inst.expectedCalls].count = (void *)count;
    uv_interface_addresses_struct_inst.calls[uv_interface_addresses_struct_inst.expectedCalls].match_addresses = match_addresses;
    uv_interface_addresses_struct_inst.calls[uv_interface_addresses_struct_inst.expectedCalls].match_count = match_count;
    uv_interface_addresses_struct_inst.calls[uv_interface_addresses_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_interface_addresses_struct_inst.calls[uv_interface_addresses_struct_inst.expectedCalls].check_params = 1;
    uv_interface_addresses_struct_inst.expectedCalls++;
}

void uv_free_interface_addresses(uv_interface_address_t * addresses, int count)
{
    int opmock_i;
    uv_free_interface_addresses_struct_inst.actualCalls++;

    if (uv_free_interface_addresses_struct_inst.callback != NULL)
    {
        uv_free_interface_addresses_struct_inst.callback (addresses, count, uv_free_interface_addresses_struct_inst.actualCalls);
        return;
    }
    if (uv_free_interface_addresses_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_free_interface_addresses', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_free_interface_addresses (uv_interface_address_t * addresses, int count)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_free_interface_addresses(uv_interface_address_t * addresses, int count)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_free_interface_addresses_struct_inst.calls[0].check_params == 1) {
        if(uv_free_interface_addresses_struct_inst.calls[0].match_addresses) {
            void * val1 = (void *) &uv_free_interface_addresses_struct_inst.calls[0].addresses;
            void * val2 = (void *) &addresses;
            int match_result = uv_free_interface_addresses_struct_inst.calls[0].match_addresses(val1, val2, "addresses", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_free_interface_addresses', %s",uv_free_interface_addresses_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_free_interface_addresses_struct_inst.calls[0].match_count) {
            void * val1 = (void *) &uv_free_interface_addresses_struct_inst.calls[0].count;
            void * val2 = (void *) &count;
            int match_result = uv_free_interface_addresses_struct_inst.calls[0].match_count(val1, val2, "count", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_free_interface_addresses', %s",uv_free_interface_addresses_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_free_interface_addresses_struct_inst.expectedCalls; opmock_i++) {
        uv_free_interface_addresses_struct_inst.calls[opmock_i - 1] = uv_free_interface_addresses_struct_inst.calls[opmock_i];
    }

    uv_free_interface_addresses_struct_inst.expectedCalls--;
}

void uv_free_interface_addresses_MockReset()
{
    uv_free_interface_addresses_struct_inst.expectedCalls = 0;
    uv_free_interface_addresses_struct_inst.actualCalls = 0;
    uv_free_interface_addresses_struct_inst.callback = NULL;
}

void uv_free_interface_addresses_MockWithCallback(OPMOCK_uv_free_interface_addresses_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_free_interface_addresses_struct_inst.callback = callback;
    uv_free_interface_addresses_struct_inst.expectedCalls = 0;
    uv_free_interface_addresses_struct_inst.actualCalls = 0;
}

void uv_free_interface_addresses_VerifyMock()
{
    if (uv_free_interface_addresses_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_free_interface_addresses'",uv_free_interface_addresses_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_free_interface_addresses_ExpectAndReturn (uv_interface_address_t * addresses, int count, OPMOCK_MATCHER match_addresses, OPMOCK_MATCHER match_count)
{
    if(uv_free_interface_addresses_struct_inst.callback != NULL)
    {
        uv_free_interface_addresses_MockReset ();
    }

    if(uv_free_interface_addresses_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_free_interface_addresses_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_free_interface_addresses (uv_interface_address_t * addresses, int count)");
    uv_free_interface_addresses_struct_inst.calls[uv_free_interface_addresses_struct_inst.expectedCalls].addresses = (void *)addresses;
    uv_free_interface_addresses_struct_inst.calls[uv_free_interface_addresses_struct_inst.expectedCalls].count = (int)count;
    uv_free_interface_addresses_struct_inst.calls[uv_free_interface_addresses_struct_inst.expectedCalls].match_addresses = match_addresses;
    uv_free_interface_addresses_struct_inst.calls[uv_free_interface_addresses_struct_inst.expectedCalls].match_count = match_count;
    uv_free_interface_addresses_struct_inst.calls[uv_free_interface_addresses_struct_inst.expectedCalls].check_params = 1;
    uv_free_interface_addresses_struct_inst.expectedCalls++;
}

void uv_fs_req_cleanup(uv_fs_t * req)
{
    int opmock_i;
    uv_fs_req_cleanup_struct_inst.actualCalls++;

    if (uv_fs_req_cleanup_struct_inst.callback != NULL)
    {
        uv_fs_req_cleanup_struct_inst.callback (req, uv_fs_req_cleanup_struct_inst.actualCalls);
        return;
    }
    if (uv_fs_req_cleanup_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_req_cleanup', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_fs_req_cleanup (uv_fs_t * req)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_fs_req_cleanup(uv_fs_t * req)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_req_cleanup_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_req_cleanup_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_req_cleanup_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_req_cleanup_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_req_cleanup', %s",uv_fs_req_cleanup_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_req_cleanup_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_req_cleanup_struct_inst.calls[opmock_i - 1] = uv_fs_req_cleanup_struct_inst.calls[opmock_i];
    }

    uv_fs_req_cleanup_struct_inst.expectedCalls--;
}

void uv_fs_req_cleanup_MockReset()
{
    uv_fs_req_cleanup_struct_inst.expectedCalls = 0;
    uv_fs_req_cleanup_struct_inst.actualCalls = 0;
    uv_fs_req_cleanup_struct_inst.callback = NULL;
}

void uv_fs_req_cleanup_MockWithCallback(OPMOCK_uv_fs_req_cleanup_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_req_cleanup_struct_inst.callback = callback;
    uv_fs_req_cleanup_struct_inst.expectedCalls = 0;
    uv_fs_req_cleanup_struct_inst.actualCalls = 0;
}

void uv_fs_req_cleanup_VerifyMock()
{
    if (uv_fs_req_cleanup_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_req_cleanup'",uv_fs_req_cleanup_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_req_cleanup_ExpectAndReturn (uv_fs_t * req, OPMOCK_MATCHER match_req)
{
    if(uv_fs_req_cleanup_struct_inst.callback != NULL)
    {
        uv_fs_req_cleanup_MockReset ();
    }

    if(uv_fs_req_cleanup_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_req_cleanup_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_fs_req_cleanup (uv_fs_t * req)");
    uv_fs_req_cleanup_struct_inst.calls[uv_fs_req_cleanup_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_req_cleanup_struct_inst.calls[uv_fs_req_cleanup_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_req_cleanup_struct_inst.calls[uv_fs_req_cleanup_struct_inst.expectedCalls].check_params = 1;
    uv_fs_req_cleanup_struct_inst.expectedCalls++;
}

int uv_fs_close(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_close_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_close_struct_inst.actualCalls++;

    if (uv_fs_close_struct_inst.callback != NULL)
    {
        return uv_fs_close_struct_inst.callback (loop, req, file, cb, uv_fs_close_struct_inst.actualCalls);
    }
    if (uv_fs_close_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_close', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_close (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_close(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_close_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_close_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_close_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_close_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_close', %s",uv_fs_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_close_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_close_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_close_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_close', %s",uv_fs_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_close_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_close_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_close_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_close', %s",uv_fs_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_close_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_close_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_close_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_close', %s",uv_fs_close_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_close_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_close_struct_inst.calls[opmock_i - 1] = uv_fs_close_struct_inst.calls[opmock_i];
    }

    uv_fs_close_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_close_MockReset()
{
    uv_fs_close_struct_inst.expectedCalls = 0;
    uv_fs_close_struct_inst.actualCalls = 0;
    uv_fs_close_struct_inst.callback = NULL;
}

void uv_fs_close_MockWithCallback(OPMOCK_uv_fs_close_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_close_struct_inst.callback = callback;
    uv_fs_close_struct_inst.expectedCalls = 0;
    uv_fs_close_struct_inst.actualCalls = 0;
}

void uv_fs_close_VerifyMock()
{
    if (uv_fs_close_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_close'",uv_fs_close_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_close_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_close_struct_inst.callback != NULL)
    {
        uv_fs_close_MockReset ();
    }

    if(uv_fs_close_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_close_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_close (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)");
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].file = (int)file;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_close_struct_inst.calls[uv_fs_close_struct_inst.expectedCalls].check_params = 1;
    uv_fs_close_struct_inst.expectedCalls++;
}

int uv_fs_open(uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, int mode, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_open_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_open_struct_inst.actualCalls++;

    if (uv_fs_open_struct_inst.callback != NULL)
    {
        return uv_fs_open_struct_inst.callback (loop, req, path, flags, mode, cb, uv_fs_open_struct_inst.actualCalls);
    }
    if (uv_fs_open_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_open', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_open (uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, int mode, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_open(uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, int mode, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_open_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_open_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_open_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_open_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_open', %s",uv_fs_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_open_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_open_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_open_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_open', %s",uv_fs_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_open_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_open_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_open_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_open', %s",uv_fs_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_open_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_fs_open_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_fs_open_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_open', %s",uv_fs_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_open_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_fs_open_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_fs_open_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_open', %s",uv_fs_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_open_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_open_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_open_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_open', %s",uv_fs_open_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_open_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_open_struct_inst.calls[opmock_i - 1] = uv_fs_open_struct_inst.calls[opmock_i];
    }

    uv_fs_open_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_open_MockReset()
{
    uv_fs_open_struct_inst.expectedCalls = 0;
    uv_fs_open_struct_inst.actualCalls = 0;
    uv_fs_open_struct_inst.callback = NULL;
}

void uv_fs_open_MockWithCallback(OPMOCK_uv_fs_open_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_open_struct_inst.callback = callback;
    uv_fs_open_struct_inst.expectedCalls = 0;
    uv_fs_open_struct_inst.actualCalls = 0;
}

void uv_fs_open_VerifyMock()
{
    if (uv_fs_open_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_open'",uv_fs_open_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_open_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, int mode, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_flags, OPMOCK_MATCHER match_mode, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_open_struct_inst.callback != NULL)
    {
        uv_fs_open_MockReset ();
    }

    if(uv_fs_open_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_open_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_open (uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, int mode, uv_fs_cb cb)");
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].flags = (int)flags;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].mode = (int)mode;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].match_flags = match_flags;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].match_mode = match_mode;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_open_struct_inst.calls[uv_fs_open_struct_inst.expectedCalls].check_params = 1;
    uv_fs_open_struct_inst.expectedCalls++;
}

int uv_fs_read(uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_read_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_read_struct_inst.actualCalls++;

    if (uv_fs_read_struct_inst.callback != NULL)
    {
        return uv_fs_read_struct_inst.callback (loop, req, file, bufs, nbufs, offset, cb, uv_fs_read_struct_inst.actualCalls);
    }
    if (uv_fs_read_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_read', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_read (uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_read(uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_read_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_read_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_read_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_read_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_read_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_read_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_read_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_read_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_fs_read_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_read_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_fs_read_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_read_struct_inst.calls[0].match_offset) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].offset;
            void * val2 = (void *) &offset;
            int match_result = uv_fs_read_struct_inst.calls[0].match_offset(val1, val2, "offset", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_read_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_read_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_read_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_read', %s",uv_fs_read_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_read_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_read_struct_inst.calls[opmock_i - 1] = uv_fs_read_struct_inst.calls[opmock_i];
    }

    uv_fs_read_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_read_MockReset()
{
    uv_fs_read_struct_inst.expectedCalls = 0;
    uv_fs_read_struct_inst.actualCalls = 0;
    uv_fs_read_struct_inst.callback = NULL;
}

void uv_fs_read_MockWithCallback(OPMOCK_uv_fs_read_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_read_struct_inst.callback = callback;
    uv_fs_read_struct_inst.expectedCalls = 0;
    uv_fs_read_struct_inst.actualCalls = 0;
}

void uv_fs_read_VerifyMock()
{
    if (uv_fs_read_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_read'",uv_fs_read_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_read_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs, OPMOCK_MATCHER match_offset, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_read_struct_inst.callback != NULL)
    {
        uv_fs_read_MockReset ();
    }

    if(uv_fs_read_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_read_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_read (uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)");
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].file = (int)file;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].offset = (long long)offset;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_offset = match_offset;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_read_struct_inst.calls[uv_fs_read_struct_inst.expectedCalls].check_params = 1;
    uv_fs_read_struct_inst.expectedCalls++;
}

int uv_fs_unlink(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_unlink_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_unlink_struct_inst.actualCalls++;

    if (uv_fs_unlink_struct_inst.callback != NULL)
    {
        return uv_fs_unlink_struct_inst.callback (loop, req, path, cb, uv_fs_unlink_struct_inst.actualCalls);
    }
    if (uv_fs_unlink_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_unlink', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_unlink (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_unlink(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_unlink_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_unlink_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_unlink_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_unlink_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_unlink', %s",uv_fs_unlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_unlink_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_unlink_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_unlink_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_unlink', %s",uv_fs_unlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_unlink_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_unlink_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_unlink_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_unlink', %s",uv_fs_unlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_unlink_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_unlink_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_unlink_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_unlink', %s",uv_fs_unlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_unlink_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_unlink_struct_inst.calls[opmock_i - 1] = uv_fs_unlink_struct_inst.calls[opmock_i];
    }

    uv_fs_unlink_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_unlink_MockReset()
{
    uv_fs_unlink_struct_inst.expectedCalls = 0;
    uv_fs_unlink_struct_inst.actualCalls = 0;
    uv_fs_unlink_struct_inst.callback = NULL;
}

void uv_fs_unlink_MockWithCallback(OPMOCK_uv_fs_unlink_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_unlink_struct_inst.callback = callback;
    uv_fs_unlink_struct_inst.expectedCalls = 0;
    uv_fs_unlink_struct_inst.actualCalls = 0;
}

void uv_fs_unlink_VerifyMock()
{
    if (uv_fs_unlink_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_unlink'",uv_fs_unlink_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_unlink_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_unlink_struct_inst.callback != NULL)
    {
        uv_fs_unlink_MockReset ();
    }

    if(uv_fs_unlink_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_unlink_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_unlink (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)");
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_unlink_struct_inst.calls[uv_fs_unlink_struct_inst.expectedCalls].check_params = 1;
    uv_fs_unlink_struct_inst.expectedCalls++;
}

int uv_fs_write(uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_write_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_write_struct_inst.actualCalls++;

    if (uv_fs_write_struct_inst.callback != NULL)
    {
        return uv_fs_write_struct_inst.callback (loop, req, file, bufs, nbufs, offset, cb, uv_fs_write_struct_inst.actualCalls);
    }
    if (uv_fs_write_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_write', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_write (uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_write(uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_write_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_write_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_write_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_write_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_write_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_write_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_write_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_write_struct_inst.calls[0].match_bufs) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].bufs;
            void * val2 = (void *) &bufs;
            int match_result = uv_fs_write_struct_inst.calls[0].match_bufs(val1, val2, "bufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_write_struct_inst.calls[0].match_nbufs) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].nbufs;
            void * val2 = (void *) &nbufs;
            int match_result = uv_fs_write_struct_inst.calls[0].match_nbufs(val1, val2, "nbufs", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_write_struct_inst.calls[0].match_offset) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].offset;
            void * val2 = (void *) &offset;
            int match_result = uv_fs_write_struct_inst.calls[0].match_offset(val1, val2, "offset", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_write_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_write_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_write_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_write', %s",uv_fs_write_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_write_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_write_struct_inst.calls[opmock_i - 1] = uv_fs_write_struct_inst.calls[opmock_i];
    }

    uv_fs_write_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_write_MockReset()
{
    uv_fs_write_struct_inst.expectedCalls = 0;
    uv_fs_write_struct_inst.actualCalls = 0;
    uv_fs_write_struct_inst.callback = NULL;
}

void uv_fs_write_MockWithCallback(OPMOCK_uv_fs_write_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_write_struct_inst.callback = callback;
    uv_fs_write_struct_inst.expectedCalls = 0;
    uv_fs_write_struct_inst.actualCalls = 0;
}

void uv_fs_write_VerifyMock()
{
    if (uv_fs_write_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_write'",uv_fs_write_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_write_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_bufs, OPMOCK_MATCHER match_nbufs, OPMOCK_MATCHER match_offset, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_write_struct_inst.callback != NULL)
    {
        uv_fs_write_MockReset ();
    }

    if(uv_fs_write_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_write_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_write (uv_loop_t * loop, uv_fs_t * req, uv_file file, const uv_buf_t  bufs [], unsigned int nbufs, int64_t offset, uv_fs_cb cb)");
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].file = (int)file;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].bufs = (void *)bufs;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].nbufs = (unsigned int)nbufs;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].offset = (long long)offset;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_bufs = match_bufs;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_nbufs = match_nbufs;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_offset = match_offset;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_write_struct_inst.calls[uv_fs_write_struct_inst.expectedCalls].check_params = 1;
    uv_fs_write_struct_inst.expectedCalls++;
}

int uv_fs_mkdir(uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_mkdir_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_mkdir_struct_inst.actualCalls++;

    if (uv_fs_mkdir_struct_inst.callback != NULL)
    {
        return uv_fs_mkdir_struct_inst.callback (loop, req, path, mode, cb, uv_fs_mkdir_struct_inst.actualCalls);
    }
    if (uv_fs_mkdir_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_mkdir', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_mkdir (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_mkdir(uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_mkdir_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_mkdir_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_mkdir_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_mkdir_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdir', %s",uv_fs_mkdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdir_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_mkdir_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_mkdir_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdir', %s",uv_fs_mkdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdir_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_mkdir_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_mkdir_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdir', %s",uv_fs_mkdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdir_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_fs_mkdir_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_fs_mkdir_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdir', %s",uv_fs_mkdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdir_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_mkdir_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_mkdir_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdir', %s",uv_fs_mkdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_mkdir_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_mkdir_struct_inst.calls[opmock_i - 1] = uv_fs_mkdir_struct_inst.calls[opmock_i];
    }

    uv_fs_mkdir_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_mkdir_MockReset()
{
    uv_fs_mkdir_struct_inst.expectedCalls = 0;
    uv_fs_mkdir_struct_inst.actualCalls = 0;
    uv_fs_mkdir_struct_inst.callback = NULL;
}

void uv_fs_mkdir_MockWithCallback(OPMOCK_uv_fs_mkdir_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_mkdir_struct_inst.callback = callback;
    uv_fs_mkdir_struct_inst.expectedCalls = 0;
    uv_fs_mkdir_struct_inst.actualCalls = 0;
}

void uv_fs_mkdir_VerifyMock()
{
    if (uv_fs_mkdir_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_mkdir'",uv_fs_mkdir_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_mkdir_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_mode, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_mkdir_struct_inst.callback != NULL)
    {
        uv_fs_mkdir_MockReset ();
    }

    if(uv_fs_mkdir_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_mkdir_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_mkdir (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)");
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].mode = (int)mode;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].match_mode = match_mode;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_mkdir_struct_inst.calls[uv_fs_mkdir_struct_inst.expectedCalls].check_params = 1;
    uv_fs_mkdir_struct_inst.expectedCalls++;
}

int uv_fs_mkdtemp(uv_loop_t * loop, uv_fs_t * req, const char * tpl, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_mkdtemp_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_mkdtemp_struct_inst.actualCalls++;

    if (uv_fs_mkdtemp_struct_inst.callback != NULL)
    {
        return uv_fs_mkdtemp_struct_inst.callback (loop, req, tpl, cb, uv_fs_mkdtemp_struct_inst.actualCalls);
    }
    if (uv_fs_mkdtemp_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_mkdtemp', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_mkdtemp (uv_loop_t * loop, uv_fs_t * req, const char * tpl, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_mkdtemp(uv_loop_t * loop, uv_fs_t * req, const char * tpl, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_mkdtemp_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_mkdtemp_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_mkdtemp_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_mkdtemp_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdtemp', %s",uv_fs_mkdtemp_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdtemp_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_mkdtemp_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_mkdtemp_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdtemp', %s",uv_fs_mkdtemp_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdtemp_struct_inst.calls[0].match_tpl) {
            void * val1 = (void *) &uv_fs_mkdtemp_struct_inst.calls[0].tpl;
            void * val2 = (void *) &tpl;
            int match_result = uv_fs_mkdtemp_struct_inst.calls[0].match_tpl(val1, val2, "tpl", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdtemp', %s",uv_fs_mkdtemp_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_mkdtemp_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_mkdtemp_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_mkdtemp_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_mkdtemp', %s",uv_fs_mkdtemp_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_mkdtemp_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_mkdtemp_struct_inst.calls[opmock_i - 1] = uv_fs_mkdtemp_struct_inst.calls[opmock_i];
    }

    uv_fs_mkdtemp_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_mkdtemp_MockReset()
{
    uv_fs_mkdtemp_struct_inst.expectedCalls = 0;
    uv_fs_mkdtemp_struct_inst.actualCalls = 0;
    uv_fs_mkdtemp_struct_inst.callback = NULL;
}

void uv_fs_mkdtemp_MockWithCallback(OPMOCK_uv_fs_mkdtemp_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_mkdtemp_struct_inst.callback = callback;
    uv_fs_mkdtemp_struct_inst.expectedCalls = 0;
    uv_fs_mkdtemp_struct_inst.actualCalls = 0;
}

void uv_fs_mkdtemp_VerifyMock()
{
    if (uv_fs_mkdtemp_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_mkdtemp'",uv_fs_mkdtemp_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_mkdtemp_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * tpl, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_tpl, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_mkdtemp_struct_inst.callback != NULL)
    {
        uv_fs_mkdtemp_MockReset ();
    }

    if(uv_fs_mkdtemp_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_mkdtemp_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_mkdtemp (uv_loop_t * loop, uv_fs_t * req, const char * tpl, uv_fs_cb cb)");
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].tpl = (void *)tpl;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].match_tpl = match_tpl;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_mkdtemp_struct_inst.calls[uv_fs_mkdtemp_struct_inst.expectedCalls].check_params = 1;
    uv_fs_mkdtemp_struct_inst.expectedCalls++;
}

int uv_fs_rmdir(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_rmdir_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_rmdir_struct_inst.actualCalls++;

    if (uv_fs_rmdir_struct_inst.callback != NULL)
    {
        return uv_fs_rmdir_struct_inst.callback (loop, req, path, cb, uv_fs_rmdir_struct_inst.actualCalls);
    }
    if (uv_fs_rmdir_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_rmdir', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_rmdir (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_rmdir(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_rmdir_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_rmdir_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_rmdir_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_rmdir_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rmdir', %s",uv_fs_rmdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rmdir_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_rmdir_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_rmdir_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rmdir', %s",uv_fs_rmdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rmdir_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_rmdir_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_rmdir_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rmdir', %s",uv_fs_rmdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rmdir_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_rmdir_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_rmdir_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rmdir', %s",uv_fs_rmdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_rmdir_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_rmdir_struct_inst.calls[opmock_i - 1] = uv_fs_rmdir_struct_inst.calls[opmock_i];
    }

    uv_fs_rmdir_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_rmdir_MockReset()
{
    uv_fs_rmdir_struct_inst.expectedCalls = 0;
    uv_fs_rmdir_struct_inst.actualCalls = 0;
    uv_fs_rmdir_struct_inst.callback = NULL;
}

void uv_fs_rmdir_MockWithCallback(OPMOCK_uv_fs_rmdir_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_rmdir_struct_inst.callback = callback;
    uv_fs_rmdir_struct_inst.expectedCalls = 0;
    uv_fs_rmdir_struct_inst.actualCalls = 0;
}

void uv_fs_rmdir_VerifyMock()
{
    if (uv_fs_rmdir_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_rmdir'",uv_fs_rmdir_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_rmdir_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_rmdir_struct_inst.callback != NULL)
    {
        uv_fs_rmdir_MockReset ();
    }

    if(uv_fs_rmdir_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_rmdir_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_rmdir (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)");
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_rmdir_struct_inst.calls[uv_fs_rmdir_struct_inst.expectedCalls].check_params = 1;
    uv_fs_rmdir_struct_inst.expectedCalls++;
}

int uv_fs_scandir(uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_scandir_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_scandir_struct_inst.actualCalls++;

    if (uv_fs_scandir_struct_inst.callback != NULL)
    {
        return uv_fs_scandir_struct_inst.callback (loop, req, path, flags, cb, uv_fs_scandir_struct_inst.actualCalls);
    }
    if (uv_fs_scandir_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_scandir', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_scandir (uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_scandir(uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_scandir_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_scandir_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_scandir_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_scandir_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir', %s",uv_fs_scandir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_scandir_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_scandir_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_scandir_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir', %s",uv_fs_scandir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_scandir_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_scandir_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_scandir_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir', %s",uv_fs_scandir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_scandir_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_fs_scandir_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_fs_scandir_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir', %s",uv_fs_scandir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_scandir_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_scandir_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_scandir_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir', %s",uv_fs_scandir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_scandir_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_scandir_struct_inst.calls[opmock_i - 1] = uv_fs_scandir_struct_inst.calls[opmock_i];
    }

    uv_fs_scandir_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_scandir_MockReset()
{
    uv_fs_scandir_struct_inst.expectedCalls = 0;
    uv_fs_scandir_struct_inst.actualCalls = 0;
    uv_fs_scandir_struct_inst.callback = NULL;
}

void uv_fs_scandir_MockWithCallback(OPMOCK_uv_fs_scandir_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_scandir_struct_inst.callback = callback;
    uv_fs_scandir_struct_inst.expectedCalls = 0;
    uv_fs_scandir_struct_inst.actualCalls = 0;
}

void uv_fs_scandir_VerifyMock()
{
    if (uv_fs_scandir_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_scandir'",uv_fs_scandir_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_scandir_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_flags, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_scandir_struct_inst.callback != NULL)
    {
        uv_fs_scandir_MockReset ();
    }

    if(uv_fs_scandir_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_scandir_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_scandir (uv_loop_t * loop, uv_fs_t * req, const char * path, int flags, uv_fs_cb cb)");
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].flags = (int)flags;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].match_flags = match_flags;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_scandir_struct_inst.calls[uv_fs_scandir_struct_inst.expectedCalls].check_params = 1;
    uv_fs_scandir_struct_inst.expectedCalls++;
}

int uv_fs_scandir_next(uv_fs_t * req, uv_dirent_t * ent)
{
    int default_res = (int)uv_fs_scandir_next_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_scandir_next_struct_inst.actualCalls++;

    if (uv_fs_scandir_next_struct_inst.callback != NULL)
    {
        return uv_fs_scandir_next_struct_inst.callback (req, ent, uv_fs_scandir_next_struct_inst.actualCalls);
    }
    if (uv_fs_scandir_next_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_scandir_next', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_scandir_next (uv_fs_t * req, uv_dirent_t * ent)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_scandir_next(uv_fs_t * req, uv_dirent_t * ent)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_scandir_next_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_scandir_next_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_scandir_next_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_scandir_next_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir_next', %s",uv_fs_scandir_next_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_scandir_next_struct_inst.calls[0].match_ent) {
            void * val1 = (void *) &uv_fs_scandir_next_struct_inst.calls[0].ent;
            void * val2 = (void *) &ent;
            int match_result = uv_fs_scandir_next_struct_inst.calls[0].match_ent(val1, val2, "ent", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_scandir_next', %s",uv_fs_scandir_next_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_scandir_next_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_scandir_next_struct_inst.calls[opmock_i - 1] = uv_fs_scandir_next_struct_inst.calls[opmock_i];
    }

    uv_fs_scandir_next_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_scandir_next_MockReset()
{
    uv_fs_scandir_next_struct_inst.expectedCalls = 0;
    uv_fs_scandir_next_struct_inst.actualCalls = 0;
    uv_fs_scandir_next_struct_inst.callback = NULL;
}

void uv_fs_scandir_next_MockWithCallback(OPMOCK_uv_fs_scandir_next_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_scandir_next_struct_inst.callback = callback;
    uv_fs_scandir_next_struct_inst.expectedCalls = 0;
    uv_fs_scandir_next_struct_inst.actualCalls = 0;
}

void uv_fs_scandir_next_VerifyMock()
{
    if (uv_fs_scandir_next_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_scandir_next'",uv_fs_scandir_next_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_scandir_next_ExpectAndReturn (uv_fs_t * req, uv_dirent_t * ent, int to_return, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_ent)
{
    if(uv_fs_scandir_next_struct_inst.callback != NULL)
    {
        uv_fs_scandir_next_MockReset ();
    }

    if(uv_fs_scandir_next_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_scandir_next_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_scandir_next (uv_fs_t * req, uv_dirent_t * ent)");
    uv_fs_scandir_next_struct_inst.calls[uv_fs_scandir_next_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_scandir_next_struct_inst.calls[uv_fs_scandir_next_struct_inst.expectedCalls].ent = (void *)ent;
    uv_fs_scandir_next_struct_inst.calls[uv_fs_scandir_next_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_scandir_next_struct_inst.calls[uv_fs_scandir_next_struct_inst.expectedCalls].match_ent = match_ent;
    uv_fs_scandir_next_struct_inst.calls[uv_fs_scandir_next_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_scandir_next_struct_inst.calls[uv_fs_scandir_next_struct_inst.expectedCalls].check_params = 1;
    uv_fs_scandir_next_struct_inst.expectedCalls++;
}

int uv_fs_stat(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_stat_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_stat_struct_inst.actualCalls++;

    if (uv_fs_stat_struct_inst.callback != NULL)
    {
        return uv_fs_stat_struct_inst.callback (loop, req, path, cb, uv_fs_stat_struct_inst.actualCalls);
    }
    if (uv_fs_stat_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_stat', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_stat (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_stat(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_stat_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_stat_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_stat_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_stat_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_stat', %s",uv_fs_stat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_stat_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_stat_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_stat_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_stat', %s",uv_fs_stat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_stat_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_stat_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_stat_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_stat', %s",uv_fs_stat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_stat_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_stat_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_stat_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_stat', %s",uv_fs_stat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_stat_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_stat_struct_inst.calls[opmock_i - 1] = uv_fs_stat_struct_inst.calls[opmock_i];
    }

    uv_fs_stat_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_stat_MockReset()
{
    uv_fs_stat_struct_inst.expectedCalls = 0;
    uv_fs_stat_struct_inst.actualCalls = 0;
    uv_fs_stat_struct_inst.callback = NULL;
}

void uv_fs_stat_MockWithCallback(OPMOCK_uv_fs_stat_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_stat_struct_inst.callback = callback;
    uv_fs_stat_struct_inst.expectedCalls = 0;
    uv_fs_stat_struct_inst.actualCalls = 0;
}

void uv_fs_stat_VerifyMock()
{
    if (uv_fs_stat_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_stat'",uv_fs_stat_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_stat_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_stat_struct_inst.callback != NULL)
    {
        uv_fs_stat_MockReset ();
    }

    if(uv_fs_stat_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_stat_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_stat (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)");
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_stat_struct_inst.calls[uv_fs_stat_struct_inst.expectedCalls].check_params = 1;
    uv_fs_stat_struct_inst.expectedCalls++;
}

int uv_fs_fstat(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_fstat_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_fstat_struct_inst.actualCalls++;

    if (uv_fs_fstat_struct_inst.callback != NULL)
    {
        return uv_fs_fstat_struct_inst.callback (loop, req, file, cb, uv_fs_fstat_struct_inst.actualCalls);
    }
    if (uv_fs_fstat_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_fstat', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_fstat (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_fstat(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_fstat_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_fstat_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_fstat_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_fstat_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fstat', %s",uv_fs_fstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fstat_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_fstat_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_fstat_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fstat', %s",uv_fs_fstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fstat_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_fstat_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_fstat_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fstat', %s",uv_fs_fstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fstat_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_fstat_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_fstat_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fstat', %s",uv_fs_fstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_fstat_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_fstat_struct_inst.calls[opmock_i - 1] = uv_fs_fstat_struct_inst.calls[opmock_i];
    }

    uv_fs_fstat_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_fstat_MockReset()
{
    uv_fs_fstat_struct_inst.expectedCalls = 0;
    uv_fs_fstat_struct_inst.actualCalls = 0;
    uv_fs_fstat_struct_inst.callback = NULL;
}

void uv_fs_fstat_MockWithCallback(OPMOCK_uv_fs_fstat_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_fstat_struct_inst.callback = callback;
    uv_fs_fstat_struct_inst.expectedCalls = 0;
    uv_fs_fstat_struct_inst.actualCalls = 0;
}

void uv_fs_fstat_VerifyMock()
{
    if (uv_fs_fstat_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_fstat'",uv_fs_fstat_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_fstat_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_fstat_struct_inst.callback != NULL)
    {
        uv_fs_fstat_MockReset ();
    }

    if(uv_fs_fstat_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_fstat_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_fstat (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)");
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].file = (int)file;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_fstat_struct_inst.calls[uv_fs_fstat_struct_inst.expectedCalls].check_params = 1;
    uv_fs_fstat_struct_inst.expectedCalls++;
}

int uv_fs_rename(uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_rename_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_rename_struct_inst.actualCalls++;

    if (uv_fs_rename_struct_inst.callback != NULL)
    {
        return uv_fs_rename_struct_inst.callback (loop, req, path, new_path, cb, uv_fs_rename_struct_inst.actualCalls);
    }
    if (uv_fs_rename_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_rename', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_rename (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_rename(uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_rename_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_rename_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_rename_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_rename_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rename', %s",uv_fs_rename_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rename_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_rename_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_rename_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rename', %s",uv_fs_rename_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rename_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_rename_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_rename_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rename', %s",uv_fs_rename_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rename_struct_inst.calls[0].match_new_path) {
            void * val1 = (void *) &uv_fs_rename_struct_inst.calls[0].new_path;
            void * val2 = (void *) &new_path;
            int match_result = uv_fs_rename_struct_inst.calls[0].match_new_path(val1, val2, "new_path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rename', %s",uv_fs_rename_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_rename_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_rename_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_rename_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_rename', %s",uv_fs_rename_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_rename_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_rename_struct_inst.calls[opmock_i - 1] = uv_fs_rename_struct_inst.calls[opmock_i];
    }

    uv_fs_rename_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_rename_MockReset()
{
    uv_fs_rename_struct_inst.expectedCalls = 0;
    uv_fs_rename_struct_inst.actualCalls = 0;
    uv_fs_rename_struct_inst.callback = NULL;
}

void uv_fs_rename_MockWithCallback(OPMOCK_uv_fs_rename_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_rename_struct_inst.callback = callback;
    uv_fs_rename_struct_inst.expectedCalls = 0;
    uv_fs_rename_struct_inst.actualCalls = 0;
}

void uv_fs_rename_VerifyMock()
{
    if (uv_fs_rename_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_rename'",uv_fs_rename_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_rename_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_new_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_rename_struct_inst.callback != NULL)
    {
        uv_fs_rename_MockReset ();
    }

    if(uv_fs_rename_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_rename_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_rename (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)");
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].new_path = (void *)new_path;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].match_new_path = match_new_path;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_rename_struct_inst.calls[uv_fs_rename_struct_inst.expectedCalls].check_params = 1;
    uv_fs_rename_struct_inst.expectedCalls++;
}

int uv_fs_fsync(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_fsync_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_fsync_struct_inst.actualCalls++;

    if (uv_fs_fsync_struct_inst.callback != NULL)
    {
        return uv_fs_fsync_struct_inst.callback (loop, req, file, cb, uv_fs_fsync_struct_inst.actualCalls);
    }
    if (uv_fs_fsync_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_fsync', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_fsync (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_fsync(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_fsync_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_fsync_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_fsync_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_fsync_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fsync', %s",uv_fs_fsync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fsync_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_fsync_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_fsync_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fsync', %s",uv_fs_fsync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fsync_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_fsync_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_fsync_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fsync', %s",uv_fs_fsync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fsync_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_fsync_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_fsync_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fsync', %s",uv_fs_fsync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_fsync_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_fsync_struct_inst.calls[opmock_i - 1] = uv_fs_fsync_struct_inst.calls[opmock_i];
    }

    uv_fs_fsync_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_fsync_MockReset()
{
    uv_fs_fsync_struct_inst.expectedCalls = 0;
    uv_fs_fsync_struct_inst.actualCalls = 0;
    uv_fs_fsync_struct_inst.callback = NULL;
}

void uv_fs_fsync_MockWithCallback(OPMOCK_uv_fs_fsync_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_fsync_struct_inst.callback = callback;
    uv_fs_fsync_struct_inst.expectedCalls = 0;
    uv_fs_fsync_struct_inst.actualCalls = 0;
}

void uv_fs_fsync_VerifyMock()
{
    if (uv_fs_fsync_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_fsync'",uv_fs_fsync_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_fsync_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_fsync_struct_inst.callback != NULL)
    {
        uv_fs_fsync_MockReset ();
    }

    if(uv_fs_fsync_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_fsync_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_fsync (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)");
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].file = (int)file;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_fsync_struct_inst.calls[uv_fs_fsync_struct_inst.expectedCalls].check_params = 1;
    uv_fs_fsync_struct_inst.expectedCalls++;
}

int uv_fs_fdatasync(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_fdatasync_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_fdatasync_struct_inst.actualCalls++;

    if (uv_fs_fdatasync_struct_inst.callback != NULL)
    {
        return uv_fs_fdatasync_struct_inst.callback (loop, req, file, cb, uv_fs_fdatasync_struct_inst.actualCalls);
    }
    if (uv_fs_fdatasync_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_fdatasync', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_fdatasync (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_fdatasync(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_fdatasync_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_fdatasync_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_fdatasync_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_fdatasync_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fdatasync', %s",uv_fs_fdatasync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fdatasync_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_fdatasync_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_fdatasync_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fdatasync', %s",uv_fs_fdatasync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fdatasync_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_fdatasync_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_fdatasync_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fdatasync', %s",uv_fs_fdatasync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fdatasync_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_fdatasync_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_fdatasync_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fdatasync', %s",uv_fs_fdatasync_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_fdatasync_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_fdatasync_struct_inst.calls[opmock_i - 1] = uv_fs_fdatasync_struct_inst.calls[opmock_i];
    }

    uv_fs_fdatasync_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_fdatasync_MockReset()
{
    uv_fs_fdatasync_struct_inst.expectedCalls = 0;
    uv_fs_fdatasync_struct_inst.actualCalls = 0;
    uv_fs_fdatasync_struct_inst.callback = NULL;
}

void uv_fs_fdatasync_MockWithCallback(OPMOCK_uv_fs_fdatasync_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_fdatasync_struct_inst.callback = callback;
    uv_fs_fdatasync_struct_inst.expectedCalls = 0;
    uv_fs_fdatasync_struct_inst.actualCalls = 0;
}

void uv_fs_fdatasync_VerifyMock()
{
    if (uv_fs_fdatasync_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_fdatasync'",uv_fs_fdatasync_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_fdatasync_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_fdatasync_struct_inst.callback != NULL)
    {
        uv_fs_fdatasync_MockReset ();
    }

    if(uv_fs_fdatasync_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_fdatasync_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_fdatasync (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_fs_cb cb)");
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].file = (int)file;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_fdatasync_struct_inst.calls[uv_fs_fdatasync_struct_inst.expectedCalls].check_params = 1;
    uv_fs_fdatasync_struct_inst.expectedCalls++;
}

int uv_fs_ftruncate(uv_loop_t * loop, uv_fs_t * req, uv_file file, int64_t offset, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_ftruncate_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_ftruncate_struct_inst.actualCalls++;

    if (uv_fs_ftruncate_struct_inst.callback != NULL)
    {
        return uv_fs_ftruncate_struct_inst.callback (loop, req, file, offset, cb, uv_fs_ftruncate_struct_inst.actualCalls);
    }
    if (uv_fs_ftruncate_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_ftruncate', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_ftruncate (uv_loop_t * loop, uv_fs_t * req, uv_file file, int64_t offset, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_ftruncate(uv_loop_t * loop, uv_fs_t * req, uv_file file, int64_t offset, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_ftruncate_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_ftruncate_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_ftruncate_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_ftruncate_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_ftruncate', %s",uv_fs_ftruncate_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_ftruncate_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_ftruncate_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_ftruncate_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_ftruncate', %s",uv_fs_ftruncate_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_ftruncate_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_ftruncate_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_ftruncate_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_ftruncate', %s",uv_fs_ftruncate_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_ftruncate_struct_inst.calls[0].match_offset) {
            void * val1 = (void *) &uv_fs_ftruncate_struct_inst.calls[0].offset;
            void * val2 = (void *) &offset;
            int match_result = uv_fs_ftruncate_struct_inst.calls[0].match_offset(val1, val2, "offset", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_ftruncate', %s",uv_fs_ftruncate_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_ftruncate_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_ftruncate_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_ftruncate_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_ftruncate', %s",uv_fs_ftruncate_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_ftruncate_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_ftruncate_struct_inst.calls[opmock_i - 1] = uv_fs_ftruncate_struct_inst.calls[opmock_i];
    }

    uv_fs_ftruncate_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_ftruncate_MockReset()
{
    uv_fs_ftruncate_struct_inst.expectedCalls = 0;
    uv_fs_ftruncate_struct_inst.actualCalls = 0;
    uv_fs_ftruncate_struct_inst.callback = NULL;
}

void uv_fs_ftruncate_MockWithCallback(OPMOCK_uv_fs_ftruncate_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_ftruncate_struct_inst.callback = callback;
    uv_fs_ftruncate_struct_inst.expectedCalls = 0;
    uv_fs_ftruncate_struct_inst.actualCalls = 0;
}

void uv_fs_ftruncate_VerifyMock()
{
    if (uv_fs_ftruncate_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_ftruncate'",uv_fs_ftruncate_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_ftruncate_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, int64_t offset, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_offset, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_ftruncate_struct_inst.callback != NULL)
    {
        uv_fs_ftruncate_MockReset ();
    }

    if(uv_fs_ftruncate_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_ftruncate_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_ftruncate (uv_loop_t * loop, uv_fs_t * req, uv_file file, int64_t offset, uv_fs_cb cb)");
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].file = (int)file;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].offset = (long long)offset;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].match_offset = match_offset;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_ftruncate_struct_inst.calls[uv_fs_ftruncate_struct_inst.expectedCalls].check_params = 1;
    uv_fs_ftruncate_struct_inst.expectedCalls++;
}

int uv_fs_sendfile(uv_loop_t * loop, uv_fs_t * req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_sendfile_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_sendfile_struct_inst.actualCalls++;

    if (uv_fs_sendfile_struct_inst.callback != NULL)
    {
        return uv_fs_sendfile_struct_inst.callback (loop, req, out_fd, in_fd, in_offset, length, cb, uv_fs_sendfile_struct_inst.actualCalls);
    }
    if (uv_fs_sendfile_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_sendfile', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_sendfile (uv_loop_t * loop, uv_fs_t * req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_sendfile(uv_loop_t * loop, uv_fs_t * req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_sendfile_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_sendfile_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_sendfile_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_sendfile_struct_inst.calls[0].match_out_fd) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].out_fd;
            void * val2 = (void *) &out_fd;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_out_fd(val1, val2, "out_fd", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_sendfile_struct_inst.calls[0].match_in_fd) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].in_fd;
            void * val2 = (void *) &in_fd;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_in_fd(val1, val2, "in_fd", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_sendfile_struct_inst.calls[0].match_in_offset) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].in_offset;
            void * val2 = (void *) &in_offset;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_in_offset(val1, val2, "in_offset", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_sendfile_struct_inst.calls[0].match_length) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].length;
            void * val2 = (void *) &length;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_length(val1, val2, "length", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_sendfile_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_sendfile_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_sendfile_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_sendfile', %s",uv_fs_sendfile_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_sendfile_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_sendfile_struct_inst.calls[opmock_i - 1] = uv_fs_sendfile_struct_inst.calls[opmock_i];
    }

    uv_fs_sendfile_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_sendfile_MockReset()
{
    uv_fs_sendfile_struct_inst.expectedCalls = 0;
    uv_fs_sendfile_struct_inst.actualCalls = 0;
    uv_fs_sendfile_struct_inst.callback = NULL;
}

void uv_fs_sendfile_MockWithCallback(OPMOCK_uv_fs_sendfile_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_sendfile_struct_inst.callback = callback;
    uv_fs_sendfile_struct_inst.expectedCalls = 0;
    uv_fs_sendfile_struct_inst.actualCalls = 0;
}

void uv_fs_sendfile_VerifyMock()
{
    if (uv_fs_sendfile_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_sendfile'",uv_fs_sendfile_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_sendfile_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_out_fd, OPMOCK_MATCHER match_in_fd, OPMOCK_MATCHER match_in_offset, OPMOCK_MATCHER match_length, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_sendfile_struct_inst.callback != NULL)
    {
        uv_fs_sendfile_MockReset ();
    }

    if(uv_fs_sendfile_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_sendfile_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_sendfile (uv_loop_t * loop, uv_fs_t * req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb)");
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].out_fd = (int)out_fd;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].in_fd = (int)in_fd;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].in_offset = (long long)in_offset;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].length = (unsigned long)length;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_out_fd = match_out_fd;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_in_fd = match_in_fd;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_in_offset = match_in_offset;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_length = match_length;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_sendfile_struct_inst.calls[uv_fs_sendfile_struct_inst.expectedCalls].check_params = 1;
    uv_fs_sendfile_struct_inst.expectedCalls++;
}

int uv_fs_access(uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_access_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_access_struct_inst.actualCalls++;

    if (uv_fs_access_struct_inst.callback != NULL)
    {
        return uv_fs_access_struct_inst.callback (loop, req, path, mode, cb, uv_fs_access_struct_inst.actualCalls);
    }
    if (uv_fs_access_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_access', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_access (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_access(uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_access_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_access_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_access_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_access_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_access', %s",uv_fs_access_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_access_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_access_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_access_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_access', %s",uv_fs_access_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_access_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_access_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_access_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_access', %s",uv_fs_access_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_access_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_fs_access_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_fs_access_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_access', %s",uv_fs_access_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_access_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_access_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_access_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_access', %s",uv_fs_access_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_access_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_access_struct_inst.calls[opmock_i - 1] = uv_fs_access_struct_inst.calls[opmock_i];
    }

    uv_fs_access_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_access_MockReset()
{
    uv_fs_access_struct_inst.expectedCalls = 0;
    uv_fs_access_struct_inst.actualCalls = 0;
    uv_fs_access_struct_inst.callback = NULL;
}

void uv_fs_access_MockWithCallback(OPMOCK_uv_fs_access_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_access_struct_inst.callback = callback;
    uv_fs_access_struct_inst.expectedCalls = 0;
    uv_fs_access_struct_inst.actualCalls = 0;
}

void uv_fs_access_VerifyMock()
{
    if (uv_fs_access_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_access'",uv_fs_access_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_access_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_mode, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_access_struct_inst.callback != NULL)
    {
        uv_fs_access_MockReset ();
    }

    if(uv_fs_access_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_access_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_access (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)");
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].mode = (int)mode;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].match_mode = match_mode;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_access_struct_inst.calls[uv_fs_access_struct_inst.expectedCalls].check_params = 1;
    uv_fs_access_struct_inst.expectedCalls++;
}

int uv_fs_chmod(uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_chmod_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_chmod_struct_inst.actualCalls++;

    if (uv_fs_chmod_struct_inst.callback != NULL)
    {
        return uv_fs_chmod_struct_inst.callback (loop, req, path, mode, cb, uv_fs_chmod_struct_inst.actualCalls);
    }
    if (uv_fs_chmod_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_chmod', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_chmod (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_chmod(uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_chmod_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_chmod_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_chmod_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_chmod_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chmod', %s",uv_fs_chmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chmod_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_chmod_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_chmod_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chmod', %s",uv_fs_chmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chmod_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_chmod_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_chmod_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chmod', %s",uv_fs_chmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chmod_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_fs_chmod_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_fs_chmod_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chmod', %s",uv_fs_chmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chmod_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_chmod_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_chmod_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chmod', %s",uv_fs_chmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_chmod_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_chmod_struct_inst.calls[opmock_i - 1] = uv_fs_chmod_struct_inst.calls[opmock_i];
    }

    uv_fs_chmod_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_chmod_MockReset()
{
    uv_fs_chmod_struct_inst.expectedCalls = 0;
    uv_fs_chmod_struct_inst.actualCalls = 0;
    uv_fs_chmod_struct_inst.callback = NULL;
}

void uv_fs_chmod_MockWithCallback(OPMOCK_uv_fs_chmod_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_chmod_struct_inst.callback = callback;
    uv_fs_chmod_struct_inst.expectedCalls = 0;
    uv_fs_chmod_struct_inst.actualCalls = 0;
}

void uv_fs_chmod_VerifyMock()
{
    if (uv_fs_chmod_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_chmod'",uv_fs_chmod_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_chmod_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_mode, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_chmod_struct_inst.callback != NULL)
    {
        uv_fs_chmod_MockReset ();
    }

    if(uv_fs_chmod_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_chmod_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_chmod (uv_loop_t * loop, uv_fs_t * req, const char * path, int mode, uv_fs_cb cb)");
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].mode = (int)mode;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].match_mode = match_mode;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_chmod_struct_inst.calls[uv_fs_chmod_struct_inst.expectedCalls].check_params = 1;
    uv_fs_chmod_struct_inst.expectedCalls++;
}

int uv_fs_utime(uv_loop_t * loop, uv_fs_t * req, const char * path, double atime, double mtime, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_utime_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_utime_struct_inst.actualCalls++;

    if (uv_fs_utime_struct_inst.callback != NULL)
    {
        return uv_fs_utime_struct_inst.callback (loop, req, path, atime, mtime, cb, uv_fs_utime_struct_inst.actualCalls);
    }
    if (uv_fs_utime_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_utime', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_utime (uv_loop_t * loop, uv_fs_t * req, const char * path, double atime, double mtime, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_utime(uv_loop_t * loop, uv_fs_t * req, const char * path, double atime, double mtime, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_utime_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_utime_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_utime_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_utime_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_utime', %s",uv_fs_utime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_utime_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_utime_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_utime_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_utime', %s",uv_fs_utime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_utime_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_utime_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_utime_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_utime', %s",uv_fs_utime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_utime_struct_inst.calls[0].match_atime) {
            void * val1 = (void *) &uv_fs_utime_struct_inst.calls[0].atime;
            void * val2 = (void *) &atime;
            int match_result = uv_fs_utime_struct_inst.calls[0].match_atime(val1, val2, "atime", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_utime', %s",uv_fs_utime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_utime_struct_inst.calls[0].match_mtime) {
            void * val1 = (void *) &uv_fs_utime_struct_inst.calls[0].mtime;
            void * val2 = (void *) &mtime;
            int match_result = uv_fs_utime_struct_inst.calls[0].match_mtime(val1, val2, "mtime", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_utime', %s",uv_fs_utime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_utime_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_utime_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_utime_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_utime', %s",uv_fs_utime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_utime_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_utime_struct_inst.calls[opmock_i - 1] = uv_fs_utime_struct_inst.calls[opmock_i];
    }

    uv_fs_utime_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_utime_MockReset()
{
    uv_fs_utime_struct_inst.expectedCalls = 0;
    uv_fs_utime_struct_inst.actualCalls = 0;
    uv_fs_utime_struct_inst.callback = NULL;
}

void uv_fs_utime_MockWithCallback(OPMOCK_uv_fs_utime_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_utime_struct_inst.callback = callback;
    uv_fs_utime_struct_inst.expectedCalls = 0;
    uv_fs_utime_struct_inst.actualCalls = 0;
}

void uv_fs_utime_VerifyMock()
{
    if (uv_fs_utime_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_utime'",uv_fs_utime_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_utime_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, double atime, double mtime, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_atime, OPMOCK_MATCHER match_mtime, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_utime_struct_inst.callback != NULL)
    {
        uv_fs_utime_MockReset ();
    }

    if(uv_fs_utime_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_utime_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_utime (uv_loop_t * loop, uv_fs_t * req, const char * path, double atime, double mtime, uv_fs_cb cb)");
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].atime = (double)atime;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].mtime = (double)mtime;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].match_atime = match_atime;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].match_mtime = match_mtime;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_utime_struct_inst.calls[uv_fs_utime_struct_inst.expectedCalls].check_params = 1;
    uv_fs_utime_struct_inst.expectedCalls++;
}

int uv_fs_futime(uv_loop_t * loop, uv_fs_t * req, uv_file file, double atime, double mtime, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_futime_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_futime_struct_inst.actualCalls++;

    if (uv_fs_futime_struct_inst.callback != NULL)
    {
        return uv_fs_futime_struct_inst.callback (loop, req, file, atime, mtime, cb, uv_fs_futime_struct_inst.actualCalls);
    }
    if (uv_fs_futime_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_futime', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_futime (uv_loop_t * loop, uv_fs_t * req, uv_file file, double atime, double mtime, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_futime(uv_loop_t * loop, uv_fs_t * req, uv_file file, double atime, double mtime, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_futime_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_futime_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_futime_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_futime_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_futime', %s",uv_fs_futime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_futime_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_futime_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_futime_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_futime', %s",uv_fs_futime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_futime_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_futime_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_futime_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_futime', %s",uv_fs_futime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_futime_struct_inst.calls[0].match_atime) {
            void * val1 = (void *) &uv_fs_futime_struct_inst.calls[0].atime;
            void * val2 = (void *) &atime;
            int match_result = uv_fs_futime_struct_inst.calls[0].match_atime(val1, val2, "atime", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_futime', %s",uv_fs_futime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_futime_struct_inst.calls[0].match_mtime) {
            void * val1 = (void *) &uv_fs_futime_struct_inst.calls[0].mtime;
            void * val2 = (void *) &mtime;
            int match_result = uv_fs_futime_struct_inst.calls[0].match_mtime(val1, val2, "mtime", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_futime', %s",uv_fs_futime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_futime_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_futime_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_futime_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_futime', %s",uv_fs_futime_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_futime_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_futime_struct_inst.calls[opmock_i - 1] = uv_fs_futime_struct_inst.calls[opmock_i];
    }

    uv_fs_futime_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_futime_MockReset()
{
    uv_fs_futime_struct_inst.expectedCalls = 0;
    uv_fs_futime_struct_inst.actualCalls = 0;
    uv_fs_futime_struct_inst.callback = NULL;
}

void uv_fs_futime_MockWithCallback(OPMOCK_uv_fs_futime_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_futime_struct_inst.callback = callback;
    uv_fs_futime_struct_inst.expectedCalls = 0;
    uv_fs_futime_struct_inst.actualCalls = 0;
}

void uv_fs_futime_VerifyMock()
{
    if (uv_fs_futime_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_futime'",uv_fs_futime_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_futime_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, double atime, double mtime, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_atime, OPMOCK_MATCHER match_mtime, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_futime_struct_inst.callback != NULL)
    {
        uv_fs_futime_MockReset ();
    }

    if(uv_fs_futime_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_futime_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_futime (uv_loop_t * loop, uv_fs_t * req, uv_file file, double atime, double mtime, uv_fs_cb cb)");
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].file = (int)file;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].atime = (double)atime;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].mtime = (double)mtime;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].match_atime = match_atime;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].match_mtime = match_mtime;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_futime_struct_inst.calls[uv_fs_futime_struct_inst.expectedCalls].check_params = 1;
    uv_fs_futime_struct_inst.expectedCalls++;
}

int uv_fs_lstat(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_lstat_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_lstat_struct_inst.actualCalls++;

    if (uv_fs_lstat_struct_inst.callback != NULL)
    {
        return uv_fs_lstat_struct_inst.callback (loop, req, path, cb, uv_fs_lstat_struct_inst.actualCalls);
    }
    if (uv_fs_lstat_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_lstat', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_lstat (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_lstat(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_lstat_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_lstat_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_lstat_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_lstat_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_lstat', %s",uv_fs_lstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_lstat_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_lstat_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_lstat_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_lstat', %s",uv_fs_lstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_lstat_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_lstat_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_lstat_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_lstat', %s",uv_fs_lstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_lstat_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_lstat_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_lstat_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_lstat', %s",uv_fs_lstat_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_lstat_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_lstat_struct_inst.calls[opmock_i - 1] = uv_fs_lstat_struct_inst.calls[opmock_i];
    }

    uv_fs_lstat_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_lstat_MockReset()
{
    uv_fs_lstat_struct_inst.expectedCalls = 0;
    uv_fs_lstat_struct_inst.actualCalls = 0;
    uv_fs_lstat_struct_inst.callback = NULL;
}

void uv_fs_lstat_MockWithCallback(OPMOCK_uv_fs_lstat_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_lstat_struct_inst.callback = callback;
    uv_fs_lstat_struct_inst.expectedCalls = 0;
    uv_fs_lstat_struct_inst.actualCalls = 0;
}

void uv_fs_lstat_VerifyMock()
{
    if (uv_fs_lstat_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_lstat'",uv_fs_lstat_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_lstat_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_lstat_struct_inst.callback != NULL)
    {
        uv_fs_lstat_MockReset ();
    }

    if(uv_fs_lstat_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_lstat_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_lstat (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)");
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_lstat_struct_inst.calls[uv_fs_lstat_struct_inst.expectedCalls].check_params = 1;
    uv_fs_lstat_struct_inst.expectedCalls++;
}

int uv_fs_link(uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_link_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_link_struct_inst.actualCalls++;

    if (uv_fs_link_struct_inst.callback != NULL)
    {
        return uv_fs_link_struct_inst.callback (loop, req, path, new_path, cb, uv_fs_link_struct_inst.actualCalls);
    }
    if (uv_fs_link_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_link', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_link (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_link(uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_link_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_link_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_link_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_link_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_link', %s",uv_fs_link_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_link_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_link_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_link_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_link', %s",uv_fs_link_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_link_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_link_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_link_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_link', %s",uv_fs_link_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_link_struct_inst.calls[0].match_new_path) {
            void * val1 = (void *) &uv_fs_link_struct_inst.calls[0].new_path;
            void * val2 = (void *) &new_path;
            int match_result = uv_fs_link_struct_inst.calls[0].match_new_path(val1, val2, "new_path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_link', %s",uv_fs_link_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_link_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_link_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_link_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_link', %s",uv_fs_link_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_link_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_link_struct_inst.calls[opmock_i - 1] = uv_fs_link_struct_inst.calls[opmock_i];
    }

    uv_fs_link_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_link_MockReset()
{
    uv_fs_link_struct_inst.expectedCalls = 0;
    uv_fs_link_struct_inst.actualCalls = 0;
    uv_fs_link_struct_inst.callback = NULL;
}

void uv_fs_link_MockWithCallback(OPMOCK_uv_fs_link_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_link_struct_inst.callback = callback;
    uv_fs_link_struct_inst.expectedCalls = 0;
    uv_fs_link_struct_inst.actualCalls = 0;
}

void uv_fs_link_VerifyMock()
{
    if (uv_fs_link_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_link'",uv_fs_link_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_link_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_new_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_link_struct_inst.callback != NULL)
    {
        uv_fs_link_MockReset ();
    }

    if(uv_fs_link_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_link_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_link (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, uv_fs_cb cb)");
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].new_path = (void *)new_path;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].match_new_path = match_new_path;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_link_struct_inst.calls[uv_fs_link_struct_inst.expectedCalls].check_params = 1;
    uv_fs_link_struct_inst.expectedCalls++;
}

int uv_fs_symlink(uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, int flags, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_symlink_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_symlink_struct_inst.actualCalls++;

    if (uv_fs_symlink_struct_inst.callback != NULL)
    {
        return uv_fs_symlink_struct_inst.callback (loop, req, path, new_path, flags, cb, uv_fs_symlink_struct_inst.actualCalls);
    }
    if (uv_fs_symlink_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_symlink', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_symlink (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, int flags, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_symlink(uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, int flags, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_symlink_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_symlink_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_symlink_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_symlink_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_symlink', %s",uv_fs_symlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_symlink_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_symlink_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_symlink_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_symlink', %s",uv_fs_symlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_symlink_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_symlink_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_symlink_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_symlink', %s",uv_fs_symlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_symlink_struct_inst.calls[0].match_new_path) {
            void * val1 = (void *) &uv_fs_symlink_struct_inst.calls[0].new_path;
            void * val2 = (void *) &new_path;
            int match_result = uv_fs_symlink_struct_inst.calls[0].match_new_path(val1, val2, "new_path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_symlink', %s",uv_fs_symlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_symlink_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_fs_symlink_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_fs_symlink_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_symlink', %s",uv_fs_symlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_symlink_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_symlink_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_symlink_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_symlink', %s",uv_fs_symlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_symlink_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_symlink_struct_inst.calls[opmock_i - 1] = uv_fs_symlink_struct_inst.calls[opmock_i];
    }

    uv_fs_symlink_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_symlink_MockReset()
{
    uv_fs_symlink_struct_inst.expectedCalls = 0;
    uv_fs_symlink_struct_inst.actualCalls = 0;
    uv_fs_symlink_struct_inst.callback = NULL;
}

void uv_fs_symlink_MockWithCallback(OPMOCK_uv_fs_symlink_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_symlink_struct_inst.callback = callback;
    uv_fs_symlink_struct_inst.expectedCalls = 0;
    uv_fs_symlink_struct_inst.actualCalls = 0;
}

void uv_fs_symlink_VerifyMock()
{
    if (uv_fs_symlink_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_symlink'",uv_fs_symlink_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_symlink_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, int flags, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_new_path, OPMOCK_MATCHER match_flags, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_symlink_struct_inst.callback != NULL)
    {
        uv_fs_symlink_MockReset ();
    }

    if(uv_fs_symlink_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_symlink_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_symlink (uv_loop_t * loop, uv_fs_t * req, const char * path, const char * new_path, int flags, uv_fs_cb cb)");
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].new_path = (void *)new_path;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].flags = (int)flags;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].match_new_path = match_new_path;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].match_flags = match_flags;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_symlink_struct_inst.calls[uv_fs_symlink_struct_inst.expectedCalls].check_params = 1;
    uv_fs_symlink_struct_inst.expectedCalls++;
}

int uv_fs_readlink(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_readlink_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_readlink_struct_inst.actualCalls++;

    if (uv_fs_readlink_struct_inst.callback != NULL)
    {
        return uv_fs_readlink_struct_inst.callback (loop, req, path, cb, uv_fs_readlink_struct_inst.actualCalls);
    }
    if (uv_fs_readlink_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_readlink', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_readlink (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_readlink(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_readlink_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_readlink_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_readlink_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_readlink_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_readlink', %s",uv_fs_readlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_readlink_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_readlink_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_readlink_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_readlink', %s",uv_fs_readlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_readlink_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_readlink_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_readlink_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_readlink', %s",uv_fs_readlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_readlink_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_readlink_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_readlink_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_readlink', %s",uv_fs_readlink_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_readlink_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_readlink_struct_inst.calls[opmock_i - 1] = uv_fs_readlink_struct_inst.calls[opmock_i];
    }

    uv_fs_readlink_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_readlink_MockReset()
{
    uv_fs_readlink_struct_inst.expectedCalls = 0;
    uv_fs_readlink_struct_inst.actualCalls = 0;
    uv_fs_readlink_struct_inst.callback = NULL;
}

void uv_fs_readlink_MockWithCallback(OPMOCK_uv_fs_readlink_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_readlink_struct_inst.callback = callback;
    uv_fs_readlink_struct_inst.expectedCalls = 0;
    uv_fs_readlink_struct_inst.actualCalls = 0;
}

void uv_fs_readlink_VerifyMock()
{
    if (uv_fs_readlink_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_readlink'",uv_fs_readlink_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_readlink_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_readlink_struct_inst.callback != NULL)
    {
        uv_fs_readlink_MockReset ();
    }

    if(uv_fs_readlink_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_readlink_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_readlink (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_fs_cb cb)");
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_readlink_struct_inst.calls[uv_fs_readlink_struct_inst.expectedCalls].check_params = 1;
    uv_fs_readlink_struct_inst.expectedCalls++;
}

int uv_fs_fchmod(uv_loop_t * loop, uv_fs_t * req, uv_file file, int mode, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_fchmod_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_fchmod_struct_inst.actualCalls++;

    if (uv_fs_fchmod_struct_inst.callback != NULL)
    {
        return uv_fs_fchmod_struct_inst.callback (loop, req, file, mode, cb, uv_fs_fchmod_struct_inst.actualCalls);
    }
    if (uv_fs_fchmod_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_fchmod', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_fchmod (uv_loop_t * loop, uv_fs_t * req, uv_file file, int mode, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_fchmod(uv_loop_t * loop, uv_fs_t * req, uv_file file, int mode, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_fchmod_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_fchmod_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_fchmod_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_fchmod_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchmod', %s",uv_fs_fchmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchmod_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_fchmod_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_fchmod_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchmod', %s",uv_fs_fchmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchmod_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_fchmod_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_fchmod_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchmod', %s",uv_fs_fchmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchmod_struct_inst.calls[0].match_mode) {
            void * val1 = (void *) &uv_fs_fchmod_struct_inst.calls[0].mode;
            void * val2 = (void *) &mode;
            int match_result = uv_fs_fchmod_struct_inst.calls[0].match_mode(val1, val2, "mode", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchmod', %s",uv_fs_fchmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchmod_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_fchmod_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_fchmod_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchmod', %s",uv_fs_fchmod_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_fchmod_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_fchmod_struct_inst.calls[opmock_i - 1] = uv_fs_fchmod_struct_inst.calls[opmock_i];
    }

    uv_fs_fchmod_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_fchmod_MockReset()
{
    uv_fs_fchmod_struct_inst.expectedCalls = 0;
    uv_fs_fchmod_struct_inst.actualCalls = 0;
    uv_fs_fchmod_struct_inst.callback = NULL;
}

void uv_fs_fchmod_MockWithCallback(OPMOCK_uv_fs_fchmod_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_fchmod_struct_inst.callback = callback;
    uv_fs_fchmod_struct_inst.expectedCalls = 0;
    uv_fs_fchmod_struct_inst.actualCalls = 0;
}

void uv_fs_fchmod_VerifyMock()
{
    if (uv_fs_fchmod_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_fchmod'",uv_fs_fchmod_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_fchmod_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, int mode, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_mode, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_fchmod_struct_inst.callback != NULL)
    {
        uv_fs_fchmod_MockReset ();
    }

    if(uv_fs_fchmod_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_fchmod_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_fchmod (uv_loop_t * loop, uv_fs_t * req, uv_file file, int mode, uv_fs_cb cb)");
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].file = (int)file;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].mode = (int)mode;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].match_mode = match_mode;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_fchmod_struct_inst.calls[uv_fs_fchmod_struct_inst.expectedCalls].check_params = 1;
    uv_fs_fchmod_struct_inst.expectedCalls++;
}

int uv_fs_chown(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_chown_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_chown_struct_inst.actualCalls++;

    if (uv_fs_chown_struct_inst.callback != NULL)
    {
        return uv_fs_chown_struct_inst.callback (loop, req, path, uid, gid, cb, uv_fs_chown_struct_inst.actualCalls);
    }
    if (uv_fs_chown_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_chown', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_chown (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_chown(uv_loop_t * loop, uv_fs_t * req, const char * path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_chown_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_chown_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_chown_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_chown_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chown', %s",uv_fs_chown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chown_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_chown_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_chown_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chown', %s",uv_fs_chown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chown_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_chown_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_chown_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chown', %s",uv_fs_chown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chown_struct_inst.calls[0].match_uid) {
            void * val1 = (void *) &uv_fs_chown_struct_inst.calls[0].uid;
            void * val2 = (void *) &uid;
            int match_result = uv_fs_chown_struct_inst.calls[0].match_uid(val1, val2, "uid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chown', %s",uv_fs_chown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chown_struct_inst.calls[0].match_gid) {
            void * val1 = (void *) &uv_fs_chown_struct_inst.calls[0].gid;
            void * val2 = (void *) &gid;
            int match_result = uv_fs_chown_struct_inst.calls[0].match_gid(val1, val2, "gid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chown', %s",uv_fs_chown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_chown_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_chown_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_chown_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_chown', %s",uv_fs_chown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_chown_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_chown_struct_inst.calls[opmock_i - 1] = uv_fs_chown_struct_inst.calls[opmock_i];
    }

    uv_fs_chown_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_chown_MockReset()
{
    uv_fs_chown_struct_inst.expectedCalls = 0;
    uv_fs_chown_struct_inst.actualCalls = 0;
    uv_fs_chown_struct_inst.callback = NULL;
}

void uv_fs_chown_MockWithCallback(OPMOCK_uv_fs_chown_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_chown_struct_inst.callback = callback;
    uv_fs_chown_struct_inst.expectedCalls = 0;
    uv_fs_chown_struct_inst.actualCalls = 0;
}

void uv_fs_chown_VerifyMock()
{
    if (uv_fs_chown_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_chown'",uv_fs_chown_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_chown_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_uid, OPMOCK_MATCHER match_gid, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_chown_struct_inst.callback != NULL)
    {
        uv_fs_chown_MockReset ();
    }

    if(uv_fs_chown_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_chown_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_chown (uv_loop_t * loop, uv_fs_t * req, const char * path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)");
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].uid = (unsigned int)uid;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].gid = (unsigned int)gid;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].match_uid = match_uid;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].match_gid = match_gid;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_chown_struct_inst.calls[uv_fs_chown_struct_inst.expectedCalls].check_params = 1;
    uv_fs_chown_struct_inst.expectedCalls++;
}

int uv_fs_fchown(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)
{
    int default_res = (int)uv_fs_fchown_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_fchown_struct_inst.actualCalls++;

    if (uv_fs_fchown_struct_inst.callback != NULL)
    {
        return uv_fs_fchown_struct_inst.callback (loop, req, file, uid, gid, cb, uv_fs_fchown_struct_inst.actualCalls);
    }
    if (uv_fs_fchown_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_fchown', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_fchown (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_fchown(uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_fchown_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_fchown_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_fchown_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_fchown_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchown', %s",uv_fs_fchown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchown_struct_inst.calls[0].match_req) {
            void * val1 = (void *) &uv_fs_fchown_struct_inst.calls[0].req;
            void * val2 = (void *) &req;
            int match_result = uv_fs_fchown_struct_inst.calls[0].match_req(val1, val2, "req", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchown', %s",uv_fs_fchown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchown_struct_inst.calls[0].match_file) {
            void * val1 = (void *) &uv_fs_fchown_struct_inst.calls[0].file;
            void * val2 = (void *) &file;
            int match_result = uv_fs_fchown_struct_inst.calls[0].match_file(val1, val2, "file", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchown', %s",uv_fs_fchown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchown_struct_inst.calls[0].match_uid) {
            void * val1 = (void *) &uv_fs_fchown_struct_inst.calls[0].uid;
            void * val2 = (void *) &uid;
            int match_result = uv_fs_fchown_struct_inst.calls[0].match_uid(val1, val2, "uid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchown', %s",uv_fs_fchown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchown_struct_inst.calls[0].match_gid) {
            void * val1 = (void *) &uv_fs_fchown_struct_inst.calls[0].gid;
            void * val2 = (void *) &gid;
            int match_result = uv_fs_fchown_struct_inst.calls[0].match_gid(val1, val2, "gid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchown', %s",uv_fs_fchown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_fchown_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_fchown_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_fchown_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_fchown', %s",uv_fs_fchown_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_fchown_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_fchown_struct_inst.calls[opmock_i - 1] = uv_fs_fchown_struct_inst.calls[opmock_i];
    }

    uv_fs_fchown_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_fchown_MockReset()
{
    uv_fs_fchown_struct_inst.expectedCalls = 0;
    uv_fs_fchown_struct_inst.actualCalls = 0;
    uv_fs_fchown_struct_inst.callback = NULL;
}

void uv_fs_fchown_MockWithCallback(OPMOCK_uv_fs_fchown_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_fchown_struct_inst.callback = callback;
    uv_fs_fchown_struct_inst.expectedCalls = 0;
    uv_fs_fchown_struct_inst.actualCalls = 0;
}

void uv_fs_fchown_VerifyMock()
{
    if (uv_fs_fchown_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_fchown'",uv_fs_fchown_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_fchown_ExpectAndReturn (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_req, OPMOCK_MATCHER match_file, OPMOCK_MATCHER match_uid, OPMOCK_MATCHER match_gid, OPMOCK_MATCHER match_cb)
{
    if(uv_fs_fchown_struct_inst.callback != NULL)
    {
        uv_fs_fchown_MockReset ();
    }

    if(uv_fs_fchown_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_fchown_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_fchown (uv_loop_t * loop, uv_fs_t * req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)");
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].req = (void *)req;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].file = (int)file;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].uid = (unsigned int)uid;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].gid = (unsigned int)gid;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].match_req = match_req;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].match_file = match_file;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].match_uid = match_uid;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].match_gid = match_gid;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_fchown_struct_inst.calls[uv_fs_fchown_struct_inst.expectedCalls].check_params = 1;
    uv_fs_fchown_struct_inst.expectedCalls++;
}

int uv_fs_poll_init(uv_loop_t * loop, uv_fs_poll_t * handle)
{
    int default_res = (int)uv_fs_poll_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_poll_init_struct_inst.actualCalls++;

    if (uv_fs_poll_init_struct_inst.callback != NULL)
    {
        return uv_fs_poll_init_struct_inst.callback (loop, handle, uv_fs_poll_init_struct_inst.actualCalls);
    }
    if (uv_fs_poll_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_poll_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_poll_init (uv_loop_t * loop, uv_fs_poll_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_poll_init(uv_loop_t * loop, uv_fs_poll_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_poll_init_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_poll_init_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_poll_init_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_poll_init_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_init', %s",uv_fs_poll_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_poll_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_poll_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_poll_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_init', %s",uv_fs_poll_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_poll_init_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_poll_init_struct_inst.calls[opmock_i - 1] = uv_fs_poll_init_struct_inst.calls[opmock_i];
    }

    uv_fs_poll_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_poll_init_MockReset()
{
    uv_fs_poll_init_struct_inst.expectedCalls = 0;
    uv_fs_poll_init_struct_inst.actualCalls = 0;
    uv_fs_poll_init_struct_inst.callback = NULL;
}

void uv_fs_poll_init_MockWithCallback(OPMOCK_uv_fs_poll_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_poll_init_struct_inst.callback = callback;
    uv_fs_poll_init_struct_inst.expectedCalls = 0;
    uv_fs_poll_init_struct_inst.actualCalls = 0;
}

void uv_fs_poll_init_VerifyMock()
{
    if (uv_fs_poll_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_poll_init'",uv_fs_poll_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_poll_init_ExpectAndReturn (uv_loop_t * loop, uv_fs_poll_t * handle, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_handle)
{
    if(uv_fs_poll_init_struct_inst.callback != NULL)
    {
        uv_fs_poll_init_MockReset ();
    }

    if(uv_fs_poll_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_poll_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_poll_init (uv_loop_t * loop, uv_fs_poll_t * handle)");
    uv_fs_poll_init_struct_inst.calls[uv_fs_poll_init_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_poll_init_struct_inst.calls[uv_fs_poll_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_poll_init_struct_inst.calls[uv_fs_poll_init_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_poll_init_struct_inst.calls[uv_fs_poll_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_poll_init_struct_inst.calls[uv_fs_poll_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_poll_init_struct_inst.calls[uv_fs_poll_init_struct_inst.expectedCalls].check_params = 1;
    uv_fs_poll_init_struct_inst.expectedCalls++;
}

int uv_fs_poll_start(uv_fs_poll_t * handle, uv_fs_poll_cb poll_cb, const char * path, unsigned int interval)
{
    int default_res = (int)uv_fs_poll_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_poll_start_struct_inst.actualCalls++;

    if (uv_fs_poll_start_struct_inst.callback != NULL)
    {
        return uv_fs_poll_start_struct_inst.callback (handle, poll_cb, path, interval, uv_fs_poll_start_struct_inst.actualCalls);
    }
    if (uv_fs_poll_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_poll_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_poll_start (uv_fs_poll_t * handle, uv_fs_poll_cb poll_cb, const char * path, unsigned int interval)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_poll_start(uv_fs_poll_t * handle, uv_fs_poll_cb poll_cb, const char * path, unsigned int interval)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_poll_start_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_poll_start_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_poll_start_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_poll_start_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_start', %s",uv_fs_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_poll_start_struct_inst.calls[0].match_poll_cb) {
            void * val1 = (void *) &uv_fs_poll_start_struct_inst.calls[0].poll_cb;
            void * val2 = (void *) &poll_cb;
            int match_result = uv_fs_poll_start_struct_inst.calls[0].match_poll_cb(val1, val2, "poll_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_start', %s",uv_fs_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_poll_start_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_poll_start_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_poll_start_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_start', %s",uv_fs_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_poll_start_struct_inst.calls[0].match_interval) {
            void * val1 = (void *) &uv_fs_poll_start_struct_inst.calls[0].interval;
            void * val2 = (void *) &interval;
            int match_result = uv_fs_poll_start_struct_inst.calls[0].match_interval(val1, val2, "interval", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_start', %s",uv_fs_poll_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_poll_start_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_poll_start_struct_inst.calls[opmock_i - 1] = uv_fs_poll_start_struct_inst.calls[opmock_i];
    }

    uv_fs_poll_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_poll_start_MockReset()
{
    uv_fs_poll_start_struct_inst.expectedCalls = 0;
    uv_fs_poll_start_struct_inst.actualCalls = 0;
    uv_fs_poll_start_struct_inst.callback = NULL;
}

void uv_fs_poll_start_MockWithCallback(OPMOCK_uv_fs_poll_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_poll_start_struct_inst.callback = callback;
    uv_fs_poll_start_struct_inst.expectedCalls = 0;
    uv_fs_poll_start_struct_inst.actualCalls = 0;
}

void uv_fs_poll_start_VerifyMock()
{
    if (uv_fs_poll_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_poll_start'",uv_fs_poll_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_poll_start_ExpectAndReturn (uv_fs_poll_t * handle, uv_fs_poll_cb poll_cb, const char * path, unsigned int interval, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_poll_cb, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_interval)
{
    if(uv_fs_poll_start_struct_inst.callback != NULL)
    {
        uv_fs_poll_start_MockReset ();
    }

    if(uv_fs_poll_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_poll_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_poll_start (uv_fs_poll_t * handle, uv_fs_poll_cb poll_cb, const char * path, unsigned int interval)");
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].poll_cb = (void *)poll_cb;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].interval = (unsigned int)interval;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].match_poll_cb = match_poll_cb;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].match_interval = match_interval;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_poll_start_struct_inst.calls[uv_fs_poll_start_struct_inst.expectedCalls].check_params = 1;
    uv_fs_poll_start_struct_inst.expectedCalls++;
}

int uv_fs_poll_stop(uv_fs_poll_t * handle)
{
    int default_res = (int)uv_fs_poll_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_poll_stop_struct_inst.actualCalls++;

    if (uv_fs_poll_stop_struct_inst.callback != NULL)
    {
        return uv_fs_poll_stop_struct_inst.callback (handle, uv_fs_poll_stop_struct_inst.actualCalls);
    }
    if (uv_fs_poll_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_poll_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_poll_stop (uv_fs_poll_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_poll_stop(uv_fs_poll_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_poll_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_poll_stop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_poll_stop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_poll_stop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_stop', %s",uv_fs_poll_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_poll_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_poll_stop_struct_inst.calls[opmock_i - 1] = uv_fs_poll_stop_struct_inst.calls[opmock_i];
    }

    uv_fs_poll_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_poll_stop_MockReset()
{
    uv_fs_poll_stop_struct_inst.expectedCalls = 0;
    uv_fs_poll_stop_struct_inst.actualCalls = 0;
    uv_fs_poll_stop_struct_inst.callback = NULL;
}

void uv_fs_poll_stop_MockWithCallback(OPMOCK_uv_fs_poll_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_poll_stop_struct_inst.callback = callback;
    uv_fs_poll_stop_struct_inst.expectedCalls = 0;
    uv_fs_poll_stop_struct_inst.actualCalls = 0;
}

void uv_fs_poll_stop_VerifyMock()
{
    if (uv_fs_poll_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_poll_stop'",uv_fs_poll_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_poll_stop_ExpectAndReturn (uv_fs_poll_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_fs_poll_stop_struct_inst.callback != NULL)
    {
        uv_fs_poll_stop_MockReset ();
    }

    if(uv_fs_poll_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_poll_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_poll_stop (uv_fs_poll_t * handle)");
    uv_fs_poll_stop_struct_inst.calls[uv_fs_poll_stop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_poll_stop_struct_inst.calls[uv_fs_poll_stop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_poll_stop_struct_inst.calls[uv_fs_poll_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_poll_stop_struct_inst.calls[uv_fs_poll_stop_struct_inst.expectedCalls].check_params = 1;
    uv_fs_poll_stop_struct_inst.expectedCalls++;
}

int uv_fs_poll_getpath(uv_fs_poll_t * handle, char * buf, size_t * len)
{
    int default_res = (int)uv_fs_poll_getpath_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_poll_getpath_struct_inst.actualCalls++;

    if (uv_fs_poll_getpath_struct_inst.callback != NULL)
    {
        return uv_fs_poll_getpath_struct_inst.callback (handle, buf, len, uv_fs_poll_getpath_struct_inst.actualCalls);
    }
    if (uv_fs_poll_getpath_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_poll_getpath', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_poll_getpath (uv_fs_poll_t * handle, char * buf, size_t * len)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_poll_getpath(uv_fs_poll_t * handle, char * buf, size_t * len)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_poll_getpath_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_poll_getpath_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_poll_getpath_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_poll_getpath_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_getpath', %s",uv_fs_poll_getpath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_poll_getpath_struct_inst.calls[0].match_buf) {
            void * val1 = (void *) &uv_fs_poll_getpath_struct_inst.calls[0].buf;
            void * val2 = (void *) &buf;
            int match_result = uv_fs_poll_getpath_struct_inst.calls[0].match_buf(val1, val2, "buf", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_getpath', %s",uv_fs_poll_getpath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_poll_getpath_struct_inst.calls[0].match_len) {
            void * val1 = (void *) &uv_fs_poll_getpath_struct_inst.calls[0].len;
            void * val2 = (void *) &len;
            int match_result = uv_fs_poll_getpath_struct_inst.calls[0].match_len(val1, val2, "len", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_poll_getpath', %s",uv_fs_poll_getpath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_poll_getpath_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_poll_getpath_struct_inst.calls[opmock_i - 1] = uv_fs_poll_getpath_struct_inst.calls[opmock_i];
    }

    uv_fs_poll_getpath_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_poll_getpath_MockReset()
{
    uv_fs_poll_getpath_struct_inst.expectedCalls = 0;
    uv_fs_poll_getpath_struct_inst.actualCalls = 0;
    uv_fs_poll_getpath_struct_inst.callback = NULL;
}

void uv_fs_poll_getpath_MockWithCallback(OPMOCK_uv_fs_poll_getpath_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_poll_getpath_struct_inst.callback = callback;
    uv_fs_poll_getpath_struct_inst.expectedCalls = 0;
    uv_fs_poll_getpath_struct_inst.actualCalls = 0;
}

void uv_fs_poll_getpath_VerifyMock()
{
    if (uv_fs_poll_getpath_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_poll_getpath'",uv_fs_poll_getpath_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_poll_getpath_ExpectAndReturn (uv_fs_poll_t * handle, char * buf, size_t * len, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_buf, OPMOCK_MATCHER match_len)
{
    if(uv_fs_poll_getpath_struct_inst.callback != NULL)
    {
        uv_fs_poll_getpath_MockReset ();
    }

    if(uv_fs_poll_getpath_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_poll_getpath_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_poll_getpath (uv_fs_poll_t * handle, char * buf, size_t * len)");
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].buf = (void *)buf;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].len = (void *)len;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].match_buf = match_buf;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].match_len = match_len;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_poll_getpath_struct_inst.calls[uv_fs_poll_getpath_struct_inst.expectedCalls].check_params = 1;
    uv_fs_poll_getpath_struct_inst.expectedCalls++;
}

int uv_signal_init(uv_loop_t * loop, uv_signal_t * handle)
{
    int default_res = (int)uv_signal_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_signal_init_struct_inst.actualCalls++;

    if (uv_signal_init_struct_inst.callback != NULL)
    {
        return uv_signal_init_struct_inst.callback (loop, handle, uv_signal_init_struct_inst.actualCalls);
    }
    if (uv_signal_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_signal_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_signal_init (uv_loop_t * loop, uv_signal_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_signal_init(uv_loop_t * loop, uv_signal_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_signal_init_struct_inst.calls[0].check_params == 1) {
        if(uv_signal_init_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_signal_init_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_signal_init_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_signal_init', %s",uv_signal_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_signal_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_signal_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_signal_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_signal_init', %s",uv_signal_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_signal_init_struct_inst.expectedCalls; opmock_i++) {
        uv_signal_init_struct_inst.calls[opmock_i - 1] = uv_signal_init_struct_inst.calls[opmock_i];
    }

    uv_signal_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_signal_init_MockReset()
{
    uv_signal_init_struct_inst.expectedCalls = 0;
    uv_signal_init_struct_inst.actualCalls = 0;
    uv_signal_init_struct_inst.callback = NULL;
}

void uv_signal_init_MockWithCallback(OPMOCK_uv_signal_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_signal_init_struct_inst.callback = callback;
    uv_signal_init_struct_inst.expectedCalls = 0;
    uv_signal_init_struct_inst.actualCalls = 0;
}

void uv_signal_init_VerifyMock()
{
    if (uv_signal_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_signal_init'",uv_signal_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_signal_init_ExpectAndReturn (uv_loop_t * loop, uv_signal_t * handle, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_handle)
{
    if(uv_signal_init_struct_inst.callback != NULL)
    {
        uv_signal_init_MockReset ();
    }

    if(uv_signal_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_signal_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_signal_init (uv_loop_t * loop, uv_signal_t * handle)");
    uv_signal_init_struct_inst.calls[uv_signal_init_struct_inst.expectedCalls].loop = (void *)loop;
    uv_signal_init_struct_inst.calls[uv_signal_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_signal_init_struct_inst.calls[uv_signal_init_struct_inst.expectedCalls].match_loop = match_loop;
    uv_signal_init_struct_inst.calls[uv_signal_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_signal_init_struct_inst.calls[uv_signal_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_signal_init_struct_inst.calls[uv_signal_init_struct_inst.expectedCalls].check_params = 1;
    uv_signal_init_struct_inst.expectedCalls++;
}

int uv_signal_start(uv_signal_t * handle, uv_signal_cb signal_cb, int signum)
{
    int default_res = (int)uv_signal_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_signal_start_struct_inst.actualCalls++;

    if (uv_signal_start_struct_inst.callback != NULL)
    {
        return uv_signal_start_struct_inst.callback (handle, signal_cb, signum, uv_signal_start_struct_inst.actualCalls);
    }
    if (uv_signal_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_signal_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_signal_start (uv_signal_t * handle, uv_signal_cb signal_cb, int signum)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_signal_start(uv_signal_t * handle, uv_signal_cb signal_cb, int signum)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_signal_start_struct_inst.calls[0].check_params == 1) {
        if(uv_signal_start_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_signal_start_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_signal_start_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_signal_start', %s",uv_signal_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_signal_start_struct_inst.calls[0].match_signal_cb) {
            void * val1 = (void *) &uv_signal_start_struct_inst.calls[0].signal_cb;
            void * val2 = (void *) &signal_cb;
            int match_result = uv_signal_start_struct_inst.calls[0].match_signal_cb(val1, val2, "signal_cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_signal_start', %s",uv_signal_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_signal_start_struct_inst.calls[0].match_signum) {
            void * val1 = (void *) &uv_signal_start_struct_inst.calls[0].signum;
            void * val2 = (void *) &signum;
            int match_result = uv_signal_start_struct_inst.calls[0].match_signum(val1, val2, "signum", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_signal_start', %s",uv_signal_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_signal_start_struct_inst.expectedCalls; opmock_i++) {
        uv_signal_start_struct_inst.calls[opmock_i - 1] = uv_signal_start_struct_inst.calls[opmock_i];
    }

    uv_signal_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_signal_start_MockReset()
{
    uv_signal_start_struct_inst.expectedCalls = 0;
    uv_signal_start_struct_inst.actualCalls = 0;
    uv_signal_start_struct_inst.callback = NULL;
}

void uv_signal_start_MockWithCallback(OPMOCK_uv_signal_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_signal_start_struct_inst.callback = callback;
    uv_signal_start_struct_inst.expectedCalls = 0;
    uv_signal_start_struct_inst.actualCalls = 0;
}

void uv_signal_start_VerifyMock()
{
    if (uv_signal_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_signal_start'",uv_signal_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_signal_start_ExpectAndReturn (uv_signal_t * handle, uv_signal_cb signal_cb, int signum, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_signal_cb, OPMOCK_MATCHER match_signum)
{
    if(uv_signal_start_struct_inst.callback != NULL)
    {
        uv_signal_start_MockReset ();
    }

    if(uv_signal_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_signal_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_signal_start (uv_signal_t * handle, uv_signal_cb signal_cb, int signum)");
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].handle = (void *)handle;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].signal_cb = (void *)signal_cb;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].signum = (int)signum;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].match_handle = match_handle;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].match_signal_cb = match_signal_cb;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].match_signum = match_signum;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_signal_start_struct_inst.calls[uv_signal_start_struct_inst.expectedCalls].check_params = 1;
    uv_signal_start_struct_inst.expectedCalls++;
}

int uv_signal_stop(uv_signal_t * handle)
{
    int default_res = (int)uv_signal_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_signal_stop_struct_inst.actualCalls++;

    if (uv_signal_stop_struct_inst.callback != NULL)
    {
        return uv_signal_stop_struct_inst.callback (handle, uv_signal_stop_struct_inst.actualCalls);
    }
    if (uv_signal_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_signal_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_signal_stop (uv_signal_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_signal_stop(uv_signal_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_signal_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_signal_stop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_signal_stop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_signal_stop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_signal_stop', %s",uv_signal_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_signal_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_signal_stop_struct_inst.calls[opmock_i - 1] = uv_signal_stop_struct_inst.calls[opmock_i];
    }

    uv_signal_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_signal_stop_MockReset()
{
    uv_signal_stop_struct_inst.expectedCalls = 0;
    uv_signal_stop_struct_inst.actualCalls = 0;
    uv_signal_stop_struct_inst.callback = NULL;
}

void uv_signal_stop_MockWithCallback(OPMOCK_uv_signal_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_signal_stop_struct_inst.callback = callback;
    uv_signal_stop_struct_inst.expectedCalls = 0;
    uv_signal_stop_struct_inst.actualCalls = 0;
}

void uv_signal_stop_VerifyMock()
{
    if (uv_signal_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_signal_stop'",uv_signal_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_signal_stop_ExpectAndReturn (uv_signal_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_signal_stop_struct_inst.callback != NULL)
    {
        uv_signal_stop_MockReset ();
    }

    if(uv_signal_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_signal_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_signal_stop (uv_signal_t * handle)");
    uv_signal_stop_struct_inst.calls[uv_signal_stop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_signal_stop_struct_inst.calls[uv_signal_stop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_signal_stop_struct_inst.calls[uv_signal_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_signal_stop_struct_inst.calls[uv_signal_stop_struct_inst.expectedCalls].check_params = 1;
    uv_signal_stop_struct_inst.expectedCalls++;
}

void uv_loadavg(double  avg [3])
{
    int opmock_i;
    uv_loadavg_struct_inst.actualCalls++;

    if (uv_loadavg_struct_inst.callback != NULL)
    {
        uv_loadavg_struct_inst.callback (avg, uv_loadavg_struct_inst.actualCalls);
        return;
    }
    if (uv_loadavg_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_loadavg', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_loadavg (double  avg [3])") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_loadavg(double  avg [3])',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_loadavg_struct_inst.calls[0].check_params == 1) {
        if(uv_loadavg_struct_inst.calls[0].match_avg) {
            void * val1 = (void *) &uv_loadavg_struct_inst.calls[0].avg;
            void * val2 = (void *) &avg;
            int match_result = uv_loadavg_struct_inst.calls[0].match_avg(val1, val2, "avg", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_loadavg', %s",uv_loadavg_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_loadavg_struct_inst.expectedCalls; opmock_i++) {
        uv_loadavg_struct_inst.calls[opmock_i - 1] = uv_loadavg_struct_inst.calls[opmock_i];
    }

    uv_loadavg_struct_inst.expectedCalls--;
}

void uv_loadavg_MockReset()
{
    uv_loadavg_struct_inst.expectedCalls = 0;
    uv_loadavg_struct_inst.actualCalls = 0;
    uv_loadavg_struct_inst.callback = NULL;
}

void uv_loadavg_MockWithCallback(OPMOCK_uv_loadavg_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_loadavg_struct_inst.callback = callback;
    uv_loadavg_struct_inst.expectedCalls = 0;
    uv_loadavg_struct_inst.actualCalls = 0;
}

void uv_loadavg_VerifyMock()
{
    if (uv_loadavg_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_loadavg'",uv_loadavg_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_loadavg_ExpectAndReturn (double  avg [3], OPMOCK_MATCHER match_avg)
{
    if(uv_loadavg_struct_inst.callback != NULL)
    {
        uv_loadavg_MockReset ();
    }

    if(uv_loadavg_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_loadavg_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_loadavg (double  avg [3])");
    uv_loadavg_struct_inst.calls[uv_loadavg_struct_inst.expectedCalls].avg = (void *)avg;
    uv_loadavg_struct_inst.calls[uv_loadavg_struct_inst.expectedCalls].match_avg = match_avg;
    uv_loadavg_struct_inst.calls[uv_loadavg_struct_inst.expectedCalls].check_params = 1;
    uv_loadavg_struct_inst.expectedCalls++;
}

int uv_fs_event_init(uv_loop_t * loop, uv_fs_event_t * handle)
{
    int default_res = (int)uv_fs_event_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_event_init_struct_inst.actualCalls++;

    if (uv_fs_event_init_struct_inst.callback != NULL)
    {
        return uv_fs_event_init_struct_inst.callback (loop, handle, uv_fs_event_init_struct_inst.actualCalls);
    }
    if (uv_fs_event_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_event_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_event_init (uv_loop_t * loop, uv_fs_event_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_event_init(uv_loop_t * loop, uv_fs_event_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_event_init_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_event_init_struct_inst.calls[0].match_loop) {
            void * val1 = (void *) &uv_fs_event_init_struct_inst.calls[0].loop;
            void * val2 = (void *) &loop;
            int match_result = uv_fs_event_init_struct_inst.calls[0].match_loop(val1, val2, "loop", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_init', %s",uv_fs_event_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_event_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_event_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_event_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_init', %s",uv_fs_event_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_event_init_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_event_init_struct_inst.calls[opmock_i - 1] = uv_fs_event_init_struct_inst.calls[opmock_i];
    }

    uv_fs_event_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_event_init_MockReset()
{
    uv_fs_event_init_struct_inst.expectedCalls = 0;
    uv_fs_event_init_struct_inst.actualCalls = 0;
    uv_fs_event_init_struct_inst.callback = NULL;
}

void uv_fs_event_init_MockWithCallback(OPMOCK_uv_fs_event_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_event_init_struct_inst.callback = callback;
    uv_fs_event_init_struct_inst.expectedCalls = 0;
    uv_fs_event_init_struct_inst.actualCalls = 0;
}

void uv_fs_event_init_VerifyMock()
{
    if (uv_fs_event_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_event_init'",uv_fs_event_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_event_init_ExpectAndReturn (uv_loop_t * loop, uv_fs_event_t * handle, int to_return, OPMOCK_MATCHER match_loop, OPMOCK_MATCHER match_handle)
{
    if(uv_fs_event_init_struct_inst.callback != NULL)
    {
        uv_fs_event_init_MockReset ();
    }

    if(uv_fs_event_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_event_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_event_init (uv_loop_t * loop, uv_fs_event_t * handle)");
    uv_fs_event_init_struct_inst.calls[uv_fs_event_init_struct_inst.expectedCalls].loop = (void *)loop;
    uv_fs_event_init_struct_inst.calls[uv_fs_event_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_event_init_struct_inst.calls[uv_fs_event_init_struct_inst.expectedCalls].match_loop = match_loop;
    uv_fs_event_init_struct_inst.calls[uv_fs_event_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_event_init_struct_inst.calls[uv_fs_event_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_event_init_struct_inst.calls[uv_fs_event_init_struct_inst.expectedCalls].check_params = 1;
    uv_fs_event_init_struct_inst.expectedCalls++;
}

int uv_fs_event_start(uv_fs_event_t * handle, uv_fs_event_cb cb, const char * path, unsigned int flags)
{
    int default_res = (int)uv_fs_event_start_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_event_start_struct_inst.actualCalls++;

    if (uv_fs_event_start_struct_inst.callback != NULL)
    {
        return uv_fs_event_start_struct_inst.callback (handle, cb, path, flags, uv_fs_event_start_struct_inst.actualCalls);
    }
    if (uv_fs_event_start_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_event_start', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_event_start (uv_fs_event_t * handle, uv_fs_event_cb cb, const char * path, unsigned int flags)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_event_start(uv_fs_event_t * handle, uv_fs_event_cb cb, const char * path, unsigned int flags)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_event_start_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_event_start_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_event_start_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_event_start_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_start', %s",uv_fs_event_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_event_start_struct_inst.calls[0].match_cb) {
            void * val1 = (void *) &uv_fs_event_start_struct_inst.calls[0].cb;
            void * val2 = (void *) &cb;
            int match_result = uv_fs_event_start_struct_inst.calls[0].match_cb(val1, val2, "cb", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_start', %s",uv_fs_event_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_event_start_struct_inst.calls[0].match_path) {
            void * val1 = (void *) &uv_fs_event_start_struct_inst.calls[0].path;
            void * val2 = (void *) &path;
            int match_result = uv_fs_event_start_struct_inst.calls[0].match_path(val1, val2, "path", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_start', %s",uv_fs_event_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_event_start_struct_inst.calls[0].match_flags) {
            void * val1 = (void *) &uv_fs_event_start_struct_inst.calls[0].flags;
            void * val2 = (void *) &flags;
            int match_result = uv_fs_event_start_struct_inst.calls[0].match_flags(val1, val2, "flags", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_start', %s",uv_fs_event_start_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_event_start_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_event_start_struct_inst.calls[opmock_i - 1] = uv_fs_event_start_struct_inst.calls[opmock_i];
    }

    uv_fs_event_start_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_event_start_MockReset()
{
    uv_fs_event_start_struct_inst.expectedCalls = 0;
    uv_fs_event_start_struct_inst.actualCalls = 0;
    uv_fs_event_start_struct_inst.callback = NULL;
}

void uv_fs_event_start_MockWithCallback(OPMOCK_uv_fs_event_start_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_event_start_struct_inst.callback = callback;
    uv_fs_event_start_struct_inst.expectedCalls = 0;
    uv_fs_event_start_struct_inst.actualCalls = 0;
}

void uv_fs_event_start_VerifyMock()
{
    if (uv_fs_event_start_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_event_start'",uv_fs_event_start_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_event_start_ExpectAndReturn (uv_fs_event_t * handle, uv_fs_event_cb cb, const char * path, unsigned int flags, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_cb, OPMOCK_MATCHER match_path, OPMOCK_MATCHER match_flags)
{
    if(uv_fs_event_start_struct_inst.callback != NULL)
    {
        uv_fs_event_start_MockReset ();
    }

    if(uv_fs_event_start_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_event_start_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_event_start (uv_fs_event_t * handle, uv_fs_event_cb cb, const char * path, unsigned int flags)");
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].cb = (void *)cb;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].path = (void *)path;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].flags = (unsigned int)flags;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].match_cb = match_cb;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].match_path = match_path;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].match_flags = match_flags;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_event_start_struct_inst.calls[uv_fs_event_start_struct_inst.expectedCalls].check_params = 1;
    uv_fs_event_start_struct_inst.expectedCalls++;
}

int uv_fs_event_stop(uv_fs_event_t * handle)
{
    int default_res = (int)uv_fs_event_stop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_event_stop_struct_inst.actualCalls++;

    if (uv_fs_event_stop_struct_inst.callback != NULL)
    {
        return uv_fs_event_stop_struct_inst.callback (handle, uv_fs_event_stop_struct_inst.actualCalls);
    }
    if (uv_fs_event_stop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_event_stop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_event_stop (uv_fs_event_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_event_stop(uv_fs_event_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_event_stop_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_event_stop_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_event_stop_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_event_stop_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_stop', %s",uv_fs_event_stop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_event_stop_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_event_stop_struct_inst.calls[opmock_i - 1] = uv_fs_event_stop_struct_inst.calls[opmock_i];
    }

    uv_fs_event_stop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_event_stop_MockReset()
{
    uv_fs_event_stop_struct_inst.expectedCalls = 0;
    uv_fs_event_stop_struct_inst.actualCalls = 0;
    uv_fs_event_stop_struct_inst.callback = NULL;
}

void uv_fs_event_stop_MockWithCallback(OPMOCK_uv_fs_event_stop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_event_stop_struct_inst.callback = callback;
    uv_fs_event_stop_struct_inst.expectedCalls = 0;
    uv_fs_event_stop_struct_inst.actualCalls = 0;
}

void uv_fs_event_stop_VerifyMock()
{
    if (uv_fs_event_stop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_event_stop'",uv_fs_event_stop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_event_stop_ExpectAndReturn (uv_fs_event_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_fs_event_stop_struct_inst.callback != NULL)
    {
        uv_fs_event_stop_MockReset ();
    }

    if(uv_fs_event_stop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_event_stop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_event_stop (uv_fs_event_t * handle)");
    uv_fs_event_stop_struct_inst.calls[uv_fs_event_stop_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_event_stop_struct_inst.calls[uv_fs_event_stop_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_event_stop_struct_inst.calls[uv_fs_event_stop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_event_stop_struct_inst.calls[uv_fs_event_stop_struct_inst.expectedCalls].check_params = 1;
    uv_fs_event_stop_struct_inst.expectedCalls++;
}

int uv_fs_event_getpath(uv_fs_event_t * handle, char * buf, size_t * len)
{
    int default_res = (int)uv_fs_event_getpath_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_fs_event_getpath_struct_inst.actualCalls++;

    if (uv_fs_event_getpath_struct_inst.callback != NULL)
    {
        return uv_fs_event_getpath_struct_inst.callback (handle, buf, len, uv_fs_event_getpath_struct_inst.actualCalls);
    }
    if (uv_fs_event_getpath_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_fs_event_getpath', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_fs_event_getpath (uv_fs_event_t * handle, char * buf, size_t * len)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_fs_event_getpath(uv_fs_event_t * handle, char * buf, size_t * len)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_fs_event_getpath_struct_inst.calls[0].check_params == 1) {
        if(uv_fs_event_getpath_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_fs_event_getpath_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_fs_event_getpath_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_getpath', %s",uv_fs_event_getpath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_event_getpath_struct_inst.calls[0].match_buf) {
            void * val1 = (void *) &uv_fs_event_getpath_struct_inst.calls[0].buf;
            void * val2 = (void *) &buf;
            int match_result = uv_fs_event_getpath_struct_inst.calls[0].match_buf(val1, val2, "buf", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_getpath', %s",uv_fs_event_getpath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_fs_event_getpath_struct_inst.calls[0].match_len) {
            void * val1 = (void *) &uv_fs_event_getpath_struct_inst.calls[0].len;
            void * val2 = (void *) &len;
            int match_result = uv_fs_event_getpath_struct_inst.calls[0].match_len(val1, val2, "len", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_fs_event_getpath', %s",uv_fs_event_getpath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_fs_event_getpath_struct_inst.expectedCalls; opmock_i++) {
        uv_fs_event_getpath_struct_inst.calls[opmock_i - 1] = uv_fs_event_getpath_struct_inst.calls[opmock_i];
    }

    uv_fs_event_getpath_struct_inst.expectedCalls--;
    return default_res;
}

void uv_fs_event_getpath_MockReset()
{
    uv_fs_event_getpath_struct_inst.expectedCalls = 0;
    uv_fs_event_getpath_struct_inst.actualCalls = 0;
    uv_fs_event_getpath_struct_inst.callback = NULL;
}

void uv_fs_event_getpath_MockWithCallback(OPMOCK_uv_fs_event_getpath_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_fs_event_getpath_struct_inst.callback = callback;
    uv_fs_event_getpath_struct_inst.expectedCalls = 0;
    uv_fs_event_getpath_struct_inst.actualCalls = 0;
}

void uv_fs_event_getpath_VerifyMock()
{
    if (uv_fs_event_getpath_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_fs_event_getpath'",uv_fs_event_getpath_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_fs_event_getpath_ExpectAndReturn (uv_fs_event_t * handle, char * buf, size_t * len, int to_return, OPMOCK_MATCHER match_handle, OPMOCK_MATCHER match_buf, OPMOCK_MATCHER match_len)
{
    if(uv_fs_event_getpath_struct_inst.callback != NULL)
    {
        uv_fs_event_getpath_MockReset ();
    }

    if(uv_fs_event_getpath_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_fs_event_getpath_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_fs_event_getpath (uv_fs_event_t * handle, char * buf, size_t * len)");
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].handle = (void *)handle;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].buf = (void *)buf;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].len = (void *)len;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].match_handle = match_handle;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].match_buf = match_buf;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].match_len = match_len;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_fs_event_getpath_struct_inst.calls[uv_fs_event_getpath_struct_inst.expectedCalls].check_params = 1;
    uv_fs_event_getpath_struct_inst.expectedCalls++;
}

int uv_ip4_addr(const char * ip, int port, struct sockaddr_in * addr)
{
    int default_res = (int)uv_ip4_addr_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_ip4_addr_struct_inst.actualCalls++;

    if (uv_ip4_addr_struct_inst.callback != NULL)
    {
        return uv_ip4_addr_struct_inst.callback (ip, port, addr, uv_ip4_addr_struct_inst.actualCalls);
    }
    if (uv_ip4_addr_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_ip4_addr', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_ip4_addr (const char * ip, int port, struct sockaddr_in * addr)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_ip4_addr(const char * ip, int port, struct sockaddr_in * addr)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_ip4_addr_struct_inst.calls[0].check_params == 1) {
        if(uv_ip4_addr_struct_inst.calls[0].match_ip) {
            void * val1 = (void *) &uv_ip4_addr_struct_inst.calls[0].ip;
            void * val2 = (void *) &ip;
            int match_result = uv_ip4_addr_struct_inst.calls[0].match_ip(val1, val2, "ip", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip4_addr', %s",uv_ip4_addr_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip4_addr_struct_inst.calls[0].match_port) {
            void * val1 = (void *) &uv_ip4_addr_struct_inst.calls[0].port;
            void * val2 = (void *) &port;
            int match_result = uv_ip4_addr_struct_inst.calls[0].match_port(val1, val2, "port", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip4_addr', %s",uv_ip4_addr_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip4_addr_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_ip4_addr_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_ip4_addr_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip4_addr', %s",uv_ip4_addr_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_ip4_addr_struct_inst.expectedCalls; opmock_i++) {
        uv_ip4_addr_struct_inst.calls[opmock_i - 1] = uv_ip4_addr_struct_inst.calls[opmock_i];
    }

    uv_ip4_addr_struct_inst.expectedCalls--;
    return default_res;
}

void uv_ip4_addr_MockReset()
{
    uv_ip4_addr_struct_inst.expectedCalls = 0;
    uv_ip4_addr_struct_inst.actualCalls = 0;
    uv_ip4_addr_struct_inst.callback = NULL;
}

void uv_ip4_addr_MockWithCallback(OPMOCK_uv_ip4_addr_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_ip4_addr_struct_inst.callback = callback;
    uv_ip4_addr_struct_inst.expectedCalls = 0;
    uv_ip4_addr_struct_inst.actualCalls = 0;
}

void uv_ip4_addr_VerifyMock()
{
    if (uv_ip4_addr_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_ip4_addr'",uv_ip4_addr_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_ip4_addr_ExpectAndReturn (const char * ip, int port, struct sockaddr_in * addr, int to_return, OPMOCK_MATCHER match_ip, OPMOCK_MATCHER match_port, OPMOCK_MATCHER match_addr)
{
    if(uv_ip4_addr_struct_inst.callback != NULL)
    {
        uv_ip4_addr_MockReset ();
    }

    if(uv_ip4_addr_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_ip4_addr_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_ip4_addr (const char * ip, int port, struct sockaddr_in * addr)");
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].ip = (void *)ip;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].port = (int)port;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].addr = (void *)addr;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].match_ip = match_ip;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].match_port = match_port;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].match_addr = match_addr;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_ip4_addr_struct_inst.calls[uv_ip4_addr_struct_inst.expectedCalls].check_params = 1;
    uv_ip4_addr_struct_inst.expectedCalls++;
}

int uv_ip6_addr(const char * ip, int port, struct sockaddr_in6 * addr)
{
    int default_res = (int)uv_ip6_addr_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_ip6_addr_struct_inst.actualCalls++;

    if (uv_ip6_addr_struct_inst.callback != NULL)
    {
        return uv_ip6_addr_struct_inst.callback (ip, port, addr, uv_ip6_addr_struct_inst.actualCalls);
    }
    if (uv_ip6_addr_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_ip6_addr', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_ip6_addr (const char * ip, int port, struct sockaddr_in6 * addr)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_ip6_addr(const char * ip, int port, struct sockaddr_in6 * addr)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_ip6_addr_struct_inst.calls[0].check_params == 1) {
        if(uv_ip6_addr_struct_inst.calls[0].match_ip) {
            void * val1 = (void *) &uv_ip6_addr_struct_inst.calls[0].ip;
            void * val2 = (void *) &ip;
            int match_result = uv_ip6_addr_struct_inst.calls[0].match_ip(val1, val2, "ip", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip6_addr', %s",uv_ip6_addr_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip6_addr_struct_inst.calls[0].match_port) {
            void * val1 = (void *) &uv_ip6_addr_struct_inst.calls[0].port;
            void * val2 = (void *) &port;
            int match_result = uv_ip6_addr_struct_inst.calls[0].match_port(val1, val2, "port", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip6_addr', %s",uv_ip6_addr_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip6_addr_struct_inst.calls[0].match_addr) {
            void * val1 = (void *) &uv_ip6_addr_struct_inst.calls[0].addr;
            void * val2 = (void *) &addr;
            int match_result = uv_ip6_addr_struct_inst.calls[0].match_addr(val1, val2, "addr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip6_addr', %s",uv_ip6_addr_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_ip6_addr_struct_inst.expectedCalls; opmock_i++) {
        uv_ip6_addr_struct_inst.calls[opmock_i - 1] = uv_ip6_addr_struct_inst.calls[opmock_i];
    }

    uv_ip6_addr_struct_inst.expectedCalls--;
    return default_res;
}

void uv_ip6_addr_MockReset()
{
    uv_ip6_addr_struct_inst.expectedCalls = 0;
    uv_ip6_addr_struct_inst.actualCalls = 0;
    uv_ip6_addr_struct_inst.callback = NULL;
}

void uv_ip6_addr_MockWithCallback(OPMOCK_uv_ip6_addr_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_ip6_addr_struct_inst.callback = callback;
    uv_ip6_addr_struct_inst.expectedCalls = 0;
    uv_ip6_addr_struct_inst.actualCalls = 0;
}

void uv_ip6_addr_VerifyMock()
{
    if (uv_ip6_addr_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_ip6_addr'",uv_ip6_addr_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_ip6_addr_ExpectAndReturn (const char * ip, int port, struct sockaddr_in6 * addr, int to_return, OPMOCK_MATCHER match_ip, OPMOCK_MATCHER match_port, OPMOCK_MATCHER match_addr)
{
    if(uv_ip6_addr_struct_inst.callback != NULL)
    {
        uv_ip6_addr_MockReset ();
    }

    if(uv_ip6_addr_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_ip6_addr_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_ip6_addr (const char * ip, int port, struct sockaddr_in6 * addr)");
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].ip = (void *)ip;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].port = (int)port;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].addr = (void *)addr;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].match_ip = match_ip;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].match_port = match_port;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].match_addr = match_addr;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_ip6_addr_struct_inst.calls[uv_ip6_addr_struct_inst.expectedCalls].check_params = 1;
    uv_ip6_addr_struct_inst.expectedCalls++;
}

int uv_ip4_name(const struct sockaddr_in * src, char * dst, size_t size)
{
    int default_res = (int)uv_ip4_name_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_ip4_name_struct_inst.actualCalls++;

    if (uv_ip4_name_struct_inst.callback != NULL)
    {
        return uv_ip4_name_struct_inst.callback (src, dst, size, uv_ip4_name_struct_inst.actualCalls);
    }
    if (uv_ip4_name_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_ip4_name', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_ip4_name (const struct sockaddr_in * src, char * dst, size_t size)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_ip4_name(const struct sockaddr_in * src, char * dst, size_t size)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_ip4_name_struct_inst.calls[0].check_params == 1) {
        if(uv_ip4_name_struct_inst.calls[0].match_src) {
            void * val1 = (void *) &uv_ip4_name_struct_inst.calls[0].src;
            void * val2 = (void *) &src;
            int match_result = uv_ip4_name_struct_inst.calls[0].match_src(val1, val2, "src", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip4_name', %s",uv_ip4_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip4_name_struct_inst.calls[0].match_dst) {
            void * val1 = (void *) &uv_ip4_name_struct_inst.calls[0].dst;
            void * val2 = (void *) &dst;
            int match_result = uv_ip4_name_struct_inst.calls[0].match_dst(val1, val2, "dst", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip4_name', %s",uv_ip4_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip4_name_struct_inst.calls[0].match_size) {
            void * val1 = (void *) &uv_ip4_name_struct_inst.calls[0].size;
            void * val2 = (void *) &size;
            int match_result = uv_ip4_name_struct_inst.calls[0].match_size(val1, val2, "size", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip4_name', %s",uv_ip4_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_ip4_name_struct_inst.expectedCalls; opmock_i++) {
        uv_ip4_name_struct_inst.calls[opmock_i - 1] = uv_ip4_name_struct_inst.calls[opmock_i];
    }

    uv_ip4_name_struct_inst.expectedCalls--;
    return default_res;
}

void uv_ip4_name_MockReset()
{
    uv_ip4_name_struct_inst.expectedCalls = 0;
    uv_ip4_name_struct_inst.actualCalls = 0;
    uv_ip4_name_struct_inst.callback = NULL;
}

void uv_ip4_name_MockWithCallback(OPMOCK_uv_ip4_name_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_ip4_name_struct_inst.callback = callback;
    uv_ip4_name_struct_inst.expectedCalls = 0;
    uv_ip4_name_struct_inst.actualCalls = 0;
}

void uv_ip4_name_VerifyMock()
{
    if (uv_ip4_name_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_ip4_name'",uv_ip4_name_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_ip4_name_ExpectAndReturn (const struct sockaddr_in * src, char * dst, size_t size, int to_return, OPMOCK_MATCHER match_src, OPMOCK_MATCHER match_dst, OPMOCK_MATCHER match_size)
{
    if(uv_ip4_name_struct_inst.callback != NULL)
    {
        uv_ip4_name_MockReset ();
    }

    if(uv_ip4_name_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_ip4_name_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_ip4_name (const struct sockaddr_in * src, char * dst, size_t size)");
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].src = (void *)src;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].dst = (void *)dst;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].size = (unsigned long)size;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].match_src = match_src;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].match_dst = match_dst;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].match_size = match_size;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_ip4_name_struct_inst.calls[uv_ip4_name_struct_inst.expectedCalls].check_params = 1;
    uv_ip4_name_struct_inst.expectedCalls++;
}

int uv_ip6_name(const struct sockaddr_in6 * src, char * dst, size_t size)
{
    int default_res = (int)uv_ip6_name_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_ip6_name_struct_inst.actualCalls++;

    if (uv_ip6_name_struct_inst.callback != NULL)
    {
        return uv_ip6_name_struct_inst.callback (src, dst, size, uv_ip6_name_struct_inst.actualCalls);
    }
    if (uv_ip6_name_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_ip6_name', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_ip6_name (const struct sockaddr_in6 * src, char * dst, size_t size)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_ip6_name(const struct sockaddr_in6 * src, char * dst, size_t size)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_ip6_name_struct_inst.calls[0].check_params == 1) {
        if(uv_ip6_name_struct_inst.calls[0].match_src) {
            void * val1 = (void *) &uv_ip6_name_struct_inst.calls[0].src;
            void * val2 = (void *) &src;
            int match_result = uv_ip6_name_struct_inst.calls[0].match_src(val1, val2, "src", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip6_name', %s",uv_ip6_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip6_name_struct_inst.calls[0].match_dst) {
            void * val1 = (void *) &uv_ip6_name_struct_inst.calls[0].dst;
            void * val2 = (void *) &dst;
            int match_result = uv_ip6_name_struct_inst.calls[0].match_dst(val1, val2, "dst", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip6_name', %s",uv_ip6_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_ip6_name_struct_inst.calls[0].match_size) {
            void * val1 = (void *) &uv_ip6_name_struct_inst.calls[0].size;
            void * val2 = (void *) &size;
            int match_result = uv_ip6_name_struct_inst.calls[0].match_size(val1, val2, "size", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_ip6_name', %s",uv_ip6_name_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_ip6_name_struct_inst.expectedCalls; opmock_i++) {
        uv_ip6_name_struct_inst.calls[opmock_i - 1] = uv_ip6_name_struct_inst.calls[opmock_i];
    }

    uv_ip6_name_struct_inst.expectedCalls--;
    return default_res;
}

void uv_ip6_name_MockReset()
{
    uv_ip6_name_struct_inst.expectedCalls = 0;
    uv_ip6_name_struct_inst.actualCalls = 0;
    uv_ip6_name_struct_inst.callback = NULL;
}

void uv_ip6_name_MockWithCallback(OPMOCK_uv_ip6_name_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_ip6_name_struct_inst.callback = callback;
    uv_ip6_name_struct_inst.expectedCalls = 0;
    uv_ip6_name_struct_inst.actualCalls = 0;
}

void uv_ip6_name_VerifyMock()
{
    if (uv_ip6_name_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_ip6_name'",uv_ip6_name_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_ip6_name_ExpectAndReturn (const struct sockaddr_in6 * src, char * dst, size_t size, int to_return, OPMOCK_MATCHER match_src, OPMOCK_MATCHER match_dst, OPMOCK_MATCHER match_size)
{
    if(uv_ip6_name_struct_inst.callback != NULL)
    {
        uv_ip6_name_MockReset ();
    }

    if(uv_ip6_name_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_ip6_name_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_ip6_name (const struct sockaddr_in6 * src, char * dst, size_t size)");
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].src = (void *)src;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].dst = (void *)dst;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].size = (unsigned long)size;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].match_src = match_src;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].match_dst = match_dst;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].match_size = match_size;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_ip6_name_struct_inst.calls[uv_ip6_name_struct_inst.expectedCalls].check_params = 1;
    uv_ip6_name_struct_inst.expectedCalls++;
}

int uv_inet_ntop(int af, const void * src, char * dst, size_t size)
{
    int default_res = (int)uv_inet_ntop_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_inet_ntop_struct_inst.actualCalls++;

    if (uv_inet_ntop_struct_inst.callback != NULL)
    {
        return uv_inet_ntop_struct_inst.callback (af, src, dst, size, uv_inet_ntop_struct_inst.actualCalls);
    }
    if (uv_inet_ntop_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_inet_ntop', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_inet_ntop (int af, const void * src, char * dst, size_t size)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_inet_ntop(int af, const void * src, char * dst, size_t size)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_inet_ntop_struct_inst.calls[0].check_params == 1) {
        if(uv_inet_ntop_struct_inst.calls[0].match_af) {
            void * val1 = (void *) &uv_inet_ntop_struct_inst.calls[0].af;
            void * val2 = (void *) &af;
            int match_result = uv_inet_ntop_struct_inst.calls[0].match_af(val1, val2, "af", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_ntop', %s",uv_inet_ntop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_inet_ntop_struct_inst.calls[0].match_src) {
            void * val1 = (void *) &uv_inet_ntop_struct_inst.calls[0].src;
            void * val2 = (void *) &src;
            int match_result = uv_inet_ntop_struct_inst.calls[0].match_src(val1, val2, "src", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_ntop', %s",uv_inet_ntop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_inet_ntop_struct_inst.calls[0].match_dst) {
            void * val1 = (void *) &uv_inet_ntop_struct_inst.calls[0].dst;
            void * val2 = (void *) &dst;
            int match_result = uv_inet_ntop_struct_inst.calls[0].match_dst(val1, val2, "dst", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_ntop', %s",uv_inet_ntop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_inet_ntop_struct_inst.calls[0].match_size) {
            void * val1 = (void *) &uv_inet_ntop_struct_inst.calls[0].size;
            void * val2 = (void *) &size;
            int match_result = uv_inet_ntop_struct_inst.calls[0].match_size(val1, val2, "size", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_ntop', %s",uv_inet_ntop_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_inet_ntop_struct_inst.expectedCalls; opmock_i++) {
        uv_inet_ntop_struct_inst.calls[opmock_i - 1] = uv_inet_ntop_struct_inst.calls[opmock_i];
    }

    uv_inet_ntop_struct_inst.expectedCalls--;
    return default_res;
}

void uv_inet_ntop_MockReset()
{
    uv_inet_ntop_struct_inst.expectedCalls = 0;
    uv_inet_ntop_struct_inst.actualCalls = 0;
    uv_inet_ntop_struct_inst.callback = NULL;
}

void uv_inet_ntop_MockWithCallback(OPMOCK_uv_inet_ntop_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_inet_ntop_struct_inst.callback = callback;
    uv_inet_ntop_struct_inst.expectedCalls = 0;
    uv_inet_ntop_struct_inst.actualCalls = 0;
}

void uv_inet_ntop_VerifyMock()
{
    if (uv_inet_ntop_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_inet_ntop'",uv_inet_ntop_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_inet_ntop_ExpectAndReturn (int af, const void * src, char * dst, size_t size, int to_return, OPMOCK_MATCHER match_af, OPMOCK_MATCHER match_src, OPMOCK_MATCHER match_dst, OPMOCK_MATCHER match_size)
{
    if(uv_inet_ntop_struct_inst.callback != NULL)
    {
        uv_inet_ntop_MockReset ();
    }

    if(uv_inet_ntop_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_inet_ntop_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_inet_ntop (int af, const void * src, char * dst, size_t size)");
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].af = (int)af;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].src = (void *)src;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].dst = (void *)dst;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].size = (unsigned long)size;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].match_af = match_af;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].match_src = match_src;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].match_dst = match_dst;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].match_size = match_size;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_inet_ntop_struct_inst.calls[uv_inet_ntop_struct_inst.expectedCalls].check_params = 1;
    uv_inet_ntop_struct_inst.expectedCalls++;
}

int uv_inet_pton(int af, const char * src, void * dst)
{
    int default_res = (int)uv_inet_pton_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_inet_pton_struct_inst.actualCalls++;

    if (uv_inet_pton_struct_inst.callback != NULL)
    {
        return uv_inet_pton_struct_inst.callback (af, src, dst, uv_inet_pton_struct_inst.actualCalls);
    }
    if (uv_inet_pton_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_inet_pton', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_inet_pton (int af, const char * src, void * dst)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_inet_pton(int af, const char * src, void * dst)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_inet_pton_struct_inst.calls[0].check_params == 1) {
        if(uv_inet_pton_struct_inst.calls[0].match_af) {
            void * val1 = (void *) &uv_inet_pton_struct_inst.calls[0].af;
            void * val2 = (void *) &af;
            int match_result = uv_inet_pton_struct_inst.calls[0].match_af(val1, val2, "af", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_pton', %s",uv_inet_pton_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_inet_pton_struct_inst.calls[0].match_src) {
            void * val1 = (void *) &uv_inet_pton_struct_inst.calls[0].src;
            void * val2 = (void *) &src;
            int match_result = uv_inet_pton_struct_inst.calls[0].match_src(val1, val2, "src", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_pton', %s",uv_inet_pton_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_inet_pton_struct_inst.calls[0].match_dst) {
            void * val1 = (void *) &uv_inet_pton_struct_inst.calls[0].dst;
            void * val2 = (void *) &dst;
            int match_result = uv_inet_pton_struct_inst.calls[0].match_dst(val1, val2, "dst", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_inet_pton', %s",uv_inet_pton_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_inet_pton_struct_inst.expectedCalls; opmock_i++) {
        uv_inet_pton_struct_inst.calls[opmock_i - 1] = uv_inet_pton_struct_inst.calls[opmock_i];
    }

    uv_inet_pton_struct_inst.expectedCalls--;
    return default_res;
}

void uv_inet_pton_MockReset()
{
    uv_inet_pton_struct_inst.expectedCalls = 0;
    uv_inet_pton_struct_inst.actualCalls = 0;
    uv_inet_pton_struct_inst.callback = NULL;
}

void uv_inet_pton_MockWithCallback(OPMOCK_uv_inet_pton_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_inet_pton_struct_inst.callback = callback;
    uv_inet_pton_struct_inst.expectedCalls = 0;
    uv_inet_pton_struct_inst.actualCalls = 0;
}

void uv_inet_pton_VerifyMock()
{
    if (uv_inet_pton_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_inet_pton'",uv_inet_pton_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_inet_pton_ExpectAndReturn (int af, const char * src, void * dst, int to_return, OPMOCK_MATCHER match_af, OPMOCK_MATCHER match_src, OPMOCK_MATCHER match_dst)
{
    if(uv_inet_pton_struct_inst.callback != NULL)
    {
        uv_inet_pton_MockReset ();
    }

    if(uv_inet_pton_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_inet_pton_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_inet_pton (int af, const char * src, void * dst)");
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].af = (int)af;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].src = (void *)src;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].dst = (void *)dst;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].match_af = match_af;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].match_src = match_src;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].match_dst = match_dst;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_inet_pton_struct_inst.calls[uv_inet_pton_struct_inst.expectedCalls].check_params = 1;
    uv_inet_pton_struct_inst.expectedCalls++;
}

int uv_exepath(char * buffer, size_t * size)
{
    int default_res = (int)uv_exepath_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_exepath_struct_inst.actualCalls++;

    if (uv_exepath_struct_inst.callback != NULL)
    {
        return uv_exepath_struct_inst.callback (buffer, size, uv_exepath_struct_inst.actualCalls);
    }
    if (uv_exepath_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_exepath', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_exepath (char * buffer, size_t * size)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_exepath(char * buffer, size_t * size)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_exepath_struct_inst.calls[0].check_params == 1) {
        if(uv_exepath_struct_inst.calls[0].match_buffer) {
            void * val1 = (void *) &uv_exepath_struct_inst.calls[0].buffer;
            void * val2 = (void *) &buffer;
            int match_result = uv_exepath_struct_inst.calls[0].match_buffer(val1, val2, "buffer", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_exepath', %s",uv_exepath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_exepath_struct_inst.calls[0].match_size) {
            void * val1 = (void *) &uv_exepath_struct_inst.calls[0].size;
            void * val2 = (void *) &size;
            int match_result = uv_exepath_struct_inst.calls[0].match_size(val1, val2, "size", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_exepath', %s",uv_exepath_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_exepath_struct_inst.expectedCalls; opmock_i++) {
        uv_exepath_struct_inst.calls[opmock_i - 1] = uv_exepath_struct_inst.calls[opmock_i];
    }

    uv_exepath_struct_inst.expectedCalls--;
    return default_res;
}

void uv_exepath_MockReset()
{
    uv_exepath_struct_inst.expectedCalls = 0;
    uv_exepath_struct_inst.actualCalls = 0;
    uv_exepath_struct_inst.callback = NULL;
}

void uv_exepath_MockWithCallback(OPMOCK_uv_exepath_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_exepath_struct_inst.callback = callback;
    uv_exepath_struct_inst.expectedCalls = 0;
    uv_exepath_struct_inst.actualCalls = 0;
}

void uv_exepath_VerifyMock()
{
    if (uv_exepath_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_exepath'",uv_exepath_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_exepath_ExpectAndReturn (char * buffer, size_t * size, int to_return, OPMOCK_MATCHER match_buffer, OPMOCK_MATCHER match_size)
{
    if(uv_exepath_struct_inst.callback != NULL)
    {
        uv_exepath_MockReset ();
    }

    if(uv_exepath_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_exepath_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_exepath (char * buffer, size_t * size)");
    uv_exepath_struct_inst.calls[uv_exepath_struct_inst.expectedCalls].buffer = (void *)buffer;
    uv_exepath_struct_inst.calls[uv_exepath_struct_inst.expectedCalls].size = (void *)size;
    uv_exepath_struct_inst.calls[uv_exepath_struct_inst.expectedCalls].match_buffer = match_buffer;
    uv_exepath_struct_inst.calls[uv_exepath_struct_inst.expectedCalls].match_size = match_size;
    uv_exepath_struct_inst.calls[uv_exepath_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_exepath_struct_inst.calls[uv_exepath_struct_inst.expectedCalls].check_params = 1;
    uv_exepath_struct_inst.expectedCalls++;
}

int uv_cwd(char * buffer, size_t * size)
{
    int default_res = (int)uv_cwd_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_cwd_struct_inst.actualCalls++;

    if (uv_cwd_struct_inst.callback != NULL)
    {
        return uv_cwd_struct_inst.callback (buffer, size, uv_cwd_struct_inst.actualCalls);
    }
    if (uv_cwd_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cwd', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_cwd (char * buffer, size_t * size)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_cwd(char * buffer, size_t * size)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cwd_struct_inst.calls[0].check_params == 1) {
        if(uv_cwd_struct_inst.calls[0].match_buffer) {
            void * val1 = (void *) &uv_cwd_struct_inst.calls[0].buffer;
            void * val2 = (void *) &buffer;
            int match_result = uv_cwd_struct_inst.calls[0].match_buffer(val1, val2, "buffer", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cwd', %s",uv_cwd_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_cwd_struct_inst.calls[0].match_size) {
            void * val1 = (void *) &uv_cwd_struct_inst.calls[0].size;
            void * val2 = (void *) &size;
            int match_result = uv_cwd_struct_inst.calls[0].match_size(val1, val2, "size", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cwd', %s",uv_cwd_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cwd_struct_inst.expectedCalls; opmock_i++) {
        uv_cwd_struct_inst.calls[opmock_i - 1] = uv_cwd_struct_inst.calls[opmock_i];
    }

    uv_cwd_struct_inst.expectedCalls--;
    return default_res;
}

void uv_cwd_MockReset()
{
    uv_cwd_struct_inst.expectedCalls = 0;
    uv_cwd_struct_inst.actualCalls = 0;
    uv_cwd_struct_inst.callback = NULL;
}

void uv_cwd_MockWithCallback(OPMOCK_uv_cwd_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cwd_struct_inst.callback = callback;
    uv_cwd_struct_inst.expectedCalls = 0;
    uv_cwd_struct_inst.actualCalls = 0;
}

void uv_cwd_VerifyMock()
{
    if (uv_cwd_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cwd'",uv_cwd_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cwd_ExpectAndReturn (char * buffer, size_t * size, int to_return, OPMOCK_MATCHER match_buffer, OPMOCK_MATCHER match_size)
{
    if(uv_cwd_struct_inst.callback != NULL)
    {
        uv_cwd_MockReset ();
    }

    if(uv_cwd_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cwd_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_cwd (char * buffer, size_t * size)");
    uv_cwd_struct_inst.calls[uv_cwd_struct_inst.expectedCalls].buffer = (void *)buffer;
    uv_cwd_struct_inst.calls[uv_cwd_struct_inst.expectedCalls].size = (void *)size;
    uv_cwd_struct_inst.calls[uv_cwd_struct_inst.expectedCalls].match_buffer = match_buffer;
    uv_cwd_struct_inst.calls[uv_cwd_struct_inst.expectedCalls].match_size = match_size;
    uv_cwd_struct_inst.calls[uv_cwd_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_cwd_struct_inst.calls[uv_cwd_struct_inst.expectedCalls].check_params = 1;
    uv_cwd_struct_inst.expectedCalls++;
}

int uv_chdir(const char * dir)
{
    int default_res = (int)uv_chdir_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_chdir_struct_inst.actualCalls++;

    if (uv_chdir_struct_inst.callback != NULL)
    {
        return uv_chdir_struct_inst.callback (dir, uv_chdir_struct_inst.actualCalls);
    }
    if (uv_chdir_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_chdir', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_chdir (const char * dir)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_chdir(const char * dir)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_chdir_struct_inst.calls[0].check_params == 1) {
        if(uv_chdir_struct_inst.calls[0].match_dir) {
            void * val1 = (void *) &uv_chdir_struct_inst.calls[0].dir;
            void * val2 = (void *) &dir;
            int match_result = uv_chdir_struct_inst.calls[0].match_dir(val1, val2, "dir", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_chdir', %s",uv_chdir_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_chdir_struct_inst.expectedCalls; opmock_i++) {
        uv_chdir_struct_inst.calls[opmock_i - 1] = uv_chdir_struct_inst.calls[opmock_i];
    }

    uv_chdir_struct_inst.expectedCalls--;
    return default_res;
}

void uv_chdir_MockReset()
{
    uv_chdir_struct_inst.expectedCalls = 0;
    uv_chdir_struct_inst.actualCalls = 0;
    uv_chdir_struct_inst.callback = NULL;
}

void uv_chdir_MockWithCallback(OPMOCK_uv_chdir_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_chdir_struct_inst.callback = callback;
    uv_chdir_struct_inst.expectedCalls = 0;
    uv_chdir_struct_inst.actualCalls = 0;
}

void uv_chdir_VerifyMock()
{
    if (uv_chdir_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_chdir'",uv_chdir_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_chdir_ExpectAndReturn (const char * dir, int to_return, OPMOCK_MATCHER match_dir)
{
    if(uv_chdir_struct_inst.callback != NULL)
    {
        uv_chdir_MockReset ();
    }

    if(uv_chdir_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_chdir_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_chdir (const char * dir)");
    uv_chdir_struct_inst.calls[uv_chdir_struct_inst.expectedCalls].dir = (void *)dir;
    uv_chdir_struct_inst.calls[uv_chdir_struct_inst.expectedCalls].match_dir = match_dir;
    uv_chdir_struct_inst.calls[uv_chdir_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_chdir_struct_inst.calls[uv_chdir_struct_inst.expectedCalls].check_params = 1;
    uv_chdir_struct_inst.expectedCalls++;
}

uint64_t uv_get_free_memory()
{
    uint64_t default_res = (uint64_t)uv_get_free_memory_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_get_free_memory_struct_inst.actualCalls++;

    if (uv_get_free_memory_struct_inst.callback != NULL)
    {
        return uv_get_free_memory_struct_inst.callback (uv_get_free_memory_struct_inst.actualCalls);
    }
    if (uv_get_free_memory_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_get_free_memory', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uint64_t uv_get_free_memory ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uint64_t uv_get_free_memory()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_get_free_memory_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_get_free_memory_struct_inst.expectedCalls; opmock_i++) {
        uv_get_free_memory_struct_inst.calls[opmock_i - 1] = uv_get_free_memory_struct_inst.calls[opmock_i];
    }

    uv_get_free_memory_struct_inst.expectedCalls--;
    return default_res;
}

void uv_get_free_memory_MockReset()
{
    uv_get_free_memory_struct_inst.expectedCalls = 0;
    uv_get_free_memory_struct_inst.actualCalls = 0;
    uv_get_free_memory_struct_inst.callback = NULL;
}

void uv_get_free_memory_MockWithCallback(OPMOCK_uv_get_free_memory_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_get_free_memory_struct_inst.callback = callback;
    uv_get_free_memory_struct_inst.expectedCalls = 0;
    uv_get_free_memory_struct_inst.actualCalls = 0;
}

void uv_get_free_memory_VerifyMock()
{
    if (uv_get_free_memory_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_get_free_memory'",uv_get_free_memory_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_get_free_memory_ExpectAndReturn (uint64_t to_return)
{
    if(uv_get_free_memory_struct_inst.callback != NULL)
    {
        uv_get_free_memory_MockReset ();
    }

    if(uv_get_free_memory_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_get_free_memory_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uint64_t uv_get_free_memory ()");
    uv_get_free_memory_struct_inst.calls[uv_get_free_memory_struct_inst.expectedCalls].to_return = (unsigned long long) to_return;
    uv_get_free_memory_struct_inst.calls[uv_get_free_memory_struct_inst.expectedCalls].check_params = 1;
    uv_get_free_memory_struct_inst.expectedCalls++;
}

uint64_t uv_get_total_memory()
{
    uint64_t default_res = (uint64_t)uv_get_total_memory_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_get_total_memory_struct_inst.actualCalls++;

    if (uv_get_total_memory_struct_inst.callback != NULL)
    {
        return uv_get_total_memory_struct_inst.callback (uv_get_total_memory_struct_inst.actualCalls);
    }
    if (uv_get_total_memory_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_get_total_memory', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uint64_t uv_get_total_memory ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uint64_t uv_get_total_memory()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_get_total_memory_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_get_total_memory_struct_inst.expectedCalls; opmock_i++) {
        uv_get_total_memory_struct_inst.calls[opmock_i - 1] = uv_get_total_memory_struct_inst.calls[opmock_i];
    }

    uv_get_total_memory_struct_inst.expectedCalls--;
    return default_res;
}

void uv_get_total_memory_MockReset()
{
    uv_get_total_memory_struct_inst.expectedCalls = 0;
    uv_get_total_memory_struct_inst.actualCalls = 0;
    uv_get_total_memory_struct_inst.callback = NULL;
}

void uv_get_total_memory_MockWithCallback(OPMOCK_uv_get_total_memory_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_get_total_memory_struct_inst.callback = callback;
    uv_get_total_memory_struct_inst.expectedCalls = 0;
    uv_get_total_memory_struct_inst.actualCalls = 0;
}

void uv_get_total_memory_VerifyMock()
{
    if (uv_get_total_memory_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_get_total_memory'",uv_get_total_memory_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_get_total_memory_ExpectAndReturn (uint64_t to_return)
{
    if(uv_get_total_memory_struct_inst.callback != NULL)
    {
        uv_get_total_memory_MockReset ();
    }

    if(uv_get_total_memory_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_get_total_memory_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uint64_t uv_get_total_memory ()");
    uv_get_total_memory_struct_inst.calls[uv_get_total_memory_struct_inst.expectedCalls].to_return = (unsigned long long) to_return;
    uv_get_total_memory_struct_inst.calls[uv_get_total_memory_struct_inst.expectedCalls].check_params = 1;
    uv_get_total_memory_struct_inst.expectedCalls++;
}

uint64_t uv_hrtime()
{
    uint64_t default_res = (uint64_t)uv_hrtime_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_hrtime_struct_inst.actualCalls++;

    if (uv_hrtime_struct_inst.callback != NULL)
    {
        return uv_hrtime_struct_inst.callback (uv_hrtime_struct_inst.actualCalls);
    }
    if (uv_hrtime_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_hrtime', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uint64_t uv_hrtime ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uint64_t uv_hrtime()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_hrtime_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_hrtime_struct_inst.expectedCalls; opmock_i++) {
        uv_hrtime_struct_inst.calls[opmock_i - 1] = uv_hrtime_struct_inst.calls[opmock_i];
    }

    uv_hrtime_struct_inst.expectedCalls--;
    return default_res;
}

void uv_hrtime_MockReset()
{
    uv_hrtime_struct_inst.expectedCalls = 0;
    uv_hrtime_struct_inst.actualCalls = 0;
    uv_hrtime_struct_inst.callback = NULL;
}

void uv_hrtime_MockWithCallback(OPMOCK_uv_hrtime_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_hrtime_struct_inst.callback = callback;
    uv_hrtime_struct_inst.expectedCalls = 0;
    uv_hrtime_struct_inst.actualCalls = 0;
}

void uv_hrtime_VerifyMock()
{
    if (uv_hrtime_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_hrtime'",uv_hrtime_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_hrtime_ExpectAndReturn (uint64_t to_return)
{
    if(uv_hrtime_struct_inst.callback != NULL)
    {
        uv_hrtime_MockReset ();
    }

    if(uv_hrtime_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_hrtime_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uint64_t uv_hrtime ()");
    uv_hrtime_struct_inst.calls[uv_hrtime_struct_inst.expectedCalls].to_return = (unsigned long long) to_return;
    uv_hrtime_struct_inst.calls[uv_hrtime_struct_inst.expectedCalls].check_params = 1;
    uv_hrtime_struct_inst.expectedCalls++;
}

void uv_disable_stdio_inheritance()
{
    int opmock_i;
    uv_disable_stdio_inheritance_struct_inst.actualCalls++;

    if (uv_disable_stdio_inheritance_struct_inst.callback != NULL)
    {
        uv_disable_stdio_inheritance_struct_inst.callback (uv_disable_stdio_inheritance_struct_inst.actualCalls);
        return;
    }
    if (uv_disable_stdio_inheritance_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_disable_stdio_inheritance', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_disable_stdio_inheritance ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_disable_stdio_inheritance()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_disable_stdio_inheritance_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_disable_stdio_inheritance_struct_inst.expectedCalls; opmock_i++) {
        uv_disable_stdio_inheritance_struct_inst.calls[opmock_i - 1] = uv_disable_stdio_inheritance_struct_inst.calls[opmock_i];
    }

    uv_disable_stdio_inheritance_struct_inst.expectedCalls--;
}

void uv_disable_stdio_inheritance_MockReset()
{
    uv_disable_stdio_inheritance_struct_inst.expectedCalls = 0;
    uv_disable_stdio_inheritance_struct_inst.actualCalls = 0;
    uv_disable_stdio_inheritance_struct_inst.callback = NULL;
}

void uv_disable_stdio_inheritance_MockWithCallback(OPMOCK_uv_disable_stdio_inheritance_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_disable_stdio_inheritance_struct_inst.callback = callback;
    uv_disable_stdio_inheritance_struct_inst.expectedCalls = 0;
    uv_disable_stdio_inheritance_struct_inst.actualCalls = 0;
}

void uv_disable_stdio_inheritance_VerifyMock()
{
    if (uv_disable_stdio_inheritance_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_disable_stdio_inheritance'",uv_disable_stdio_inheritance_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_disable_stdio_inheritance_ExpectAndReturn ()
{
    if(uv_disable_stdio_inheritance_struct_inst.callback != NULL)
    {
        uv_disable_stdio_inheritance_MockReset ();
    }

    if(uv_disable_stdio_inheritance_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_disable_stdio_inheritance_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_disable_stdio_inheritance ()");
    uv_disable_stdio_inheritance_struct_inst.calls[uv_disable_stdio_inheritance_struct_inst.expectedCalls].check_params = 1;
    uv_disable_stdio_inheritance_struct_inst.expectedCalls++;
}

int uv_dlopen(const char * filename, uv_lib_t * lib)
{
    int default_res = (int)uv_dlopen_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_dlopen_struct_inst.actualCalls++;

    if (uv_dlopen_struct_inst.callback != NULL)
    {
        return uv_dlopen_struct_inst.callback (filename, lib, uv_dlopen_struct_inst.actualCalls);
    }
    if (uv_dlopen_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_dlopen', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_dlopen (const char * filename, uv_lib_t * lib)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_dlopen(const char * filename, uv_lib_t * lib)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_dlopen_struct_inst.calls[0].check_params == 1) {
        if(uv_dlopen_struct_inst.calls[0].match_filename) {
            void * val1 = (void *) &uv_dlopen_struct_inst.calls[0].filename;
            void * val2 = (void *) &filename;
            int match_result = uv_dlopen_struct_inst.calls[0].match_filename(val1, val2, "filename", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlopen', %s",uv_dlopen_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_dlopen_struct_inst.calls[0].match_lib) {
            void * val1 = (void *) &uv_dlopen_struct_inst.calls[0].lib;
            void * val2 = (void *) &lib;
            int match_result = uv_dlopen_struct_inst.calls[0].match_lib(val1, val2, "lib", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlopen', %s",uv_dlopen_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_dlopen_struct_inst.expectedCalls; opmock_i++) {
        uv_dlopen_struct_inst.calls[opmock_i - 1] = uv_dlopen_struct_inst.calls[opmock_i];
    }

    uv_dlopen_struct_inst.expectedCalls--;
    return default_res;
}

void uv_dlopen_MockReset()
{
    uv_dlopen_struct_inst.expectedCalls = 0;
    uv_dlopen_struct_inst.actualCalls = 0;
    uv_dlopen_struct_inst.callback = NULL;
}

void uv_dlopen_MockWithCallback(OPMOCK_uv_dlopen_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_dlopen_struct_inst.callback = callback;
    uv_dlopen_struct_inst.expectedCalls = 0;
    uv_dlopen_struct_inst.actualCalls = 0;
}

void uv_dlopen_VerifyMock()
{
    if (uv_dlopen_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_dlopen'",uv_dlopen_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_dlopen_ExpectAndReturn (const char * filename, uv_lib_t * lib, int to_return, OPMOCK_MATCHER match_filename, OPMOCK_MATCHER match_lib)
{
    if(uv_dlopen_struct_inst.callback != NULL)
    {
        uv_dlopen_MockReset ();
    }

    if(uv_dlopen_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_dlopen_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_dlopen (const char * filename, uv_lib_t * lib)");
    uv_dlopen_struct_inst.calls[uv_dlopen_struct_inst.expectedCalls].filename = (void *)filename;
    uv_dlopen_struct_inst.calls[uv_dlopen_struct_inst.expectedCalls].lib = (void *)lib;
    uv_dlopen_struct_inst.calls[uv_dlopen_struct_inst.expectedCalls].match_filename = match_filename;
    uv_dlopen_struct_inst.calls[uv_dlopen_struct_inst.expectedCalls].match_lib = match_lib;
    uv_dlopen_struct_inst.calls[uv_dlopen_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_dlopen_struct_inst.calls[uv_dlopen_struct_inst.expectedCalls].check_params = 1;
    uv_dlopen_struct_inst.expectedCalls++;
}

void uv_dlclose(uv_lib_t * lib)
{
    int opmock_i;
    uv_dlclose_struct_inst.actualCalls++;

    if (uv_dlclose_struct_inst.callback != NULL)
    {
        uv_dlclose_struct_inst.callback (lib, uv_dlclose_struct_inst.actualCalls);
        return;
    }
    if (uv_dlclose_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_dlclose', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_dlclose (uv_lib_t * lib)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_dlclose(uv_lib_t * lib)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_dlclose_struct_inst.calls[0].check_params == 1) {
        if(uv_dlclose_struct_inst.calls[0].match_lib) {
            void * val1 = (void *) &uv_dlclose_struct_inst.calls[0].lib;
            void * val2 = (void *) &lib;
            int match_result = uv_dlclose_struct_inst.calls[0].match_lib(val1, val2, "lib", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlclose', %s",uv_dlclose_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_dlclose_struct_inst.expectedCalls; opmock_i++) {
        uv_dlclose_struct_inst.calls[opmock_i - 1] = uv_dlclose_struct_inst.calls[opmock_i];
    }

    uv_dlclose_struct_inst.expectedCalls--;
}

void uv_dlclose_MockReset()
{
    uv_dlclose_struct_inst.expectedCalls = 0;
    uv_dlclose_struct_inst.actualCalls = 0;
    uv_dlclose_struct_inst.callback = NULL;
}

void uv_dlclose_MockWithCallback(OPMOCK_uv_dlclose_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_dlclose_struct_inst.callback = callback;
    uv_dlclose_struct_inst.expectedCalls = 0;
    uv_dlclose_struct_inst.actualCalls = 0;
}

void uv_dlclose_VerifyMock()
{
    if (uv_dlclose_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_dlclose'",uv_dlclose_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_dlclose_ExpectAndReturn (uv_lib_t * lib, OPMOCK_MATCHER match_lib)
{
    if(uv_dlclose_struct_inst.callback != NULL)
    {
        uv_dlclose_MockReset ();
    }

    if(uv_dlclose_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_dlclose_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_dlclose (uv_lib_t * lib)");
    uv_dlclose_struct_inst.calls[uv_dlclose_struct_inst.expectedCalls].lib = (void *)lib;
    uv_dlclose_struct_inst.calls[uv_dlclose_struct_inst.expectedCalls].match_lib = match_lib;
    uv_dlclose_struct_inst.calls[uv_dlclose_struct_inst.expectedCalls].check_params = 1;
    uv_dlclose_struct_inst.expectedCalls++;
}

int uv_dlsym(uv_lib_t * lib, const char * name, void ** ptr)
{
    int default_res = (int)uv_dlsym_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_dlsym_struct_inst.actualCalls++;

    if (uv_dlsym_struct_inst.callback != NULL)
    {
        return uv_dlsym_struct_inst.callback (lib, name, ptr, uv_dlsym_struct_inst.actualCalls);
    }
    if (uv_dlsym_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_dlsym', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_dlsym (uv_lib_t * lib, const char * name, void ** ptr)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_dlsym(uv_lib_t * lib, const char * name, void ** ptr)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_dlsym_struct_inst.calls[0].check_params == 1) {
        if(uv_dlsym_struct_inst.calls[0].match_lib) {
            void * val1 = (void *) &uv_dlsym_struct_inst.calls[0].lib;
            void * val2 = (void *) &lib;
            int match_result = uv_dlsym_struct_inst.calls[0].match_lib(val1, val2, "lib", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlsym', %s",uv_dlsym_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_dlsym_struct_inst.calls[0].match_name) {
            void * val1 = (void *) &uv_dlsym_struct_inst.calls[0].name;
            void * val2 = (void *) &name;
            int match_result = uv_dlsym_struct_inst.calls[0].match_name(val1, val2, "name", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlsym', %s",uv_dlsym_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_dlsym_struct_inst.calls[0].match_ptr) {
            void * val1 = (void *) &uv_dlsym_struct_inst.calls[0].ptr;
            void * val2 = (void *) &ptr;
            int match_result = uv_dlsym_struct_inst.calls[0].match_ptr(val1, val2, "ptr", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlsym', %s",uv_dlsym_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_dlsym_struct_inst.expectedCalls; opmock_i++) {
        uv_dlsym_struct_inst.calls[opmock_i - 1] = uv_dlsym_struct_inst.calls[opmock_i];
    }

    uv_dlsym_struct_inst.expectedCalls--;
    return default_res;
}

void uv_dlsym_MockReset()
{
    uv_dlsym_struct_inst.expectedCalls = 0;
    uv_dlsym_struct_inst.actualCalls = 0;
    uv_dlsym_struct_inst.callback = NULL;
}

void uv_dlsym_MockWithCallback(OPMOCK_uv_dlsym_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_dlsym_struct_inst.callback = callback;
    uv_dlsym_struct_inst.expectedCalls = 0;
    uv_dlsym_struct_inst.actualCalls = 0;
}

void uv_dlsym_VerifyMock()
{
    if (uv_dlsym_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_dlsym'",uv_dlsym_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_dlsym_ExpectAndReturn (uv_lib_t * lib, const char * name, void ** ptr, int to_return, OPMOCK_MATCHER match_lib, OPMOCK_MATCHER match_name, OPMOCK_MATCHER match_ptr)
{
    if(uv_dlsym_struct_inst.callback != NULL)
    {
        uv_dlsym_MockReset ();
    }

    if(uv_dlsym_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_dlsym_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_dlsym (uv_lib_t * lib, const char * name, void ** ptr)");
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].lib = (void *)lib;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].name = (void *)name;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].ptr = (void *)ptr;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].match_lib = match_lib;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].match_name = match_name;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].match_ptr = match_ptr;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_dlsym_struct_inst.calls[uv_dlsym_struct_inst.expectedCalls].check_params = 1;
    uv_dlsym_struct_inst.expectedCalls++;
}

const char * uv_dlerror(const uv_lib_t * lib)
{
    const char * default_res = (const char *)uv_dlerror_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_dlerror_struct_inst.actualCalls++;

    if (uv_dlerror_struct_inst.callback != NULL)
    {
        return uv_dlerror_struct_inst.callback (lib, uv_dlerror_struct_inst.actualCalls);
    }
    if (uv_dlerror_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_dlerror', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "const char * uv_dlerror (const uv_lib_t * lib)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'const char * uv_dlerror(const uv_lib_t * lib)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_dlerror_struct_inst.calls[0].check_params == 1) {
        if(uv_dlerror_struct_inst.calls[0].match_lib) {
            void * val1 = (void *) &uv_dlerror_struct_inst.calls[0].lib;
            void * val2 = (void *) &lib;
            int match_result = uv_dlerror_struct_inst.calls[0].match_lib(val1, val2, "lib", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_dlerror', %s",uv_dlerror_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_dlerror_struct_inst.expectedCalls; opmock_i++) {
        uv_dlerror_struct_inst.calls[opmock_i - 1] = uv_dlerror_struct_inst.calls[opmock_i];
    }

    uv_dlerror_struct_inst.expectedCalls--;
    return default_res;
}

void uv_dlerror_MockReset()
{
    uv_dlerror_struct_inst.expectedCalls = 0;
    uv_dlerror_struct_inst.actualCalls = 0;
    uv_dlerror_struct_inst.callback = NULL;
}

void uv_dlerror_MockWithCallback(OPMOCK_uv_dlerror_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_dlerror_struct_inst.callback = callback;
    uv_dlerror_struct_inst.expectedCalls = 0;
    uv_dlerror_struct_inst.actualCalls = 0;
}

void uv_dlerror_VerifyMock()
{
    if (uv_dlerror_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_dlerror'",uv_dlerror_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_dlerror_ExpectAndReturn (const uv_lib_t * lib, const char * to_return, OPMOCK_MATCHER match_lib)
{
    if(uv_dlerror_struct_inst.callback != NULL)
    {
        uv_dlerror_MockReset ();
    }

    if(uv_dlerror_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_dlerror_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"const char * uv_dlerror (const uv_lib_t * lib)");
    uv_dlerror_struct_inst.calls[uv_dlerror_struct_inst.expectedCalls].lib = (void *)lib;
    uv_dlerror_struct_inst.calls[uv_dlerror_struct_inst.expectedCalls].match_lib = match_lib;
    uv_dlerror_struct_inst.calls[uv_dlerror_struct_inst.expectedCalls].to_return = ( char *) to_return;
    uv_dlerror_struct_inst.calls[uv_dlerror_struct_inst.expectedCalls].check_params = 1;
    uv_dlerror_struct_inst.expectedCalls++;
}

int uv_mutex_init(uv_mutex_t * handle)
{
    int default_res = (int)uv_mutex_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_mutex_init_struct_inst.actualCalls++;

    if (uv_mutex_init_struct_inst.callback != NULL)
    {
        return uv_mutex_init_struct_inst.callback (handle, uv_mutex_init_struct_inst.actualCalls);
    }
    if (uv_mutex_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_mutex_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_mutex_init (uv_mutex_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_mutex_init(uv_mutex_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_mutex_init_struct_inst.calls[0].check_params == 1) {
        if(uv_mutex_init_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_mutex_init_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_mutex_init_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_mutex_init', %s",uv_mutex_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_mutex_init_struct_inst.expectedCalls; opmock_i++) {
        uv_mutex_init_struct_inst.calls[opmock_i - 1] = uv_mutex_init_struct_inst.calls[opmock_i];
    }

    uv_mutex_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_mutex_init_MockReset()
{
    uv_mutex_init_struct_inst.expectedCalls = 0;
    uv_mutex_init_struct_inst.actualCalls = 0;
    uv_mutex_init_struct_inst.callback = NULL;
}

void uv_mutex_init_MockWithCallback(OPMOCK_uv_mutex_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_mutex_init_struct_inst.callback = callback;
    uv_mutex_init_struct_inst.expectedCalls = 0;
    uv_mutex_init_struct_inst.actualCalls = 0;
}

void uv_mutex_init_VerifyMock()
{
    if (uv_mutex_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_mutex_init'",uv_mutex_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_mutex_init_ExpectAndReturn (uv_mutex_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_mutex_init_struct_inst.callback != NULL)
    {
        uv_mutex_init_MockReset ();
    }

    if(uv_mutex_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_mutex_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_mutex_init (uv_mutex_t * handle)");
    uv_mutex_init_struct_inst.calls[uv_mutex_init_struct_inst.expectedCalls].handle = (void *)handle;
    uv_mutex_init_struct_inst.calls[uv_mutex_init_struct_inst.expectedCalls].match_handle = match_handle;
    uv_mutex_init_struct_inst.calls[uv_mutex_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_mutex_init_struct_inst.calls[uv_mutex_init_struct_inst.expectedCalls].check_params = 1;
    uv_mutex_init_struct_inst.expectedCalls++;
}

void uv_mutex_destroy(uv_mutex_t * handle)
{
    int opmock_i;
    uv_mutex_destroy_struct_inst.actualCalls++;

    if (uv_mutex_destroy_struct_inst.callback != NULL)
    {
        uv_mutex_destroy_struct_inst.callback (handle, uv_mutex_destroy_struct_inst.actualCalls);
        return;
    }
    if (uv_mutex_destroy_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_mutex_destroy', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_mutex_destroy (uv_mutex_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_mutex_destroy(uv_mutex_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_mutex_destroy_struct_inst.calls[0].check_params == 1) {
        if(uv_mutex_destroy_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_mutex_destroy_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_mutex_destroy_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_mutex_destroy', %s",uv_mutex_destroy_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_mutex_destroy_struct_inst.expectedCalls; opmock_i++) {
        uv_mutex_destroy_struct_inst.calls[opmock_i - 1] = uv_mutex_destroy_struct_inst.calls[opmock_i];
    }

    uv_mutex_destroy_struct_inst.expectedCalls--;
}

void uv_mutex_destroy_MockReset()
{
    uv_mutex_destroy_struct_inst.expectedCalls = 0;
    uv_mutex_destroy_struct_inst.actualCalls = 0;
    uv_mutex_destroy_struct_inst.callback = NULL;
}

void uv_mutex_destroy_MockWithCallback(OPMOCK_uv_mutex_destroy_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_mutex_destroy_struct_inst.callback = callback;
    uv_mutex_destroy_struct_inst.expectedCalls = 0;
    uv_mutex_destroy_struct_inst.actualCalls = 0;
}

void uv_mutex_destroy_VerifyMock()
{
    if (uv_mutex_destroy_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_mutex_destroy'",uv_mutex_destroy_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_mutex_destroy_ExpectAndReturn (uv_mutex_t * handle, OPMOCK_MATCHER match_handle)
{
    if(uv_mutex_destroy_struct_inst.callback != NULL)
    {
        uv_mutex_destroy_MockReset ();
    }

    if(uv_mutex_destroy_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_mutex_destroy_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_mutex_destroy (uv_mutex_t * handle)");
    uv_mutex_destroy_struct_inst.calls[uv_mutex_destroy_struct_inst.expectedCalls].handle = (void *)handle;
    uv_mutex_destroy_struct_inst.calls[uv_mutex_destroy_struct_inst.expectedCalls].match_handle = match_handle;
    uv_mutex_destroy_struct_inst.calls[uv_mutex_destroy_struct_inst.expectedCalls].check_params = 1;
    uv_mutex_destroy_struct_inst.expectedCalls++;
}

void uv_mutex_lock(uv_mutex_t * handle)
{
    int opmock_i;
    uv_mutex_lock_struct_inst.actualCalls++;

    if (uv_mutex_lock_struct_inst.callback != NULL)
    {
        uv_mutex_lock_struct_inst.callback (handle, uv_mutex_lock_struct_inst.actualCalls);
        return;
    }
    if (uv_mutex_lock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_mutex_lock', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_mutex_lock (uv_mutex_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_mutex_lock(uv_mutex_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_mutex_lock_struct_inst.calls[0].check_params == 1) {
        if(uv_mutex_lock_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_mutex_lock_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_mutex_lock_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_mutex_lock', %s",uv_mutex_lock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_mutex_lock_struct_inst.expectedCalls; opmock_i++) {
        uv_mutex_lock_struct_inst.calls[opmock_i - 1] = uv_mutex_lock_struct_inst.calls[opmock_i];
    }

    uv_mutex_lock_struct_inst.expectedCalls--;
}

void uv_mutex_lock_MockReset()
{
    uv_mutex_lock_struct_inst.expectedCalls = 0;
    uv_mutex_lock_struct_inst.actualCalls = 0;
    uv_mutex_lock_struct_inst.callback = NULL;
}

void uv_mutex_lock_MockWithCallback(OPMOCK_uv_mutex_lock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_mutex_lock_struct_inst.callback = callback;
    uv_mutex_lock_struct_inst.expectedCalls = 0;
    uv_mutex_lock_struct_inst.actualCalls = 0;
}

void uv_mutex_lock_VerifyMock()
{
    if (uv_mutex_lock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_mutex_lock'",uv_mutex_lock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_mutex_lock_ExpectAndReturn (uv_mutex_t * handle, OPMOCK_MATCHER match_handle)
{
    if(uv_mutex_lock_struct_inst.callback != NULL)
    {
        uv_mutex_lock_MockReset ();
    }

    if(uv_mutex_lock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_mutex_lock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_mutex_lock (uv_mutex_t * handle)");
    uv_mutex_lock_struct_inst.calls[uv_mutex_lock_struct_inst.expectedCalls].handle = (void *)handle;
    uv_mutex_lock_struct_inst.calls[uv_mutex_lock_struct_inst.expectedCalls].match_handle = match_handle;
    uv_mutex_lock_struct_inst.calls[uv_mutex_lock_struct_inst.expectedCalls].check_params = 1;
    uv_mutex_lock_struct_inst.expectedCalls++;
}

int uv_mutex_trylock(uv_mutex_t * handle)
{
    int default_res = (int)uv_mutex_trylock_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_mutex_trylock_struct_inst.actualCalls++;

    if (uv_mutex_trylock_struct_inst.callback != NULL)
    {
        return uv_mutex_trylock_struct_inst.callback (handle, uv_mutex_trylock_struct_inst.actualCalls);
    }
    if (uv_mutex_trylock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_mutex_trylock', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_mutex_trylock (uv_mutex_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_mutex_trylock(uv_mutex_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_mutex_trylock_struct_inst.calls[0].check_params == 1) {
        if(uv_mutex_trylock_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_mutex_trylock_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_mutex_trylock_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_mutex_trylock', %s",uv_mutex_trylock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_mutex_trylock_struct_inst.expectedCalls; opmock_i++) {
        uv_mutex_trylock_struct_inst.calls[opmock_i - 1] = uv_mutex_trylock_struct_inst.calls[opmock_i];
    }

    uv_mutex_trylock_struct_inst.expectedCalls--;
    return default_res;
}

void uv_mutex_trylock_MockReset()
{
    uv_mutex_trylock_struct_inst.expectedCalls = 0;
    uv_mutex_trylock_struct_inst.actualCalls = 0;
    uv_mutex_trylock_struct_inst.callback = NULL;
}

void uv_mutex_trylock_MockWithCallback(OPMOCK_uv_mutex_trylock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_mutex_trylock_struct_inst.callback = callback;
    uv_mutex_trylock_struct_inst.expectedCalls = 0;
    uv_mutex_trylock_struct_inst.actualCalls = 0;
}

void uv_mutex_trylock_VerifyMock()
{
    if (uv_mutex_trylock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_mutex_trylock'",uv_mutex_trylock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_mutex_trylock_ExpectAndReturn (uv_mutex_t * handle, int to_return, OPMOCK_MATCHER match_handle)
{
    if(uv_mutex_trylock_struct_inst.callback != NULL)
    {
        uv_mutex_trylock_MockReset ();
    }

    if(uv_mutex_trylock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_mutex_trylock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_mutex_trylock (uv_mutex_t * handle)");
    uv_mutex_trylock_struct_inst.calls[uv_mutex_trylock_struct_inst.expectedCalls].handle = (void *)handle;
    uv_mutex_trylock_struct_inst.calls[uv_mutex_trylock_struct_inst.expectedCalls].match_handle = match_handle;
    uv_mutex_trylock_struct_inst.calls[uv_mutex_trylock_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_mutex_trylock_struct_inst.calls[uv_mutex_trylock_struct_inst.expectedCalls].check_params = 1;
    uv_mutex_trylock_struct_inst.expectedCalls++;
}

void uv_mutex_unlock(uv_mutex_t * handle)
{
    int opmock_i;
    uv_mutex_unlock_struct_inst.actualCalls++;

    if (uv_mutex_unlock_struct_inst.callback != NULL)
    {
        uv_mutex_unlock_struct_inst.callback (handle, uv_mutex_unlock_struct_inst.actualCalls);
        return;
    }
    if (uv_mutex_unlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_mutex_unlock', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_mutex_unlock (uv_mutex_t * handle)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_mutex_unlock(uv_mutex_t * handle)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_mutex_unlock_struct_inst.calls[0].check_params == 1) {
        if(uv_mutex_unlock_struct_inst.calls[0].match_handle) {
            void * val1 = (void *) &uv_mutex_unlock_struct_inst.calls[0].handle;
            void * val2 = (void *) &handle;
            int match_result = uv_mutex_unlock_struct_inst.calls[0].match_handle(val1, val2, "handle", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_mutex_unlock', %s",uv_mutex_unlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_mutex_unlock_struct_inst.expectedCalls; opmock_i++) {
        uv_mutex_unlock_struct_inst.calls[opmock_i - 1] = uv_mutex_unlock_struct_inst.calls[opmock_i];
    }

    uv_mutex_unlock_struct_inst.expectedCalls--;
}

void uv_mutex_unlock_MockReset()
{
    uv_mutex_unlock_struct_inst.expectedCalls = 0;
    uv_mutex_unlock_struct_inst.actualCalls = 0;
    uv_mutex_unlock_struct_inst.callback = NULL;
}

void uv_mutex_unlock_MockWithCallback(OPMOCK_uv_mutex_unlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_mutex_unlock_struct_inst.callback = callback;
    uv_mutex_unlock_struct_inst.expectedCalls = 0;
    uv_mutex_unlock_struct_inst.actualCalls = 0;
}

void uv_mutex_unlock_VerifyMock()
{
    if (uv_mutex_unlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_mutex_unlock'",uv_mutex_unlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_mutex_unlock_ExpectAndReturn (uv_mutex_t * handle, OPMOCK_MATCHER match_handle)
{
    if(uv_mutex_unlock_struct_inst.callback != NULL)
    {
        uv_mutex_unlock_MockReset ();
    }

    if(uv_mutex_unlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_mutex_unlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_mutex_unlock (uv_mutex_t * handle)");
    uv_mutex_unlock_struct_inst.calls[uv_mutex_unlock_struct_inst.expectedCalls].handle = (void *)handle;
    uv_mutex_unlock_struct_inst.calls[uv_mutex_unlock_struct_inst.expectedCalls].match_handle = match_handle;
    uv_mutex_unlock_struct_inst.calls[uv_mutex_unlock_struct_inst.expectedCalls].check_params = 1;
    uv_mutex_unlock_struct_inst.expectedCalls++;
}

int uv_rwlock_init(uv_rwlock_t * rwlock)
{
    int default_res = (int)uv_rwlock_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_rwlock_init_struct_inst.actualCalls++;

    if (uv_rwlock_init_struct_inst.callback != NULL)
    {
        return uv_rwlock_init_struct_inst.callback (rwlock, uv_rwlock_init_struct_inst.actualCalls);
    }
    if (uv_rwlock_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_rwlock_init (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_rwlock_init(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_init_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_init_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_init_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_init_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_init', %s",uv_rwlock_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_init_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_init_struct_inst.calls[opmock_i - 1] = uv_rwlock_init_struct_inst.calls[opmock_i];
    }

    uv_rwlock_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_rwlock_init_MockReset()
{
    uv_rwlock_init_struct_inst.expectedCalls = 0;
    uv_rwlock_init_struct_inst.actualCalls = 0;
    uv_rwlock_init_struct_inst.callback = NULL;
}

void uv_rwlock_init_MockWithCallback(OPMOCK_uv_rwlock_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_init_struct_inst.callback = callback;
    uv_rwlock_init_struct_inst.expectedCalls = 0;
    uv_rwlock_init_struct_inst.actualCalls = 0;
}

void uv_rwlock_init_VerifyMock()
{
    if (uv_rwlock_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_init'",uv_rwlock_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_init_ExpectAndReturn (uv_rwlock_t * rwlock, int to_return, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_init_struct_inst.callback != NULL)
    {
        uv_rwlock_init_MockReset ();
    }

    if(uv_rwlock_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_rwlock_init (uv_rwlock_t * rwlock)");
    uv_rwlock_init_struct_inst.calls[uv_rwlock_init_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_init_struct_inst.calls[uv_rwlock_init_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_init_struct_inst.calls[uv_rwlock_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_rwlock_init_struct_inst.calls[uv_rwlock_init_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_init_struct_inst.expectedCalls++;
}

void uv_rwlock_destroy(uv_rwlock_t * rwlock)
{
    int opmock_i;
    uv_rwlock_destroy_struct_inst.actualCalls++;

    if (uv_rwlock_destroy_struct_inst.callback != NULL)
    {
        uv_rwlock_destroy_struct_inst.callback (rwlock, uv_rwlock_destroy_struct_inst.actualCalls);
        return;
    }
    if (uv_rwlock_destroy_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_destroy', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_rwlock_destroy (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_rwlock_destroy(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_destroy_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_destroy_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_destroy_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_destroy_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_destroy', %s",uv_rwlock_destroy_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_destroy_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_destroy_struct_inst.calls[opmock_i - 1] = uv_rwlock_destroy_struct_inst.calls[opmock_i];
    }

    uv_rwlock_destroy_struct_inst.expectedCalls--;
}

void uv_rwlock_destroy_MockReset()
{
    uv_rwlock_destroy_struct_inst.expectedCalls = 0;
    uv_rwlock_destroy_struct_inst.actualCalls = 0;
    uv_rwlock_destroy_struct_inst.callback = NULL;
}

void uv_rwlock_destroy_MockWithCallback(OPMOCK_uv_rwlock_destroy_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_destroy_struct_inst.callback = callback;
    uv_rwlock_destroy_struct_inst.expectedCalls = 0;
    uv_rwlock_destroy_struct_inst.actualCalls = 0;
}

void uv_rwlock_destroy_VerifyMock()
{
    if (uv_rwlock_destroy_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_destroy'",uv_rwlock_destroy_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_destroy_ExpectAndReturn (uv_rwlock_t * rwlock, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_destroy_struct_inst.callback != NULL)
    {
        uv_rwlock_destroy_MockReset ();
    }

    if(uv_rwlock_destroy_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_destroy_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_rwlock_destroy (uv_rwlock_t * rwlock)");
    uv_rwlock_destroy_struct_inst.calls[uv_rwlock_destroy_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_destroy_struct_inst.calls[uv_rwlock_destroy_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_destroy_struct_inst.calls[uv_rwlock_destroy_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_destroy_struct_inst.expectedCalls++;
}

void uv_rwlock_rdlock(uv_rwlock_t * rwlock)
{
    int opmock_i;
    uv_rwlock_rdlock_struct_inst.actualCalls++;

    if (uv_rwlock_rdlock_struct_inst.callback != NULL)
    {
        uv_rwlock_rdlock_struct_inst.callback (rwlock, uv_rwlock_rdlock_struct_inst.actualCalls);
        return;
    }
    if (uv_rwlock_rdlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_rdlock', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_rwlock_rdlock (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_rwlock_rdlock(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_rdlock_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_rdlock_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_rdlock_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_rdlock_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_rdlock', %s",uv_rwlock_rdlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_rdlock_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_rdlock_struct_inst.calls[opmock_i - 1] = uv_rwlock_rdlock_struct_inst.calls[opmock_i];
    }

    uv_rwlock_rdlock_struct_inst.expectedCalls--;
}

void uv_rwlock_rdlock_MockReset()
{
    uv_rwlock_rdlock_struct_inst.expectedCalls = 0;
    uv_rwlock_rdlock_struct_inst.actualCalls = 0;
    uv_rwlock_rdlock_struct_inst.callback = NULL;
}

void uv_rwlock_rdlock_MockWithCallback(OPMOCK_uv_rwlock_rdlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_rdlock_struct_inst.callback = callback;
    uv_rwlock_rdlock_struct_inst.expectedCalls = 0;
    uv_rwlock_rdlock_struct_inst.actualCalls = 0;
}

void uv_rwlock_rdlock_VerifyMock()
{
    if (uv_rwlock_rdlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_rdlock'",uv_rwlock_rdlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_rdlock_ExpectAndReturn (uv_rwlock_t * rwlock, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_rdlock_struct_inst.callback != NULL)
    {
        uv_rwlock_rdlock_MockReset ();
    }

    if(uv_rwlock_rdlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_rdlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_rwlock_rdlock (uv_rwlock_t * rwlock)");
    uv_rwlock_rdlock_struct_inst.calls[uv_rwlock_rdlock_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_rdlock_struct_inst.calls[uv_rwlock_rdlock_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_rdlock_struct_inst.calls[uv_rwlock_rdlock_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_rdlock_struct_inst.expectedCalls++;
}

int uv_rwlock_tryrdlock(uv_rwlock_t * rwlock)
{
    int default_res = (int)uv_rwlock_tryrdlock_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_rwlock_tryrdlock_struct_inst.actualCalls++;

    if (uv_rwlock_tryrdlock_struct_inst.callback != NULL)
    {
        return uv_rwlock_tryrdlock_struct_inst.callback (rwlock, uv_rwlock_tryrdlock_struct_inst.actualCalls);
    }
    if (uv_rwlock_tryrdlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_tryrdlock', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_rwlock_tryrdlock (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_rwlock_tryrdlock(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_tryrdlock_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_tryrdlock_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_tryrdlock_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_tryrdlock_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_tryrdlock', %s",uv_rwlock_tryrdlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_tryrdlock_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_tryrdlock_struct_inst.calls[opmock_i - 1] = uv_rwlock_tryrdlock_struct_inst.calls[opmock_i];
    }

    uv_rwlock_tryrdlock_struct_inst.expectedCalls--;
    return default_res;
}

void uv_rwlock_tryrdlock_MockReset()
{
    uv_rwlock_tryrdlock_struct_inst.expectedCalls = 0;
    uv_rwlock_tryrdlock_struct_inst.actualCalls = 0;
    uv_rwlock_tryrdlock_struct_inst.callback = NULL;
}

void uv_rwlock_tryrdlock_MockWithCallback(OPMOCK_uv_rwlock_tryrdlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_tryrdlock_struct_inst.callback = callback;
    uv_rwlock_tryrdlock_struct_inst.expectedCalls = 0;
    uv_rwlock_tryrdlock_struct_inst.actualCalls = 0;
}

void uv_rwlock_tryrdlock_VerifyMock()
{
    if (uv_rwlock_tryrdlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_tryrdlock'",uv_rwlock_tryrdlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_tryrdlock_ExpectAndReturn (uv_rwlock_t * rwlock, int to_return, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_tryrdlock_struct_inst.callback != NULL)
    {
        uv_rwlock_tryrdlock_MockReset ();
    }

    if(uv_rwlock_tryrdlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_tryrdlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_rwlock_tryrdlock (uv_rwlock_t * rwlock)");
    uv_rwlock_tryrdlock_struct_inst.calls[uv_rwlock_tryrdlock_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_tryrdlock_struct_inst.calls[uv_rwlock_tryrdlock_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_tryrdlock_struct_inst.calls[uv_rwlock_tryrdlock_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_rwlock_tryrdlock_struct_inst.calls[uv_rwlock_tryrdlock_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_tryrdlock_struct_inst.expectedCalls++;
}

void uv_rwlock_rdunlock(uv_rwlock_t * rwlock)
{
    int opmock_i;
    uv_rwlock_rdunlock_struct_inst.actualCalls++;

    if (uv_rwlock_rdunlock_struct_inst.callback != NULL)
    {
        uv_rwlock_rdunlock_struct_inst.callback (rwlock, uv_rwlock_rdunlock_struct_inst.actualCalls);
        return;
    }
    if (uv_rwlock_rdunlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_rdunlock', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_rwlock_rdunlock (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_rwlock_rdunlock(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_rdunlock_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_rdunlock_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_rdunlock_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_rdunlock_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_rdunlock', %s",uv_rwlock_rdunlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_rdunlock_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_rdunlock_struct_inst.calls[opmock_i - 1] = uv_rwlock_rdunlock_struct_inst.calls[opmock_i];
    }

    uv_rwlock_rdunlock_struct_inst.expectedCalls--;
}

void uv_rwlock_rdunlock_MockReset()
{
    uv_rwlock_rdunlock_struct_inst.expectedCalls = 0;
    uv_rwlock_rdunlock_struct_inst.actualCalls = 0;
    uv_rwlock_rdunlock_struct_inst.callback = NULL;
}

void uv_rwlock_rdunlock_MockWithCallback(OPMOCK_uv_rwlock_rdunlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_rdunlock_struct_inst.callback = callback;
    uv_rwlock_rdunlock_struct_inst.expectedCalls = 0;
    uv_rwlock_rdunlock_struct_inst.actualCalls = 0;
}

void uv_rwlock_rdunlock_VerifyMock()
{
    if (uv_rwlock_rdunlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_rdunlock'",uv_rwlock_rdunlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_rdunlock_ExpectAndReturn (uv_rwlock_t * rwlock, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_rdunlock_struct_inst.callback != NULL)
    {
        uv_rwlock_rdunlock_MockReset ();
    }

    if(uv_rwlock_rdunlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_rdunlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_rwlock_rdunlock (uv_rwlock_t * rwlock)");
    uv_rwlock_rdunlock_struct_inst.calls[uv_rwlock_rdunlock_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_rdunlock_struct_inst.calls[uv_rwlock_rdunlock_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_rdunlock_struct_inst.calls[uv_rwlock_rdunlock_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_rdunlock_struct_inst.expectedCalls++;
}

void uv_rwlock_wrlock(uv_rwlock_t * rwlock)
{
    int opmock_i;
    uv_rwlock_wrlock_struct_inst.actualCalls++;

    if (uv_rwlock_wrlock_struct_inst.callback != NULL)
    {
        uv_rwlock_wrlock_struct_inst.callback (rwlock, uv_rwlock_wrlock_struct_inst.actualCalls);
        return;
    }
    if (uv_rwlock_wrlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_wrlock', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_rwlock_wrlock (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_rwlock_wrlock(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_wrlock_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_wrlock_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_wrlock_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_wrlock_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_wrlock', %s",uv_rwlock_wrlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_wrlock_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_wrlock_struct_inst.calls[opmock_i - 1] = uv_rwlock_wrlock_struct_inst.calls[opmock_i];
    }

    uv_rwlock_wrlock_struct_inst.expectedCalls--;
}

void uv_rwlock_wrlock_MockReset()
{
    uv_rwlock_wrlock_struct_inst.expectedCalls = 0;
    uv_rwlock_wrlock_struct_inst.actualCalls = 0;
    uv_rwlock_wrlock_struct_inst.callback = NULL;
}

void uv_rwlock_wrlock_MockWithCallback(OPMOCK_uv_rwlock_wrlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_wrlock_struct_inst.callback = callback;
    uv_rwlock_wrlock_struct_inst.expectedCalls = 0;
    uv_rwlock_wrlock_struct_inst.actualCalls = 0;
}

void uv_rwlock_wrlock_VerifyMock()
{
    if (uv_rwlock_wrlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_wrlock'",uv_rwlock_wrlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_wrlock_ExpectAndReturn (uv_rwlock_t * rwlock, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_wrlock_struct_inst.callback != NULL)
    {
        uv_rwlock_wrlock_MockReset ();
    }

    if(uv_rwlock_wrlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_wrlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_rwlock_wrlock (uv_rwlock_t * rwlock)");
    uv_rwlock_wrlock_struct_inst.calls[uv_rwlock_wrlock_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_wrlock_struct_inst.calls[uv_rwlock_wrlock_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_wrlock_struct_inst.calls[uv_rwlock_wrlock_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_wrlock_struct_inst.expectedCalls++;
}

int uv_rwlock_trywrlock(uv_rwlock_t * rwlock)
{
    int default_res = (int)uv_rwlock_trywrlock_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_rwlock_trywrlock_struct_inst.actualCalls++;

    if (uv_rwlock_trywrlock_struct_inst.callback != NULL)
    {
        return uv_rwlock_trywrlock_struct_inst.callback (rwlock, uv_rwlock_trywrlock_struct_inst.actualCalls);
    }
    if (uv_rwlock_trywrlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_trywrlock', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_rwlock_trywrlock (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_rwlock_trywrlock(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_trywrlock_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_trywrlock_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_trywrlock_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_trywrlock_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_trywrlock', %s",uv_rwlock_trywrlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_trywrlock_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_trywrlock_struct_inst.calls[opmock_i - 1] = uv_rwlock_trywrlock_struct_inst.calls[opmock_i];
    }

    uv_rwlock_trywrlock_struct_inst.expectedCalls--;
    return default_res;
}

void uv_rwlock_trywrlock_MockReset()
{
    uv_rwlock_trywrlock_struct_inst.expectedCalls = 0;
    uv_rwlock_trywrlock_struct_inst.actualCalls = 0;
    uv_rwlock_trywrlock_struct_inst.callback = NULL;
}

void uv_rwlock_trywrlock_MockWithCallback(OPMOCK_uv_rwlock_trywrlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_trywrlock_struct_inst.callback = callback;
    uv_rwlock_trywrlock_struct_inst.expectedCalls = 0;
    uv_rwlock_trywrlock_struct_inst.actualCalls = 0;
}

void uv_rwlock_trywrlock_VerifyMock()
{
    if (uv_rwlock_trywrlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_trywrlock'",uv_rwlock_trywrlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_trywrlock_ExpectAndReturn (uv_rwlock_t * rwlock, int to_return, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_trywrlock_struct_inst.callback != NULL)
    {
        uv_rwlock_trywrlock_MockReset ();
    }

    if(uv_rwlock_trywrlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_trywrlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_rwlock_trywrlock (uv_rwlock_t * rwlock)");
    uv_rwlock_trywrlock_struct_inst.calls[uv_rwlock_trywrlock_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_trywrlock_struct_inst.calls[uv_rwlock_trywrlock_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_trywrlock_struct_inst.calls[uv_rwlock_trywrlock_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_rwlock_trywrlock_struct_inst.calls[uv_rwlock_trywrlock_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_trywrlock_struct_inst.expectedCalls++;
}

void uv_rwlock_wrunlock(uv_rwlock_t * rwlock)
{
    int opmock_i;
    uv_rwlock_wrunlock_struct_inst.actualCalls++;

    if (uv_rwlock_wrunlock_struct_inst.callback != NULL)
    {
        uv_rwlock_wrunlock_struct_inst.callback (rwlock, uv_rwlock_wrunlock_struct_inst.actualCalls);
        return;
    }
    if (uv_rwlock_wrunlock_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_rwlock_wrunlock', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_rwlock_wrunlock (uv_rwlock_t * rwlock)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_rwlock_wrunlock(uv_rwlock_t * rwlock)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_rwlock_wrunlock_struct_inst.calls[0].check_params == 1) {
        if(uv_rwlock_wrunlock_struct_inst.calls[0].match_rwlock) {
            void * val1 = (void *) &uv_rwlock_wrunlock_struct_inst.calls[0].rwlock;
            void * val2 = (void *) &rwlock;
            int match_result = uv_rwlock_wrunlock_struct_inst.calls[0].match_rwlock(val1, val2, "rwlock", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_rwlock_wrunlock', %s",uv_rwlock_wrunlock_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_rwlock_wrunlock_struct_inst.expectedCalls; opmock_i++) {
        uv_rwlock_wrunlock_struct_inst.calls[opmock_i - 1] = uv_rwlock_wrunlock_struct_inst.calls[opmock_i];
    }

    uv_rwlock_wrunlock_struct_inst.expectedCalls--;
}

void uv_rwlock_wrunlock_MockReset()
{
    uv_rwlock_wrunlock_struct_inst.expectedCalls = 0;
    uv_rwlock_wrunlock_struct_inst.actualCalls = 0;
    uv_rwlock_wrunlock_struct_inst.callback = NULL;
}

void uv_rwlock_wrunlock_MockWithCallback(OPMOCK_uv_rwlock_wrunlock_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_rwlock_wrunlock_struct_inst.callback = callback;
    uv_rwlock_wrunlock_struct_inst.expectedCalls = 0;
    uv_rwlock_wrunlock_struct_inst.actualCalls = 0;
}

void uv_rwlock_wrunlock_VerifyMock()
{
    if (uv_rwlock_wrunlock_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_rwlock_wrunlock'",uv_rwlock_wrunlock_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_rwlock_wrunlock_ExpectAndReturn (uv_rwlock_t * rwlock, OPMOCK_MATCHER match_rwlock)
{
    if(uv_rwlock_wrunlock_struct_inst.callback != NULL)
    {
        uv_rwlock_wrunlock_MockReset ();
    }

    if(uv_rwlock_wrunlock_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_rwlock_wrunlock_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_rwlock_wrunlock (uv_rwlock_t * rwlock)");
    uv_rwlock_wrunlock_struct_inst.calls[uv_rwlock_wrunlock_struct_inst.expectedCalls].rwlock = (void *)rwlock;
    uv_rwlock_wrunlock_struct_inst.calls[uv_rwlock_wrunlock_struct_inst.expectedCalls].match_rwlock = match_rwlock;
    uv_rwlock_wrunlock_struct_inst.calls[uv_rwlock_wrunlock_struct_inst.expectedCalls].check_params = 1;
    uv_rwlock_wrunlock_struct_inst.expectedCalls++;
}

int uv_sem_init(uv_sem_t * sem, unsigned int value)
{
    int default_res = (int)uv_sem_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_sem_init_struct_inst.actualCalls++;

    if (uv_sem_init_struct_inst.callback != NULL)
    {
        return uv_sem_init_struct_inst.callback (sem, value, uv_sem_init_struct_inst.actualCalls);
    }
    if (uv_sem_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_sem_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_sem_init (uv_sem_t * sem, unsigned int value)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_sem_init(uv_sem_t * sem, unsigned int value)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_sem_init_struct_inst.calls[0].check_params == 1) {
        if(uv_sem_init_struct_inst.calls[0].match_sem) {
            void * val1 = (void *) &uv_sem_init_struct_inst.calls[0].sem;
            void * val2 = (void *) &sem;
            int match_result = uv_sem_init_struct_inst.calls[0].match_sem(val1, val2, "sem", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_sem_init', %s",uv_sem_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_sem_init_struct_inst.calls[0].match_value) {
            void * val1 = (void *) &uv_sem_init_struct_inst.calls[0].value;
            void * val2 = (void *) &value;
            int match_result = uv_sem_init_struct_inst.calls[0].match_value(val1, val2, "value", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_sem_init', %s",uv_sem_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_sem_init_struct_inst.expectedCalls; opmock_i++) {
        uv_sem_init_struct_inst.calls[opmock_i - 1] = uv_sem_init_struct_inst.calls[opmock_i];
    }

    uv_sem_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_sem_init_MockReset()
{
    uv_sem_init_struct_inst.expectedCalls = 0;
    uv_sem_init_struct_inst.actualCalls = 0;
    uv_sem_init_struct_inst.callback = NULL;
}

void uv_sem_init_MockWithCallback(OPMOCK_uv_sem_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_sem_init_struct_inst.callback = callback;
    uv_sem_init_struct_inst.expectedCalls = 0;
    uv_sem_init_struct_inst.actualCalls = 0;
}

void uv_sem_init_VerifyMock()
{
    if (uv_sem_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_sem_init'",uv_sem_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_sem_init_ExpectAndReturn (uv_sem_t * sem, unsigned int value, int to_return, OPMOCK_MATCHER match_sem, OPMOCK_MATCHER match_value)
{
    if(uv_sem_init_struct_inst.callback != NULL)
    {
        uv_sem_init_MockReset ();
    }

    if(uv_sem_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_sem_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_sem_init (uv_sem_t * sem, unsigned int value)");
    uv_sem_init_struct_inst.calls[uv_sem_init_struct_inst.expectedCalls].sem = (void *)sem;
    uv_sem_init_struct_inst.calls[uv_sem_init_struct_inst.expectedCalls].value = (unsigned int)value;
    uv_sem_init_struct_inst.calls[uv_sem_init_struct_inst.expectedCalls].match_sem = match_sem;
    uv_sem_init_struct_inst.calls[uv_sem_init_struct_inst.expectedCalls].match_value = match_value;
    uv_sem_init_struct_inst.calls[uv_sem_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_sem_init_struct_inst.calls[uv_sem_init_struct_inst.expectedCalls].check_params = 1;
    uv_sem_init_struct_inst.expectedCalls++;
}

void uv_sem_destroy(uv_sem_t * sem)
{
    int opmock_i;
    uv_sem_destroy_struct_inst.actualCalls++;

    if (uv_sem_destroy_struct_inst.callback != NULL)
    {
        uv_sem_destroy_struct_inst.callback (sem, uv_sem_destroy_struct_inst.actualCalls);
        return;
    }
    if (uv_sem_destroy_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_sem_destroy', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_sem_destroy (uv_sem_t * sem)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_sem_destroy(uv_sem_t * sem)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_sem_destroy_struct_inst.calls[0].check_params == 1) {
        if(uv_sem_destroy_struct_inst.calls[0].match_sem) {
            void * val1 = (void *) &uv_sem_destroy_struct_inst.calls[0].sem;
            void * val2 = (void *) &sem;
            int match_result = uv_sem_destroy_struct_inst.calls[0].match_sem(val1, val2, "sem", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_sem_destroy', %s",uv_sem_destroy_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_sem_destroy_struct_inst.expectedCalls; opmock_i++) {
        uv_sem_destroy_struct_inst.calls[opmock_i - 1] = uv_sem_destroy_struct_inst.calls[opmock_i];
    }

    uv_sem_destroy_struct_inst.expectedCalls--;
}

void uv_sem_destroy_MockReset()
{
    uv_sem_destroy_struct_inst.expectedCalls = 0;
    uv_sem_destroy_struct_inst.actualCalls = 0;
    uv_sem_destroy_struct_inst.callback = NULL;
}

void uv_sem_destroy_MockWithCallback(OPMOCK_uv_sem_destroy_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_sem_destroy_struct_inst.callback = callback;
    uv_sem_destroy_struct_inst.expectedCalls = 0;
    uv_sem_destroy_struct_inst.actualCalls = 0;
}

void uv_sem_destroy_VerifyMock()
{
    if (uv_sem_destroy_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_sem_destroy'",uv_sem_destroy_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_sem_destroy_ExpectAndReturn (uv_sem_t * sem, OPMOCK_MATCHER match_sem)
{
    if(uv_sem_destroy_struct_inst.callback != NULL)
    {
        uv_sem_destroy_MockReset ();
    }

    if(uv_sem_destroy_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_sem_destroy_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_sem_destroy (uv_sem_t * sem)");
    uv_sem_destroy_struct_inst.calls[uv_sem_destroy_struct_inst.expectedCalls].sem = (void *)sem;
    uv_sem_destroy_struct_inst.calls[uv_sem_destroy_struct_inst.expectedCalls].match_sem = match_sem;
    uv_sem_destroy_struct_inst.calls[uv_sem_destroy_struct_inst.expectedCalls].check_params = 1;
    uv_sem_destroy_struct_inst.expectedCalls++;
}

void uv_sem_post(uv_sem_t * sem)
{
    int opmock_i;
    uv_sem_post_struct_inst.actualCalls++;

    if (uv_sem_post_struct_inst.callback != NULL)
    {
        uv_sem_post_struct_inst.callback (sem, uv_sem_post_struct_inst.actualCalls);
        return;
    }
    if (uv_sem_post_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_sem_post', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_sem_post (uv_sem_t * sem)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_sem_post(uv_sem_t * sem)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_sem_post_struct_inst.calls[0].check_params == 1) {
        if(uv_sem_post_struct_inst.calls[0].match_sem) {
            void * val1 = (void *) &uv_sem_post_struct_inst.calls[0].sem;
            void * val2 = (void *) &sem;
            int match_result = uv_sem_post_struct_inst.calls[0].match_sem(val1, val2, "sem", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_sem_post', %s",uv_sem_post_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_sem_post_struct_inst.expectedCalls; opmock_i++) {
        uv_sem_post_struct_inst.calls[opmock_i - 1] = uv_sem_post_struct_inst.calls[opmock_i];
    }

    uv_sem_post_struct_inst.expectedCalls--;
}

void uv_sem_post_MockReset()
{
    uv_sem_post_struct_inst.expectedCalls = 0;
    uv_sem_post_struct_inst.actualCalls = 0;
    uv_sem_post_struct_inst.callback = NULL;
}

void uv_sem_post_MockWithCallback(OPMOCK_uv_sem_post_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_sem_post_struct_inst.callback = callback;
    uv_sem_post_struct_inst.expectedCalls = 0;
    uv_sem_post_struct_inst.actualCalls = 0;
}

void uv_sem_post_VerifyMock()
{
    if (uv_sem_post_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_sem_post'",uv_sem_post_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_sem_post_ExpectAndReturn (uv_sem_t * sem, OPMOCK_MATCHER match_sem)
{
    if(uv_sem_post_struct_inst.callback != NULL)
    {
        uv_sem_post_MockReset ();
    }

    if(uv_sem_post_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_sem_post_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_sem_post (uv_sem_t * sem)");
    uv_sem_post_struct_inst.calls[uv_sem_post_struct_inst.expectedCalls].sem = (void *)sem;
    uv_sem_post_struct_inst.calls[uv_sem_post_struct_inst.expectedCalls].match_sem = match_sem;
    uv_sem_post_struct_inst.calls[uv_sem_post_struct_inst.expectedCalls].check_params = 1;
    uv_sem_post_struct_inst.expectedCalls++;
}

void uv_sem_wait(uv_sem_t * sem)
{
    int opmock_i;
    uv_sem_wait_struct_inst.actualCalls++;

    if (uv_sem_wait_struct_inst.callback != NULL)
    {
        uv_sem_wait_struct_inst.callback (sem, uv_sem_wait_struct_inst.actualCalls);
        return;
    }
    if (uv_sem_wait_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_sem_wait', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_sem_wait (uv_sem_t * sem)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_sem_wait(uv_sem_t * sem)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_sem_wait_struct_inst.calls[0].check_params == 1) {
        if(uv_sem_wait_struct_inst.calls[0].match_sem) {
            void * val1 = (void *) &uv_sem_wait_struct_inst.calls[0].sem;
            void * val2 = (void *) &sem;
            int match_result = uv_sem_wait_struct_inst.calls[0].match_sem(val1, val2, "sem", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_sem_wait', %s",uv_sem_wait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_sem_wait_struct_inst.expectedCalls; opmock_i++) {
        uv_sem_wait_struct_inst.calls[opmock_i - 1] = uv_sem_wait_struct_inst.calls[opmock_i];
    }

    uv_sem_wait_struct_inst.expectedCalls--;
}

void uv_sem_wait_MockReset()
{
    uv_sem_wait_struct_inst.expectedCalls = 0;
    uv_sem_wait_struct_inst.actualCalls = 0;
    uv_sem_wait_struct_inst.callback = NULL;
}

void uv_sem_wait_MockWithCallback(OPMOCK_uv_sem_wait_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_sem_wait_struct_inst.callback = callback;
    uv_sem_wait_struct_inst.expectedCalls = 0;
    uv_sem_wait_struct_inst.actualCalls = 0;
}

void uv_sem_wait_VerifyMock()
{
    if (uv_sem_wait_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_sem_wait'",uv_sem_wait_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_sem_wait_ExpectAndReturn (uv_sem_t * sem, OPMOCK_MATCHER match_sem)
{
    if(uv_sem_wait_struct_inst.callback != NULL)
    {
        uv_sem_wait_MockReset ();
    }

    if(uv_sem_wait_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_sem_wait_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_sem_wait (uv_sem_t * sem)");
    uv_sem_wait_struct_inst.calls[uv_sem_wait_struct_inst.expectedCalls].sem = (void *)sem;
    uv_sem_wait_struct_inst.calls[uv_sem_wait_struct_inst.expectedCalls].match_sem = match_sem;
    uv_sem_wait_struct_inst.calls[uv_sem_wait_struct_inst.expectedCalls].check_params = 1;
    uv_sem_wait_struct_inst.expectedCalls++;
}

int uv_sem_trywait(uv_sem_t * sem)
{
    int default_res = (int)uv_sem_trywait_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_sem_trywait_struct_inst.actualCalls++;

    if (uv_sem_trywait_struct_inst.callback != NULL)
    {
        return uv_sem_trywait_struct_inst.callback (sem, uv_sem_trywait_struct_inst.actualCalls);
    }
    if (uv_sem_trywait_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_sem_trywait', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_sem_trywait (uv_sem_t * sem)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_sem_trywait(uv_sem_t * sem)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_sem_trywait_struct_inst.calls[0].check_params == 1) {
        if(uv_sem_trywait_struct_inst.calls[0].match_sem) {
            void * val1 = (void *) &uv_sem_trywait_struct_inst.calls[0].sem;
            void * val2 = (void *) &sem;
            int match_result = uv_sem_trywait_struct_inst.calls[0].match_sem(val1, val2, "sem", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_sem_trywait', %s",uv_sem_trywait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_sem_trywait_struct_inst.expectedCalls; opmock_i++) {
        uv_sem_trywait_struct_inst.calls[opmock_i - 1] = uv_sem_trywait_struct_inst.calls[opmock_i];
    }

    uv_sem_trywait_struct_inst.expectedCalls--;
    return default_res;
}

void uv_sem_trywait_MockReset()
{
    uv_sem_trywait_struct_inst.expectedCalls = 0;
    uv_sem_trywait_struct_inst.actualCalls = 0;
    uv_sem_trywait_struct_inst.callback = NULL;
}

void uv_sem_trywait_MockWithCallback(OPMOCK_uv_sem_trywait_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_sem_trywait_struct_inst.callback = callback;
    uv_sem_trywait_struct_inst.expectedCalls = 0;
    uv_sem_trywait_struct_inst.actualCalls = 0;
}

void uv_sem_trywait_VerifyMock()
{
    if (uv_sem_trywait_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_sem_trywait'",uv_sem_trywait_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_sem_trywait_ExpectAndReturn (uv_sem_t * sem, int to_return, OPMOCK_MATCHER match_sem)
{
    if(uv_sem_trywait_struct_inst.callback != NULL)
    {
        uv_sem_trywait_MockReset ();
    }

    if(uv_sem_trywait_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_sem_trywait_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_sem_trywait (uv_sem_t * sem)");
    uv_sem_trywait_struct_inst.calls[uv_sem_trywait_struct_inst.expectedCalls].sem = (void *)sem;
    uv_sem_trywait_struct_inst.calls[uv_sem_trywait_struct_inst.expectedCalls].match_sem = match_sem;
    uv_sem_trywait_struct_inst.calls[uv_sem_trywait_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_sem_trywait_struct_inst.calls[uv_sem_trywait_struct_inst.expectedCalls].check_params = 1;
    uv_sem_trywait_struct_inst.expectedCalls++;
}

int uv_cond_init(uv_cond_t * cond)
{
    int default_res = (int)uv_cond_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_cond_init_struct_inst.actualCalls++;

    if (uv_cond_init_struct_inst.callback != NULL)
    {
        return uv_cond_init_struct_inst.callback (cond, uv_cond_init_struct_inst.actualCalls);
    }
    if (uv_cond_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cond_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_cond_init (uv_cond_t * cond)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_cond_init(uv_cond_t * cond)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cond_init_struct_inst.calls[0].check_params == 1) {
        if(uv_cond_init_struct_inst.calls[0].match_cond) {
            void * val1 = (void *) &uv_cond_init_struct_inst.calls[0].cond;
            void * val2 = (void *) &cond;
            int match_result = uv_cond_init_struct_inst.calls[0].match_cond(val1, val2, "cond", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_init', %s",uv_cond_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cond_init_struct_inst.expectedCalls; opmock_i++) {
        uv_cond_init_struct_inst.calls[opmock_i - 1] = uv_cond_init_struct_inst.calls[opmock_i];
    }

    uv_cond_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_cond_init_MockReset()
{
    uv_cond_init_struct_inst.expectedCalls = 0;
    uv_cond_init_struct_inst.actualCalls = 0;
    uv_cond_init_struct_inst.callback = NULL;
}

void uv_cond_init_MockWithCallback(OPMOCK_uv_cond_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cond_init_struct_inst.callback = callback;
    uv_cond_init_struct_inst.expectedCalls = 0;
    uv_cond_init_struct_inst.actualCalls = 0;
}

void uv_cond_init_VerifyMock()
{
    if (uv_cond_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cond_init'",uv_cond_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cond_init_ExpectAndReturn (uv_cond_t * cond, int to_return, OPMOCK_MATCHER match_cond)
{
    if(uv_cond_init_struct_inst.callback != NULL)
    {
        uv_cond_init_MockReset ();
    }

    if(uv_cond_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cond_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_cond_init (uv_cond_t * cond)");
    uv_cond_init_struct_inst.calls[uv_cond_init_struct_inst.expectedCalls].cond = (void *)cond;
    uv_cond_init_struct_inst.calls[uv_cond_init_struct_inst.expectedCalls].match_cond = match_cond;
    uv_cond_init_struct_inst.calls[uv_cond_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_cond_init_struct_inst.calls[uv_cond_init_struct_inst.expectedCalls].check_params = 1;
    uv_cond_init_struct_inst.expectedCalls++;
}

void uv_cond_destroy(uv_cond_t * cond)
{
    int opmock_i;
    uv_cond_destroy_struct_inst.actualCalls++;

    if (uv_cond_destroy_struct_inst.callback != NULL)
    {
        uv_cond_destroy_struct_inst.callback (cond, uv_cond_destroy_struct_inst.actualCalls);
        return;
    }
    if (uv_cond_destroy_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cond_destroy', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_cond_destroy (uv_cond_t * cond)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_cond_destroy(uv_cond_t * cond)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cond_destroy_struct_inst.calls[0].check_params == 1) {
        if(uv_cond_destroy_struct_inst.calls[0].match_cond) {
            void * val1 = (void *) &uv_cond_destroy_struct_inst.calls[0].cond;
            void * val2 = (void *) &cond;
            int match_result = uv_cond_destroy_struct_inst.calls[0].match_cond(val1, val2, "cond", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_destroy', %s",uv_cond_destroy_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cond_destroy_struct_inst.expectedCalls; opmock_i++) {
        uv_cond_destroy_struct_inst.calls[opmock_i - 1] = uv_cond_destroy_struct_inst.calls[opmock_i];
    }

    uv_cond_destroy_struct_inst.expectedCalls--;
}

void uv_cond_destroy_MockReset()
{
    uv_cond_destroy_struct_inst.expectedCalls = 0;
    uv_cond_destroy_struct_inst.actualCalls = 0;
    uv_cond_destroy_struct_inst.callback = NULL;
}

void uv_cond_destroy_MockWithCallback(OPMOCK_uv_cond_destroy_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cond_destroy_struct_inst.callback = callback;
    uv_cond_destroy_struct_inst.expectedCalls = 0;
    uv_cond_destroy_struct_inst.actualCalls = 0;
}

void uv_cond_destroy_VerifyMock()
{
    if (uv_cond_destroy_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cond_destroy'",uv_cond_destroy_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cond_destroy_ExpectAndReturn (uv_cond_t * cond, OPMOCK_MATCHER match_cond)
{
    if(uv_cond_destroy_struct_inst.callback != NULL)
    {
        uv_cond_destroy_MockReset ();
    }

    if(uv_cond_destroy_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cond_destroy_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_cond_destroy (uv_cond_t * cond)");
    uv_cond_destroy_struct_inst.calls[uv_cond_destroy_struct_inst.expectedCalls].cond = (void *)cond;
    uv_cond_destroy_struct_inst.calls[uv_cond_destroy_struct_inst.expectedCalls].match_cond = match_cond;
    uv_cond_destroy_struct_inst.calls[uv_cond_destroy_struct_inst.expectedCalls].check_params = 1;
    uv_cond_destroy_struct_inst.expectedCalls++;
}

void uv_cond_signal(uv_cond_t * cond)
{
    int opmock_i;
    uv_cond_signal_struct_inst.actualCalls++;

    if (uv_cond_signal_struct_inst.callback != NULL)
    {
        uv_cond_signal_struct_inst.callback (cond, uv_cond_signal_struct_inst.actualCalls);
        return;
    }
    if (uv_cond_signal_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cond_signal', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_cond_signal (uv_cond_t * cond)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_cond_signal(uv_cond_t * cond)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cond_signal_struct_inst.calls[0].check_params == 1) {
        if(uv_cond_signal_struct_inst.calls[0].match_cond) {
            void * val1 = (void *) &uv_cond_signal_struct_inst.calls[0].cond;
            void * val2 = (void *) &cond;
            int match_result = uv_cond_signal_struct_inst.calls[0].match_cond(val1, val2, "cond", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_signal', %s",uv_cond_signal_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cond_signal_struct_inst.expectedCalls; opmock_i++) {
        uv_cond_signal_struct_inst.calls[opmock_i - 1] = uv_cond_signal_struct_inst.calls[opmock_i];
    }

    uv_cond_signal_struct_inst.expectedCalls--;
}

void uv_cond_signal_MockReset()
{
    uv_cond_signal_struct_inst.expectedCalls = 0;
    uv_cond_signal_struct_inst.actualCalls = 0;
    uv_cond_signal_struct_inst.callback = NULL;
}

void uv_cond_signal_MockWithCallback(OPMOCK_uv_cond_signal_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cond_signal_struct_inst.callback = callback;
    uv_cond_signal_struct_inst.expectedCalls = 0;
    uv_cond_signal_struct_inst.actualCalls = 0;
}

void uv_cond_signal_VerifyMock()
{
    if (uv_cond_signal_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cond_signal'",uv_cond_signal_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cond_signal_ExpectAndReturn (uv_cond_t * cond, OPMOCK_MATCHER match_cond)
{
    if(uv_cond_signal_struct_inst.callback != NULL)
    {
        uv_cond_signal_MockReset ();
    }

    if(uv_cond_signal_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cond_signal_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_cond_signal (uv_cond_t * cond)");
    uv_cond_signal_struct_inst.calls[uv_cond_signal_struct_inst.expectedCalls].cond = (void *)cond;
    uv_cond_signal_struct_inst.calls[uv_cond_signal_struct_inst.expectedCalls].match_cond = match_cond;
    uv_cond_signal_struct_inst.calls[uv_cond_signal_struct_inst.expectedCalls].check_params = 1;
    uv_cond_signal_struct_inst.expectedCalls++;
}

void uv_cond_broadcast(uv_cond_t * cond)
{
    int opmock_i;
    uv_cond_broadcast_struct_inst.actualCalls++;

    if (uv_cond_broadcast_struct_inst.callback != NULL)
    {
        uv_cond_broadcast_struct_inst.callback (cond, uv_cond_broadcast_struct_inst.actualCalls);
        return;
    }
    if (uv_cond_broadcast_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cond_broadcast', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_cond_broadcast (uv_cond_t * cond)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_cond_broadcast(uv_cond_t * cond)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cond_broadcast_struct_inst.calls[0].check_params == 1) {
        if(uv_cond_broadcast_struct_inst.calls[0].match_cond) {
            void * val1 = (void *) &uv_cond_broadcast_struct_inst.calls[0].cond;
            void * val2 = (void *) &cond;
            int match_result = uv_cond_broadcast_struct_inst.calls[0].match_cond(val1, val2, "cond", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_broadcast', %s",uv_cond_broadcast_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cond_broadcast_struct_inst.expectedCalls; opmock_i++) {
        uv_cond_broadcast_struct_inst.calls[opmock_i - 1] = uv_cond_broadcast_struct_inst.calls[opmock_i];
    }

    uv_cond_broadcast_struct_inst.expectedCalls--;
}

void uv_cond_broadcast_MockReset()
{
    uv_cond_broadcast_struct_inst.expectedCalls = 0;
    uv_cond_broadcast_struct_inst.actualCalls = 0;
    uv_cond_broadcast_struct_inst.callback = NULL;
}

void uv_cond_broadcast_MockWithCallback(OPMOCK_uv_cond_broadcast_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cond_broadcast_struct_inst.callback = callback;
    uv_cond_broadcast_struct_inst.expectedCalls = 0;
    uv_cond_broadcast_struct_inst.actualCalls = 0;
}

void uv_cond_broadcast_VerifyMock()
{
    if (uv_cond_broadcast_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cond_broadcast'",uv_cond_broadcast_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cond_broadcast_ExpectAndReturn (uv_cond_t * cond, OPMOCK_MATCHER match_cond)
{
    if(uv_cond_broadcast_struct_inst.callback != NULL)
    {
        uv_cond_broadcast_MockReset ();
    }

    if(uv_cond_broadcast_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cond_broadcast_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_cond_broadcast (uv_cond_t * cond)");
    uv_cond_broadcast_struct_inst.calls[uv_cond_broadcast_struct_inst.expectedCalls].cond = (void *)cond;
    uv_cond_broadcast_struct_inst.calls[uv_cond_broadcast_struct_inst.expectedCalls].match_cond = match_cond;
    uv_cond_broadcast_struct_inst.calls[uv_cond_broadcast_struct_inst.expectedCalls].check_params = 1;
    uv_cond_broadcast_struct_inst.expectedCalls++;
}

int uv_barrier_init(uv_barrier_t * barrier, unsigned int count)
{
    int default_res = (int)uv_barrier_init_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_barrier_init_struct_inst.actualCalls++;

    if (uv_barrier_init_struct_inst.callback != NULL)
    {
        return uv_barrier_init_struct_inst.callback (barrier, count, uv_barrier_init_struct_inst.actualCalls);
    }
    if (uv_barrier_init_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_barrier_init', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_barrier_init (uv_barrier_t * barrier, unsigned int count)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_barrier_init(uv_barrier_t * barrier, unsigned int count)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_barrier_init_struct_inst.calls[0].check_params == 1) {
        if(uv_barrier_init_struct_inst.calls[0].match_barrier) {
            void * val1 = (void *) &uv_barrier_init_struct_inst.calls[0].barrier;
            void * val2 = (void *) &barrier;
            int match_result = uv_barrier_init_struct_inst.calls[0].match_barrier(val1, val2, "barrier", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_barrier_init', %s",uv_barrier_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_barrier_init_struct_inst.calls[0].match_count) {
            void * val1 = (void *) &uv_barrier_init_struct_inst.calls[0].count;
            void * val2 = (void *) &count;
            int match_result = uv_barrier_init_struct_inst.calls[0].match_count(val1, val2, "count", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_barrier_init', %s",uv_barrier_init_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_barrier_init_struct_inst.expectedCalls; opmock_i++) {
        uv_barrier_init_struct_inst.calls[opmock_i - 1] = uv_barrier_init_struct_inst.calls[opmock_i];
    }

    uv_barrier_init_struct_inst.expectedCalls--;
    return default_res;
}

void uv_barrier_init_MockReset()
{
    uv_barrier_init_struct_inst.expectedCalls = 0;
    uv_barrier_init_struct_inst.actualCalls = 0;
    uv_barrier_init_struct_inst.callback = NULL;
}

void uv_barrier_init_MockWithCallback(OPMOCK_uv_barrier_init_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_barrier_init_struct_inst.callback = callback;
    uv_barrier_init_struct_inst.expectedCalls = 0;
    uv_barrier_init_struct_inst.actualCalls = 0;
}

void uv_barrier_init_VerifyMock()
{
    if (uv_barrier_init_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_barrier_init'",uv_barrier_init_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_barrier_init_ExpectAndReturn (uv_barrier_t * barrier, unsigned int count, int to_return, OPMOCK_MATCHER match_barrier, OPMOCK_MATCHER match_count)
{
    if(uv_barrier_init_struct_inst.callback != NULL)
    {
        uv_barrier_init_MockReset ();
    }

    if(uv_barrier_init_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_barrier_init_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_barrier_init (uv_barrier_t * barrier, unsigned int count)");
    uv_barrier_init_struct_inst.calls[uv_barrier_init_struct_inst.expectedCalls].barrier = (void *)barrier;
    uv_barrier_init_struct_inst.calls[uv_barrier_init_struct_inst.expectedCalls].count = (unsigned int)count;
    uv_barrier_init_struct_inst.calls[uv_barrier_init_struct_inst.expectedCalls].match_barrier = match_barrier;
    uv_barrier_init_struct_inst.calls[uv_barrier_init_struct_inst.expectedCalls].match_count = match_count;
    uv_barrier_init_struct_inst.calls[uv_barrier_init_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_barrier_init_struct_inst.calls[uv_barrier_init_struct_inst.expectedCalls].check_params = 1;
    uv_barrier_init_struct_inst.expectedCalls++;
}

void uv_barrier_destroy(uv_barrier_t * barrier)
{
    int opmock_i;
    uv_barrier_destroy_struct_inst.actualCalls++;

    if (uv_barrier_destroy_struct_inst.callback != NULL)
    {
        uv_barrier_destroy_struct_inst.callback (barrier, uv_barrier_destroy_struct_inst.actualCalls);
        return;
    }
    if (uv_barrier_destroy_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_barrier_destroy', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_barrier_destroy (uv_barrier_t * barrier)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_barrier_destroy(uv_barrier_t * barrier)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_barrier_destroy_struct_inst.calls[0].check_params == 1) {
        if(uv_barrier_destroy_struct_inst.calls[0].match_barrier) {
            void * val1 = (void *) &uv_barrier_destroy_struct_inst.calls[0].barrier;
            void * val2 = (void *) &barrier;
            int match_result = uv_barrier_destroy_struct_inst.calls[0].match_barrier(val1, val2, "barrier", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_barrier_destroy', %s",uv_barrier_destroy_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_barrier_destroy_struct_inst.expectedCalls; opmock_i++) {
        uv_barrier_destroy_struct_inst.calls[opmock_i - 1] = uv_barrier_destroy_struct_inst.calls[opmock_i];
    }

    uv_barrier_destroy_struct_inst.expectedCalls--;
}

void uv_barrier_destroy_MockReset()
{
    uv_barrier_destroy_struct_inst.expectedCalls = 0;
    uv_barrier_destroy_struct_inst.actualCalls = 0;
    uv_barrier_destroy_struct_inst.callback = NULL;
}

void uv_barrier_destroy_MockWithCallback(OPMOCK_uv_barrier_destroy_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_barrier_destroy_struct_inst.callback = callback;
    uv_barrier_destroy_struct_inst.expectedCalls = 0;
    uv_barrier_destroy_struct_inst.actualCalls = 0;
}

void uv_barrier_destroy_VerifyMock()
{
    if (uv_barrier_destroy_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_barrier_destroy'",uv_barrier_destroy_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_barrier_destroy_ExpectAndReturn (uv_barrier_t * barrier, OPMOCK_MATCHER match_barrier)
{
    if(uv_barrier_destroy_struct_inst.callback != NULL)
    {
        uv_barrier_destroy_MockReset ();
    }

    if(uv_barrier_destroy_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_barrier_destroy_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_barrier_destroy (uv_barrier_t * barrier)");
    uv_barrier_destroy_struct_inst.calls[uv_barrier_destroy_struct_inst.expectedCalls].barrier = (void *)barrier;
    uv_barrier_destroy_struct_inst.calls[uv_barrier_destroy_struct_inst.expectedCalls].match_barrier = match_barrier;
    uv_barrier_destroy_struct_inst.calls[uv_barrier_destroy_struct_inst.expectedCalls].check_params = 1;
    uv_barrier_destroy_struct_inst.expectedCalls++;
}

int uv_barrier_wait(uv_barrier_t * barrier)
{
    int default_res = (int)uv_barrier_wait_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_barrier_wait_struct_inst.actualCalls++;

    if (uv_barrier_wait_struct_inst.callback != NULL)
    {
        return uv_barrier_wait_struct_inst.callback (barrier, uv_barrier_wait_struct_inst.actualCalls);
    }
    if (uv_barrier_wait_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_barrier_wait', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_barrier_wait (uv_barrier_t * barrier)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_barrier_wait(uv_barrier_t * barrier)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_barrier_wait_struct_inst.calls[0].check_params == 1) {
        if(uv_barrier_wait_struct_inst.calls[0].match_barrier) {
            void * val1 = (void *) &uv_barrier_wait_struct_inst.calls[0].barrier;
            void * val2 = (void *) &barrier;
            int match_result = uv_barrier_wait_struct_inst.calls[0].match_barrier(val1, val2, "barrier", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_barrier_wait', %s",uv_barrier_wait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_barrier_wait_struct_inst.expectedCalls; opmock_i++) {
        uv_barrier_wait_struct_inst.calls[opmock_i - 1] = uv_barrier_wait_struct_inst.calls[opmock_i];
    }

    uv_barrier_wait_struct_inst.expectedCalls--;
    return default_res;
}

void uv_barrier_wait_MockReset()
{
    uv_barrier_wait_struct_inst.expectedCalls = 0;
    uv_barrier_wait_struct_inst.actualCalls = 0;
    uv_barrier_wait_struct_inst.callback = NULL;
}

void uv_barrier_wait_MockWithCallback(OPMOCK_uv_barrier_wait_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_barrier_wait_struct_inst.callback = callback;
    uv_barrier_wait_struct_inst.expectedCalls = 0;
    uv_barrier_wait_struct_inst.actualCalls = 0;
}

void uv_barrier_wait_VerifyMock()
{
    if (uv_barrier_wait_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_barrier_wait'",uv_barrier_wait_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_barrier_wait_ExpectAndReturn (uv_barrier_t * barrier, int to_return, OPMOCK_MATCHER match_barrier)
{
    if(uv_barrier_wait_struct_inst.callback != NULL)
    {
        uv_barrier_wait_MockReset ();
    }

    if(uv_barrier_wait_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_barrier_wait_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_barrier_wait (uv_barrier_t * barrier)");
    uv_barrier_wait_struct_inst.calls[uv_barrier_wait_struct_inst.expectedCalls].barrier = (void *)barrier;
    uv_barrier_wait_struct_inst.calls[uv_barrier_wait_struct_inst.expectedCalls].match_barrier = match_barrier;
    uv_barrier_wait_struct_inst.calls[uv_barrier_wait_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_barrier_wait_struct_inst.calls[uv_barrier_wait_struct_inst.expectedCalls].check_params = 1;
    uv_barrier_wait_struct_inst.expectedCalls++;
}

void uv_cond_wait(uv_cond_t * cond, uv_mutex_t * mutex)
{
    int opmock_i;
    uv_cond_wait_struct_inst.actualCalls++;

    if (uv_cond_wait_struct_inst.callback != NULL)
    {
        uv_cond_wait_struct_inst.callback (cond, mutex, uv_cond_wait_struct_inst.actualCalls);
        return;
    }
    if (uv_cond_wait_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cond_wait', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_cond_wait (uv_cond_t * cond, uv_mutex_t * mutex)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_cond_wait(uv_cond_t * cond, uv_mutex_t * mutex)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cond_wait_struct_inst.calls[0].check_params == 1) {
        if(uv_cond_wait_struct_inst.calls[0].match_cond) {
            void * val1 = (void *) &uv_cond_wait_struct_inst.calls[0].cond;
            void * val2 = (void *) &cond;
            int match_result = uv_cond_wait_struct_inst.calls[0].match_cond(val1, val2, "cond", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_wait', %s",uv_cond_wait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_cond_wait_struct_inst.calls[0].match_mutex) {
            void * val1 = (void *) &uv_cond_wait_struct_inst.calls[0].mutex;
            void * val2 = (void *) &mutex;
            int match_result = uv_cond_wait_struct_inst.calls[0].match_mutex(val1, val2, "mutex", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_wait', %s",uv_cond_wait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cond_wait_struct_inst.expectedCalls; opmock_i++) {
        uv_cond_wait_struct_inst.calls[opmock_i - 1] = uv_cond_wait_struct_inst.calls[opmock_i];
    }

    uv_cond_wait_struct_inst.expectedCalls--;
}

void uv_cond_wait_MockReset()
{
    uv_cond_wait_struct_inst.expectedCalls = 0;
    uv_cond_wait_struct_inst.actualCalls = 0;
    uv_cond_wait_struct_inst.callback = NULL;
}

void uv_cond_wait_MockWithCallback(OPMOCK_uv_cond_wait_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cond_wait_struct_inst.callback = callback;
    uv_cond_wait_struct_inst.expectedCalls = 0;
    uv_cond_wait_struct_inst.actualCalls = 0;
}

void uv_cond_wait_VerifyMock()
{
    if (uv_cond_wait_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cond_wait'",uv_cond_wait_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cond_wait_ExpectAndReturn (uv_cond_t * cond, uv_mutex_t * mutex, OPMOCK_MATCHER match_cond, OPMOCK_MATCHER match_mutex)
{
    if(uv_cond_wait_struct_inst.callback != NULL)
    {
        uv_cond_wait_MockReset ();
    }

    if(uv_cond_wait_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cond_wait_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_cond_wait (uv_cond_t * cond, uv_mutex_t * mutex)");
    uv_cond_wait_struct_inst.calls[uv_cond_wait_struct_inst.expectedCalls].cond = (void *)cond;
    uv_cond_wait_struct_inst.calls[uv_cond_wait_struct_inst.expectedCalls].mutex = (void *)mutex;
    uv_cond_wait_struct_inst.calls[uv_cond_wait_struct_inst.expectedCalls].match_cond = match_cond;
    uv_cond_wait_struct_inst.calls[uv_cond_wait_struct_inst.expectedCalls].match_mutex = match_mutex;
    uv_cond_wait_struct_inst.calls[uv_cond_wait_struct_inst.expectedCalls].check_params = 1;
    uv_cond_wait_struct_inst.expectedCalls++;
}

int uv_cond_timedwait(uv_cond_t * cond, uv_mutex_t * mutex, uint64_t timeout)
{
    int default_res = (int)uv_cond_timedwait_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_cond_timedwait_struct_inst.actualCalls++;

    if (uv_cond_timedwait_struct_inst.callback != NULL)
    {
        return uv_cond_timedwait_struct_inst.callback (cond, mutex, timeout, uv_cond_timedwait_struct_inst.actualCalls);
    }
    if (uv_cond_timedwait_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_cond_timedwait', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_cond_timedwait (uv_cond_t * cond, uv_mutex_t * mutex, uint64_t timeout)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_cond_timedwait(uv_cond_t * cond, uv_mutex_t * mutex, uint64_t timeout)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_cond_timedwait_struct_inst.calls[0].check_params == 1) {
        if(uv_cond_timedwait_struct_inst.calls[0].match_cond) {
            void * val1 = (void *) &uv_cond_timedwait_struct_inst.calls[0].cond;
            void * val2 = (void *) &cond;
            int match_result = uv_cond_timedwait_struct_inst.calls[0].match_cond(val1, val2, "cond", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_timedwait', %s",uv_cond_timedwait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_cond_timedwait_struct_inst.calls[0].match_mutex) {
            void * val1 = (void *) &uv_cond_timedwait_struct_inst.calls[0].mutex;
            void * val2 = (void *) &mutex;
            int match_result = uv_cond_timedwait_struct_inst.calls[0].match_mutex(val1, val2, "mutex", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_timedwait', %s",uv_cond_timedwait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_cond_timedwait_struct_inst.calls[0].match_timeout) {
            void * val1 = (void *) &uv_cond_timedwait_struct_inst.calls[0].timeout;
            void * val2 = (void *) &timeout;
            int match_result = uv_cond_timedwait_struct_inst.calls[0].match_timeout(val1, val2, "timeout", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_cond_timedwait', %s",uv_cond_timedwait_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_cond_timedwait_struct_inst.expectedCalls; opmock_i++) {
        uv_cond_timedwait_struct_inst.calls[opmock_i - 1] = uv_cond_timedwait_struct_inst.calls[opmock_i];
    }

    uv_cond_timedwait_struct_inst.expectedCalls--;
    return default_res;
}

void uv_cond_timedwait_MockReset()
{
    uv_cond_timedwait_struct_inst.expectedCalls = 0;
    uv_cond_timedwait_struct_inst.actualCalls = 0;
    uv_cond_timedwait_struct_inst.callback = NULL;
}

void uv_cond_timedwait_MockWithCallback(OPMOCK_uv_cond_timedwait_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_cond_timedwait_struct_inst.callback = callback;
    uv_cond_timedwait_struct_inst.expectedCalls = 0;
    uv_cond_timedwait_struct_inst.actualCalls = 0;
}

void uv_cond_timedwait_VerifyMock()
{
    if (uv_cond_timedwait_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_cond_timedwait'",uv_cond_timedwait_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_cond_timedwait_ExpectAndReturn (uv_cond_t * cond, uv_mutex_t * mutex, uint64_t timeout, int to_return, OPMOCK_MATCHER match_cond, OPMOCK_MATCHER match_mutex, OPMOCK_MATCHER match_timeout)
{
    if(uv_cond_timedwait_struct_inst.callback != NULL)
    {
        uv_cond_timedwait_MockReset ();
    }

    if(uv_cond_timedwait_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_cond_timedwait_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_cond_timedwait (uv_cond_t * cond, uv_mutex_t * mutex, uint64_t timeout)");
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].cond = (void *)cond;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].mutex = (void *)mutex;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].timeout = (unsigned long long)timeout;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].match_cond = match_cond;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].match_mutex = match_mutex;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].match_timeout = match_timeout;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_cond_timedwait_struct_inst.calls[uv_cond_timedwait_struct_inst.expectedCalls].check_params = 1;
    uv_cond_timedwait_struct_inst.expectedCalls++;
}

void uv_once(uv_once_t * guard, void (* callback )(void))
{
    int opmock_i;
    uv_once_struct_inst.actualCalls++;

    if (uv_once_struct_inst.callback != NULL)
    {
        uv_once_struct_inst.callback (guard, callback, uv_once_struct_inst.actualCalls);
        return;
    }
    if (uv_once_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_once', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_once (uv_once_t * guard, void (* callback )(void))") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_once(uv_once_t * guard, void (* callback )(void))',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_once_struct_inst.calls[0].check_params == 1) {
        if(uv_once_struct_inst.calls[0].match_guard) {
            void * val1 = (void *) &uv_once_struct_inst.calls[0].guard;
            void * val2 = (void *) &guard;
            int match_result = uv_once_struct_inst.calls[0].match_guard(val1, val2, "guard", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_once', %s",uv_once_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_once_struct_inst.calls[0].match_callback) {
            void * val1 = (void *) &uv_once_struct_inst.calls[0].callback;
            void * val2 = (void *) &callback;
            int match_result = uv_once_struct_inst.calls[0].match_callback(val1, val2, "callback", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_once', %s",uv_once_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_once_struct_inst.expectedCalls; opmock_i++) {
        uv_once_struct_inst.calls[opmock_i - 1] = uv_once_struct_inst.calls[opmock_i];
    }

    uv_once_struct_inst.expectedCalls--;
}

void uv_once_MockReset()
{
    uv_once_struct_inst.expectedCalls = 0;
    uv_once_struct_inst.actualCalls = 0;
    uv_once_struct_inst.callback = NULL;
}

void uv_once_MockWithCallback(OPMOCK_uv_once_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_once_struct_inst.callback = callback;
    uv_once_struct_inst.expectedCalls = 0;
    uv_once_struct_inst.actualCalls = 0;
}

void uv_once_VerifyMock()
{
    if (uv_once_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_once'",uv_once_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_once_ExpectAndReturn (uv_once_t * guard, void (* callback )(void), OPMOCK_MATCHER match_guard, OPMOCK_MATCHER match_callback)
{
    if(uv_once_struct_inst.callback != NULL)
    {
        uv_once_MockReset ();
    }

    if(uv_once_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_once_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_once (uv_once_t * guard, void (* callback )(void))");
    uv_once_struct_inst.calls[uv_once_struct_inst.expectedCalls].guard = (void *)guard;
    uv_once_struct_inst.calls[uv_once_struct_inst.expectedCalls].callback = (void *)callback;
    uv_once_struct_inst.calls[uv_once_struct_inst.expectedCalls].match_guard = match_guard;
    uv_once_struct_inst.calls[uv_once_struct_inst.expectedCalls].match_callback = match_callback;
    uv_once_struct_inst.calls[uv_once_struct_inst.expectedCalls].check_params = 1;
    uv_once_struct_inst.expectedCalls++;
}

int uv_key_create(uv_key_t * key)
{
    int default_res = (int)uv_key_create_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_key_create_struct_inst.actualCalls++;

    if (uv_key_create_struct_inst.callback != NULL)
    {
        return uv_key_create_struct_inst.callback (key, uv_key_create_struct_inst.actualCalls);
    }
    if (uv_key_create_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_key_create', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_key_create (uv_key_t * key)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_key_create(uv_key_t * key)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_key_create_struct_inst.calls[0].check_params == 1) {
        if(uv_key_create_struct_inst.calls[0].match_key) {
            void * val1 = (void *) &uv_key_create_struct_inst.calls[0].key;
            void * val2 = (void *) &key;
            int match_result = uv_key_create_struct_inst.calls[0].match_key(val1, val2, "key", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_key_create', %s",uv_key_create_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_key_create_struct_inst.expectedCalls; opmock_i++) {
        uv_key_create_struct_inst.calls[opmock_i - 1] = uv_key_create_struct_inst.calls[opmock_i];
    }

    uv_key_create_struct_inst.expectedCalls--;
    return default_res;
}

void uv_key_create_MockReset()
{
    uv_key_create_struct_inst.expectedCalls = 0;
    uv_key_create_struct_inst.actualCalls = 0;
    uv_key_create_struct_inst.callback = NULL;
}

void uv_key_create_MockWithCallback(OPMOCK_uv_key_create_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_key_create_struct_inst.callback = callback;
    uv_key_create_struct_inst.expectedCalls = 0;
    uv_key_create_struct_inst.actualCalls = 0;
}

void uv_key_create_VerifyMock()
{
    if (uv_key_create_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_key_create'",uv_key_create_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_key_create_ExpectAndReturn (uv_key_t * key, int to_return, OPMOCK_MATCHER match_key)
{
    if(uv_key_create_struct_inst.callback != NULL)
    {
        uv_key_create_MockReset ();
    }

    if(uv_key_create_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_key_create_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_key_create (uv_key_t * key)");
    uv_key_create_struct_inst.calls[uv_key_create_struct_inst.expectedCalls].key = (void *)key;
    uv_key_create_struct_inst.calls[uv_key_create_struct_inst.expectedCalls].match_key = match_key;
    uv_key_create_struct_inst.calls[uv_key_create_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_key_create_struct_inst.calls[uv_key_create_struct_inst.expectedCalls].check_params = 1;
    uv_key_create_struct_inst.expectedCalls++;
}

void uv_key_delete(uv_key_t * key)
{
    int opmock_i;
    uv_key_delete_struct_inst.actualCalls++;

    if (uv_key_delete_struct_inst.callback != NULL)
    {
        uv_key_delete_struct_inst.callback (key, uv_key_delete_struct_inst.actualCalls);
        return;
    }
    if (uv_key_delete_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_key_delete', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_key_delete (uv_key_t * key)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_key_delete(uv_key_t * key)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_key_delete_struct_inst.calls[0].check_params == 1) {
        if(uv_key_delete_struct_inst.calls[0].match_key) {
            void * val1 = (void *) &uv_key_delete_struct_inst.calls[0].key;
            void * val2 = (void *) &key;
            int match_result = uv_key_delete_struct_inst.calls[0].match_key(val1, val2, "key", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_key_delete', %s",uv_key_delete_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_key_delete_struct_inst.expectedCalls; opmock_i++) {
        uv_key_delete_struct_inst.calls[opmock_i - 1] = uv_key_delete_struct_inst.calls[opmock_i];
    }

    uv_key_delete_struct_inst.expectedCalls--;
}

void uv_key_delete_MockReset()
{
    uv_key_delete_struct_inst.expectedCalls = 0;
    uv_key_delete_struct_inst.actualCalls = 0;
    uv_key_delete_struct_inst.callback = NULL;
}

void uv_key_delete_MockWithCallback(OPMOCK_uv_key_delete_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_key_delete_struct_inst.callback = callback;
    uv_key_delete_struct_inst.expectedCalls = 0;
    uv_key_delete_struct_inst.actualCalls = 0;
}

void uv_key_delete_VerifyMock()
{
    if (uv_key_delete_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_key_delete'",uv_key_delete_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_key_delete_ExpectAndReturn (uv_key_t * key, OPMOCK_MATCHER match_key)
{
    if(uv_key_delete_struct_inst.callback != NULL)
    {
        uv_key_delete_MockReset ();
    }

    if(uv_key_delete_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_key_delete_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_key_delete (uv_key_t * key)");
    uv_key_delete_struct_inst.calls[uv_key_delete_struct_inst.expectedCalls].key = (void *)key;
    uv_key_delete_struct_inst.calls[uv_key_delete_struct_inst.expectedCalls].match_key = match_key;
    uv_key_delete_struct_inst.calls[uv_key_delete_struct_inst.expectedCalls].check_params = 1;
    uv_key_delete_struct_inst.expectedCalls++;
}

void * uv_key_get(uv_key_t * key)
{
    void * default_res = (void *)uv_key_get_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_key_get_struct_inst.actualCalls++;

    if (uv_key_get_struct_inst.callback != NULL)
    {
        return uv_key_get_struct_inst.callback (key, uv_key_get_struct_inst.actualCalls);
    }
    if (uv_key_get_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_key_get', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "void * uv_key_get (uv_key_t * key)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void * uv_key_get(uv_key_t * key)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_key_get_struct_inst.calls[0].check_params == 1) {
        if(uv_key_get_struct_inst.calls[0].match_key) {
            void * val1 = (void *) &uv_key_get_struct_inst.calls[0].key;
            void * val2 = (void *) &key;
            int match_result = uv_key_get_struct_inst.calls[0].match_key(val1, val2, "key", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_key_get', %s",uv_key_get_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_key_get_struct_inst.expectedCalls; opmock_i++) {
        uv_key_get_struct_inst.calls[opmock_i - 1] = uv_key_get_struct_inst.calls[opmock_i];
    }

    uv_key_get_struct_inst.expectedCalls--;
    return default_res;
}

void uv_key_get_MockReset()
{
    uv_key_get_struct_inst.expectedCalls = 0;
    uv_key_get_struct_inst.actualCalls = 0;
    uv_key_get_struct_inst.callback = NULL;
}

void uv_key_get_MockWithCallback(OPMOCK_uv_key_get_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_key_get_struct_inst.callback = callback;
    uv_key_get_struct_inst.expectedCalls = 0;
    uv_key_get_struct_inst.actualCalls = 0;
}

void uv_key_get_VerifyMock()
{
    if (uv_key_get_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_key_get'",uv_key_get_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_key_get_ExpectAndReturn (uv_key_t * key, void * to_return, OPMOCK_MATCHER match_key)
{
    if(uv_key_get_struct_inst.callback != NULL)
    {
        uv_key_get_MockReset ();
    }

    if(uv_key_get_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_key_get_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void * uv_key_get (uv_key_t * key)");
    uv_key_get_struct_inst.calls[uv_key_get_struct_inst.expectedCalls].key = (void *)key;
    uv_key_get_struct_inst.calls[uv_key_get_struct_inst.expectedCalls].match_key = match_key;
    uv_key_get_struct_inst.calls[uv_key_get_struct_inst.expectedCalls].to_return = (void *) to_return;
    uv_key_get_struct_inst.calls[uv_key_get_struct_inst.expectedCalls].check_params = 1;
    uv_key_get_struct_inst.expectedCalls++;
}

void uv_key_set(uv_key_t * key, void * value)
{
    int opmock_i;
    uv_key_set_struct_inst.actualCalls++;

    if (uv_key_set_struct_inst.callback != NULL)
    {
        uv_key_set_struct_inst.callback (key, value, uv_key_set_struct_inst.actualCalls);
        return;
    }
    if (uv_key_set_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_key_set', returning random value.");
        return;
    }

    if(strcmp(opmock_get_current_call(), "void uv_key_set (uv_key_t * key, void * value)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'void uv_key_set(uv_key_t * key, void * value)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_key_set_struct_inst.calls[0].check_params == 1) {
        if(uv_key_set_struct_inst.calls[0].match_key) {
            void * val1 = (void *) &uv_key_set_struct_inst.calls[0].key;
            void * val2 = (void *) &key;
            int match_result = uv_key_set_struct_inst.calls[0].match_key(val1, val2, "key", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_key_set', %s",uv_key_set_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_key_set_struct_inst.calls[0].match_value) {
            void * val1 = (void *) &uv_key_set_struct_inst.calls[0].value;
            void * val2 = (void *) &value;
            int match_result = uv_key_set_struct_inst.calls[0].match_value(val1, val2, "value", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_key_set', %s",uv_key_set_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_key_set_struct_inst.expectedCalls; opmock_i++) {
        uv_key_set_struct_inst.calls[opmock_i - 1] = uv_key_set_struct_inst.calls[opmock_i];
    }

    uv_key_set_struct_inst.expectedCalls--;
}

void uv_key_set_MockReset()
{
    uv_key_set_struct_inst.expectedCalls = 0;
    uv_key_set_struct_inst.actualCalls = 0;
    uv_key_set_struct_inst.callback = NULL;
}

void uv_key_set_MockWithCallback(OPMOCK_uv_key_set_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_key_set_struct_inst.callback = callback;
    uv_key_set_struct_inst.expectedCalls = 0;
    uv_key_set_struct_inst.actualCalls = 0;
}

void uv_key_set_VerifyMock()
{
    if (uv_key_set_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_key_set'",uv_key_set_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_key_set_ExpectAndReturn (uv_key_t * key, void * value, OPMOCK_MATCHER match_key, OPMOCK_MATCHER match_value)
{
    if(uv_key_set_struct_inst.callback != NULL)
    {
        uv_key_set_MockReset ();
    }

    if(uv_key_set_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_key_set_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"void uv_key_set (uv_key_t * key, void * value)");
    uv_key_set_struct_inst.calls[uv_key_set_struct_inst.expectedCalls].key = (void *)key;
    uv_key_set_struct_inst.calls[uv_key_set_struct_inst.expectedCalls].value = (void *)value;
    uv_key_set_struct_inst.calls[uv_key_set_struct_inst.expectedCalls].match_key = match_key;
    uv_key_set_struct_inst.calls[uv_key_set_struct_inst.expectedCalls].match_value = match_value;
    uv_key_set_struct_inst.calls[uv_key_set_struct_inst.expectedCalls].check_params = 1;
    uv_key_set_struct_inst.expectedCalls++;
}

int uv_thread_create(uv_thread_t * tid, uv_thread_cb entry, void * arg)
{
    int default_res = (int)uv_thread_create_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_thread_create_struct_inst.actualCalls++;

    if (uv_thread_create_struct_inst.callback != NULL)
    {
        return uv_thread_create_struct_inst.callback (tid, entry, arg, uv_thread_create_struct_inst.actualCalls);
    }
    if (uv_thread_create_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_thread_create', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_thread_create (uv_thread_t * tid, uv_thread_cb entry, void * arg)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_thread_create(uv_thread_t * tid, uv_thread_cb entry, void * arg)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_thread_create_struct_inst.calls[0].check_params == 1) {
        if(uv_thread_create_struct_inst.calls[0].match_tid) {
            void * val1 = (void *) &uv_thread_create_struct_inst.calls[0].tid;
            void * val2 = (void *) &tid;
            int match_result = uv_thread_create_struct_inst.calls[0].match_tid(val1, val2, "tid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_thread_create', %s",uv_thread_create_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_thread_create_struct_inst.calls[0].match_entry) {
            void * val1 = (void *) &uv_thread_create_struct_inst.calls[0].entry;
            void * val2 = (void *) &entry;
            int match_result = uv_thread_create_struct_inst.calls[0].match_entry(val1, val2, "entry", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_thread_create', %s",uv_thread_create_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_thread_create_struct_inst.calls[0].match_arg) {
            void * val1 = (void *) &uv_thread_create_struct_inst.calls[0].arg;
            void * val2 = (void *) &arg;
            int match_result = uv_thread_create_struct_inst.calls[0].match_arg(val1, val2, "arg", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_thread_create', %s",uv_thread_create_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_thread_create_struct_inst.expectedCalls; opmock_i++) {
        uv_thread_create_struct_inst.calls[opmock_i - 1] = uv_thread_create_struct_inst.calls[opmock_i];
    }

    uv_thread_create_struct_inst.expectedCalls--;
    return default_res;
}

void uv_thread_create_MockReset()
{
    uv_thread_create_struct_inst.expectedCalls = 0;
    uv_thread_create_struct_inst.actualCalls = 0;
    uv_thread_create_struct_inst.callback = NULL;
}

void uv_thread_create_MockWithCallback(OPMOCK_uv_thread_create_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_thread_create_struct_inst.callback = callback;
    uv_thread_create_struct_inst.expectedCalls = 0;
    uv_thread_create_struct_inst.actualCalls = 0;
}

void uv_thread_create_VerifyMock()
{
    if (uv_thread_create_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_thread_create'",uv_thread_create_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_thread_create_ExpectAndReturn (uv_thread_t * tid, uv_thread_cb entry, void * arg, int to_return, OPMOCK_MATCHER match_tid, OPMOCK_MATCHER match_entry, OPMOCK_MATCHER match_arg)
{
    if(uv_thread_create_struct_inst.callback != NULL)
    {
        uv_thread_create_MockReset ();
    }

    if(uv_thread_create_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_thread_create_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_thread_create (uv_thread_t * tid, uv_thread_cb entry, void * arg)");
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].tid = (void *)tid;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].entry = (void *)entry;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].arg = (void *)arg;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].match_tid = match_tid;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].match_entry = match_entry;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].match_arg = match_arg;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_thread_create_struct_inst.calls[uv_thread_create_struct_inst.expectedCalls].check_params = 1;
    uv_thread_create_struct_inst.expectedCalls++;
}

uv_thread_t uv_thread_self()
{
    uv_thread_t default_res = (uv_thread_t)uv_thread_self_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_thread_self_struct_inst.actualCalls++;

    if (uv_thread_self_struct_inst.callback != NULL)
    {
        return uv_thread_self_struct_inst.callback (uv_thread_self_struct_inst.actualCalls);
    }
    if (uv_thread_self_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_thread_self', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "uv_thread_t uv_thread_self ()") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'uv_thread_t uv_thread_self()',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_thread_self_struct_inst.calls[0].check_params == 1) {
    }

    for(opmock_i = 1; opmock_i < uv_thread_self_struct_inst.expectedCalls; opmock_i++) {
        uv_thread_self_struct_inst.calls[opmock_i - 1] = uv_thread_self_struct_inst.calls[opmock_i];
    }

    uv_thread_self_struct_inst.expectedCalls--;
    return default_res;
}

void uv_thread_self_MockReset()
{
    uv_thread_self_struct_inst.expectedCalls = 0;
    uv_thread_self_struct_inst.actualCalls = 0;
    uv_thread_self_struct_inst.callback = NULL;
}

void uv_thread_self_MockWithCallback(OPMOCK_uv_thread_self_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_thread_self_struct_inst.callback = callback;
    uv_thread_self_struct_inst.expectedCalls = 0;
    uv_thread_self_struct_inst.actualCalls = 0;
}

void uv_thread_self_VerifyMock()
{
    if (uv_thread_self_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_thread_self'",uv_thread_self_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_thread_self_ExpectAndReturn (uv_thread_t to_return)
{
    if(uv_thread_self_struct_inst.callback != NULL)
    {
        uv_thread_self_MockReset ();
    }

    if(uv_thread_self_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_thread_self_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"uv_thread_t uv_thread_self ()");
    uv_thread_self_struct_inst.calls[uv_thread_self_struct_inst.expectedCalls].to_return = (struct _opaque_pthread_t *) to_return;
    uv_thread_self_struct_inst.calls[uv_thread_self_struct_inst.expectedCalls].check_params = 1;
    uv_thread_self_struct_inst.expectedCalls++;
}

int uv_thread_join(uv_thread_t * tid)
{
    int default_res = (int)uv_thread_join_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_thread_join_struct_inst.actualCalls++;

    if (uv_thread_join_struct_inst.callback != NULL)
    {
        return uv_thread_join_struct_inst.callback (tid, uv_thread_join_struct_inst.actualCalls);
    }
    if (uv_thread_join_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_thread_join', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_thread_join (uv_thread_t * tid)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_thread_join(uv_thread_t * tid)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_thread_join_struct_inst.calls[0].check_params == 1) {
        if(uv_thread_join_struct_inst.calls[0].match_tid) {
            void * val1 = (void *) &uv_thread_join_struct_inst.calls[0].tid;
            void * val2 = (void *) &tid;
            int match_result = uv_thread_join_struct_inst.calls[0].match_tid(val1, val2, "tid", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_thread_join', %s",uv_thread_join_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_thread_join_struct_inst.expectedCalls; opmock_i++) {
        uv_thread_join_struct_inst.calls[opmock_i - 1] = uv_thread_join_struct_inst.calls[opmock_i];
    }

    uv_thread_join_struct_inst.expectedCalls--;
    return default_res;
}

void uv_thread_join_MockReset()
{
    uv_thread_join_struct_inst.expectedCalls = 0;
    uv_thread_join_struct_inst.actualCalls = 0;
    uv_thread_join_struct_inst.callback = NULL;
}

void uv_thread_join_MockWithCallback(OPMOCK_uv_thread_join_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_thread_join_struct_inst.callback = callback;
    uv_thread_join_struct_inst.expectedCalls = 0;
    uv_thread_join_struct_inst.actualCalls = 0;
}

void uv_thread_join_VerifyMock()
{
    if (uv_thread_join_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_thread_join'",uv_thread_join_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_thread_join_ExpectAndReturn (uv_thread_t * tid, int to_return, OPMOCK_MATCHER match_tid)
{
    if(uv_thread_join_struct_inst.callback != NULL)
    {
        uv_thread_join_MockReset ();
    }

    if(uv_thread_join_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_thread_join_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_thread_join (uv_thread_t * tid)");
    uv_thread_join_struct_inst.calls[uv_thread_join_struct_inst.expectedCalls].tid = (void *)tid;
    uv_thread_join_struct_inst.calls[uv_thread_join_struct_inst.expectedCalls].match_tid = match_tid;
    uv_thread_join_struct_inst.calls[uv_thread_join_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_thread_join_struct_inst.calls[uv_thread_join_struct_inst.expectedCalls].check_params = 1;
    uv_thread_join_struct_inst.expectedCalls++;
}

int uv_thread_equal(const uv_thread_t * t1, const uv_thread_t * t2)
{
    int default_res = (int)uv_thread_equal_struct_inst.calls[0].to_return;
    int opmock_i;
    uv_thread_equal_struct_inst.actualCalls++;

    if (uv_thread_equal_struct_inst.callback != NULL)
    {
        return uv_thread_equal_struct_inst.callback (t1, t2, uv_thread_equal_struct_inst.actualCalls);
    }
    if (uv_thread_equal_struct_inst.expectedCalls == 0)
    {
        opmock_add_error_message((char *) "WARNING : unexpected call of 'uv_thread_equal', returning random value.");
        return default_res;
    }

    if(strcmp(opmock_get_current_call(), "int uv_thread_equal (const uv_thread_t * t1, const uv_thread_t * t2)") != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : got call to 'int uv_thread_equal(const uv_thread_t * t1, const uv_thread_t * t2)',  but was expecting call to '%s'", opmock_get_current_call());
        opmock_add_error_message(buffer);
    }
    opmock_pop_call();

    if (uv_thread_equal_struct_inst.calls[0].check_params == 1) {
        if(uv_thread_equal_struct_inst.calls[0].match_t1) {
            void * val1 = (void *) &uv_thread_equal_struct_inst.calls[0].t1;
            void * val2 = (void *) &t1;
            int match_result = uv_thread_equal_struct_inst.calls[0].match_t1(val1, val2, "t1", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_thread_equal', %s",uv_thread_equal_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
        if(uv_thread_equal_struct_inst.calls[0].match_t2) {
            void * val1 = (void *) &uv_thread_equal_struct_inst.calls[0].t2;
            void * val2 = (void *) &t2;
            int match_result = uv_thread_equal_struct_inst.calls[0].match_t2(val1, val2, "t2", get_matcher_message());
            if(match_result){
                char buffer[OP_ERROR_MESSAGE_LENGTH];
                snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : on call number %d of 'uv_thread_equal', %s",uv_thread_equal_struct_inst.actualCalls, get_matcher_message());
                opmock_add_error_message((char *) buffer);
            }
        }
    }

    for(opmock_i = 1; opmock_i < uv_thread_equal_struct_inst.expectedCalls; opmock_i++) {
        uv_thread_equal_struct_inst.calls[opmock_i - 1] = uv_thread_equal_struct_inst.calls[opmock_i];
    }

    uv_thread_equal_struct_inst.expectedCalls--;
    return default_res;
}

void uv_thread_equal_MockReset()
{
    uv_thread_equal_struct_inst.expectedCalls = 0;
    uv_thread_equal_struct_inst.actualCalls = 0;
    uv_thread_equal_struct_inst.callback = NULL;
}

void uv_thread_equal_MockWithCallback(OPMOCK_uv_thread_equal_CALLBACK callback)
{
    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    uv_thread_equal_struct_inst.callback = callback;
    uv_thread_equal_struct_inst.expectedCalls = 0;
    uv_thread_equal_struct_inst.actualCalls = 0;
}

void uv_thread_equal_VerifyMock()
{
    if (uv_thread_equal_struct_inst.expectedCalls != 0) {
        char buffer[OP_ERROR_MESSAGE_LENGTH];
        snprintf(buffer, OP_ERROR_MESSAGE_LENGTH, "WARNING : Bad number of calls (%d) for 'uv_thread_equal'",uv_thread_equal_struct_inst.actualCalls);
        opmock_add_error_message((char *) buffer);
    }
}

void uv_thread_equal_ExpectAndReturn (const uv_thread_t * t1, const uv_thread_t * t2, int to_return, OPMOCK_MATCHER match_t1, OPMOCK_MATCHER match_t2)
{
    if(uv_thread_equal_struct_inst.callback != NULL)
    {
        uv_thread_equal_MockReset ();
    }

    if(uv_thread_equal_struct_inst.expectedCalls >= MAX_FUNC_CALL)
    {
        printf("WARNING : aborting uv_thread_equal_ExpectAndReturn, call stack overload.");
        return;
    }

    opmock_add_reset_callback(opmock_reset_all_mocks_in_this_header);
    opmock_add_verify_callback(opmock_verify_all_mocks_in_this_header);
    opmock_add_call((char *)"int uv_thread_equal (const uv_thread_t * t1, const uv_thread_t * t2)");
    uv_thread_equal_struct_inst.calls[uv_thread_equal_struct_inst.expectedCalls].t1 = (void *)t1;
    uv_thread_equal_struct_inst.calls[uv_thread_equal_struct_inst.expectedCalls].t2 = (void *)t2;
    uv_thread_equal_struct_inst.calls[uv_thread_equal_struct_inst.expectedCalls].match_t1 = match_t1;
    uv_thread_equal_struct_inst.calls[uv_thread_equal_struct_inst.expectedCalls].match_t2 = match_t2;
    uv_thread_equal_struct_inst.calls[uv_thread_equal_struct_inst.expectedCalls].to_return = (int) to_return;
    uv_thread_equal_struct_inst.calls[uv_thread_equal_struct_inst.expectedCalls].check_params = 1;
    uv_thread_equal_struct_inst.expectedCalls++;
}

